{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Creating a Discord Bot","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This is a tutorial on how to create a Discord bot using the discord.py library. This tutorial will cover the basics of creating a bot and how to use the library's commands and events. To follow this tutorial, you will need to have Python 3.8 or higher installed on your computer. You can download Python here.</p>"},{"location":"#installing-python","title":"Installing Python","text":"<p>To install Python, you will need to go to the Python website and download the latest version of Python. It's recommended to at least have Python <code>3.8&gt;=</code> installed on your computer. For more ease of use of python and easily leveraging features like more convenient typehints, it's recommended to install <code>3.10</code> or higher.</p> <p></p>"},{"location":"#for-linux","title":"For Linux","text":"<p>If you are using Linux, you can install Python using your package manager. For example, if you are using Ubuntu, you can install Python using the following command:</p> <pre><code>sudo apt install python3.9\n</code></pre> <p>Note</p> <p>Depending on your Linux distribution, you may need to use a different command to install Python. Also, based on your linux distro version you may already have python installed. To check if you have python installed, you can run <code>python3 --version</code> in your terminal.</p> <p>Most linux distros however don't come with <code>pip</code> installed. To install <code>pip</code> you can run <code>sudo apt install python3-pip</code> in your terminal. <pre><code>sudo apt install python3-pip\n</code></pre></p>"},{"location":"#verify-installation","title":"Verify Installation","text":"<p>To verify that you have Python installed, you can run the following command in your terminal:</p> WindowsMac &amp; Linux <pre><code>py --version\n</code></pre> <pre><code>python3 --version\n</code></pre> <p>Note</p> <p>Depending on your Python installation, the version displayed may be different.</p> <p></p>"},{"location":"#for-windows-mac","title":"For Windows &amp; Mac","text":"<p>When installing Python on Windows or Mac, you will need to make sure that you have the <code>Add Python to PATH</code> option checked. This will allow you to use Python in your command prompt or terminal.</p>"},{"location":"#creating-a-bot","title":"Creating a Bot","text":"<p>To interact with the Discord API, we need to create a bot. To do this, we need to go to the Discord Developer Portal and create a new application.</p> <p></p>"},{"location":"#configuring-the-bot","title":"Configuring the Bot","text":"<p>After creating the application, we need to configure the bot and get the bot token. To do this, we need to go to the <code>Bot</code> tab.</p> <p></p> <code>Username</code> This is the username of the bot. You can change this to whatever you want. <code>Avatar</code> This is the avatar of the bot. You can change this to whatever you want. <code>Token</code> This is the token of the bot. This is used to control the bot. You should keep this token private and not share it with anyone. Click on the <code>Copy</code> button to copy the token to your clipboard. <code>Public Bot</code> This is used to determine if the bot is public or not. If you want to make the bot public, you can enable this option."},{"location":"#configuring-intents","title":"Configuring Intents","text":"<p>After configuring the bot, we need to configure intents. To do this, just scroll down to the <code>Privileged Gateway Intents</code> section and enable intents keeping in mind the following:</p> <code>Presence Intent</code> This is used to determine if the bot can see the presence of users. For example, if this is enabled, the bot can see if a user is playing a game, streaming, listening to Spotify and statuses like online, idle, dnd and offline etc. <code>Server Members Intent</code> This is used to determine if the bot can see the members of a server. For example, if this is enabled, the bot can see if a user joins or leaves a server and related server member events. <code>Message Content Intent</code> This is used to determine if the bot can see the content of messages. For example, if this is enabled, the bot can see the content of messages and related message events. <p>Tip</p> <p>If you want to get contents of messages, embeds, attachments and use prefix commands, you will need to enable the <code>Message Content Intent</code>. As long as your bot is in less than 100 servers, you can enable all intents without any verification. If your bot is in more than 100 servers, you will need to verify your bot and get intents you need approved.</p> <p></p>"},{"location":"#adding-the-bot-to-a-server","title":"Adding the Bot to a Server","text":"<p>After configuring intents, we need to add the bot to a server. To do this, we need to go to the <code>OAuth2</code> tab. Under the <code>OAuth2 URL Generator</code> section, go to select the <code>bot</code> scope, if you want slash commands for your bot as well check <code>applications.commands</code> scope also. Then, we need to select the permissions that we want the bot to have. After selecting the all the permissions, scroll down and copy the invite URL. You can use this URL to add the bot to a server.</p> <p></p> <p>Warning</p> <p>For this tutorial, we will be using the <code>Administrator</code> permission. This is not recommended for production bots. You should only give your bot the permissions that it needs. If its a personal bot, you can give it the <code>Administrator</code> permission.</p>"},{"location":"#in-app-authorization","title":"In-App Authorization","text":"<p>In order to add in-app authorization, you need to complete a few extra steps. Travel to <code>General</code> section under <code>OAuth2</code> tab and select <code>In-App Authorization</code> option. After that all steps are the same as above.</p> <p></p>"},{"location":"#conclusion","title":"Conclusion","text":"<p>With that, we have created a Discord bot. In the next section, we will be creating a bot using the discord.py library. After completing this tutorial, you should have a basic understanding of how to create a Discord bot. Before we move on to the next section, make sure to have the following ready:</p> <ul> <li> Python 3.8 or higher installed on your computer.</li> <li> A Discord bot created on the Discord Developer Portal.</li> <li> The bot token copied to your clipboard or saved somewhere safe.</li> <li> The bot added to a server.</li> </ul>"},{"location":"audio-playback/","title":"Audio Playback","text":"<p>Reminder</p> <p>Remember to install <code>discord.py[voice]</code> rather than just <code>discord.py</code> in order to obtain all necessary libraries for voice functionality.</p>"},{"location":"audio-playback/#installing-ffmpeg","title":"Installing ffmpeg","text":"<p>It's an executable needed to work with audio in discord.py. You can also use <code>avconv</code> instead</p> WindowsLinux <p>Visit the ffmpeg website and select the installation build.</p> <p></p> <p></p> <p>Unzip it and put where you like</p> <p>You can install ffmpeg using your package manager. An example of installing it with apt:</p> <pre><code>sudo apt install ffmpeg\n</code></pre>"},{"location":"audio-playback/#adding-ffmpeg-to-path-for-windows","title":"Adding ffmpeg to PATH (for Windows)","text":"<p>The steps may vary slightly depending on your Windows version, but they are generally the same. If you're having trouble, you can find guides for your particular version on YouTube.</p> <p>Press <code>Win</code> and search for \"Edit environment variables\"</p> <p></p> <p>Click <code>Path</code>, then click <code>Edit</code></p> <p></p> <p>Click <code>New</code></p> <p></p> <p>Enter your path to the <code>bin</code> directory of ffmpeg</p> <p></p>"},{"location":"audio-playback/#voice-basics","title":"Voice basics","text":""},{"location":"audio-playback/#connecting-to-the-voice-channel","title":"Connecting to the voice channel","text":"<pre><code>@bot.command()\nasync def connect(ctx: commands.Context):\n    await ctx.author.voice.channel.connect()\n</code></pre> <p><code>ctx.author.voice</code> is <code>None</code> if user is not in the voice channel</p>"},{"location":"audio-playback/#disconnecting-from-the-voice-channel","title":"Disconnecting from the voice channel","text":"<pre><code>@bot.command()\nasync def disconnect(ctx: commands.Context):\n    await ctx.voice_client.disconnect()\n</code></pre> <p><code>ctx.voice_client</code> is <code>None</code> if bot is not in the voice channel</p>"},{"location":"audio-playback/#moving-to-another-voice-channel","title":"Moving to another voice channel","text":"<pre><code>@bot.command()\nasync def disconnect(ctx: commands.Context, channel: discord.VoiceChannel):\n    await ctx.voice_client.move_to(channel)\n</code></pre>"},{"location":"audio-playback/#playing-an-audio","title":"Playing an audio","text":"<pre><code>@bot.command()\nasync def play(ctx: commands.Context):\n    ctx.voice_client.play(discord.FFmpegPCMAudio(\"my-cool-music.mp3\"))\n</code></pre> <p>If you need to set path to <code>ffmpeg</code> executable directly, use</p> <pre><code>ctx.voice_client.play(discord.FFmpegPCMAudio(\"my-cool-music.mp3\", executable=\"path/to/ffmpeg.exe\"))\n</code></pre> <p>You can see other <code>FFmpegPCMAudio</code> possible arguments in the docs. Instead of <code>FFmpegPCMAudio</code> also <code>FFmpegOpusAudio</code> can be used.</p>"},{"location":"audio-playback/#what-is-pcm-and-opus","title":"What is PCM and Opus","text":"<p>PCM - Think of this as raw audio; it is not encoded in anything special and is used by your computer at a lower level.</p> <p>Opus - This is a lossy audio format; it's an encoding applied to PCM that makes music playable over Discord. An Opus encoder generates Opus packets, which can play over Discord.</p> <p><code>FFmpegPCMAudio</code> produces PCM packets that need to be encoded to Opus.</p> <p><code>FFmpegOpusAudio</code> produces Opus packets, skipping the encoding step done by the library.</p>"},{"location":"audio-playback/#pause-playing","title":"Pause playing","text":"<pre><code>@bot.command()\nasync def pause(ctx: commands.Context):\n    ctx.voice_client.pause()\n</code></pre>"},{"location":"audio-playback/#resume-playing","title":"Resume playing","text":"<pre><code>@bot.command()\nasync def resume(ctx: commands.Context):\n    ctx.voice_client.resume()\n</code></pre>"},{"location":"audio-playback/#changing-volume","title":"Changing volume","text":"<p>If you want to have volume controls, use <code>PCMVolumeTransformer</code> when initializing the audio. Without that you won't be able to change the audio volume</p> <pre><code>ctx.voice_client.play(discord.PCMVolumeTransformer(discord.FFmpegPCMAudio(\"my-cool-music.mp3\")))\n</code></pre> <pre><code>@bot.command()\nasync def volume(ctx: commands.Context, volume: int):\n    ctx.voice_client.source.volume = volume / 100\n</code></pre>"},{"location":"audio-playback/#examples","title":"Examples","text":""},{"location":"audio-playback/#putting-all-together","title":"Putting all together","text":"<pre><code>import discord\nfrom discord.ext import commands\n\nintents = discord.Intents.default()\nintents.message_content = True\n\nbot = commands.Bot(command_prefix=\".\", intents=intents)\n\n\n@bot.command()\nasync def connect(ctx: commands.Context):\n    if ctx.author.voice is None:\n        return await ctx.send(\"You are not connected to the voice channel!\")\n    await ctx.author.voice.channel.connect()\n    await ctx.send(\"Connected!\")\n\n\n@bot.command()\nasync def disconnect(ctx: commands.Context):\n    if ctx.voice_client is None:\n        return await ctx.send(\"I am not connected to the voice channel!\")\n    await ctx.voice_client.disconnect()\n    await ctx.send(\"Disconnected!\")\n\n\n@bot.command()\nasync def pause(ctx: commands.Context):\n    if ctx.voice_client is None:\n        return await ctx.send(\"I am not connected to the voice channel!\")\n    if ctx.voice_client.is_playing():\n        ctx.voice_client.pause()\n        await ctx.send(\"Paused!\")\n\n\n@bot.command()\nasync def resume(ctx: commands.Context):\n    if ctx.voice_client is None:\n        return await ctx.send(\"I am not connected to the voice channel!\")\n    if ctx.voice_client.is_paused():\n        ctx.voice_client.resume()\n        await ctx.send(\"Resumed playing!\")\n\n\n@bot.command()\nasync def play(ctx: commands.Context, file: str):\n    if ctx.voice_client is None:\n        return await ctx.send(\"I am not connected to the voice channel!\")\n    ctx.voice_client.play(discord.PCMVolumeTransformer(discord.FFmpegPCMAudio(f\"music/{file}.mp3\")))\n    await ctx.send(f\"Playing `{file}` :musical_note:\")\n\n\n\n@bot.command()\nasync def volume(ctx: commands.Context, volume: int):\n    ctx.voice_client.source.volume = volume / 100\n    await ctx.send(f\"Changed volume to {volume}%\")\n\n\nbot.run(\"token\")\n</code></pre> <p>Tip</p> <p>You may improve the code better by using custom checks rather than things like<code>if ctx.author.voice is None: ...</code></p> <p></p>"},{"location":"audio-playback/#creating-custom-voice-client","title":"Creating custom voice client","text":"<p>We can only play one song at a time right now. Let's extend <code>VoiceCLient</code> class to include a music queue</p> <pre><code>class CustomVoiceClient(discord.VoiceClient):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.queue = []\n\n    def track_finished(self, error):\n        self.queue.pop(0)\n        if self.queue:\n            self.play(self.queue[0], after=self.track_finished)\n\n    def add_track(self, track: discord.AudioSource):\n        self.queue.append(track)\n        if len(self.queue) == 1:\n            self.play(track, after=self.track_finished)\n\n    def skip_track(self):\n        if self.is_playing():\n            self.stop()\n        elif self.queue:\n            self.queue.pop(0)\n</code></pre> <p>To use it instead of default one we need to pass the class in the <code>cls</code> argument when connecting to the channel</p> <pre><code>await ctx.author.voice.channel.connect(cls=CustomVoiceClient)\n</code></pre>"},{"location":"audio-playback/#adding-buttons","title":"Adding buttons","text":"<pre><code>import discord\nfrom discord.ext import commands\n\nintents = discord.Intents.default()\nintents.message_content = True\n\nbot = commands.Bot(command_prefix=\".\", intents=intents)\n\n\nclass CustomVoiceClient(discord.VoiceClient):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.queue = []\n\n    def track_finished(self, error):\n        self.queue.pop(0)\n        if self.queue:\n            self.play(self.queue[0], after=self.track_finished)\n\n    def add_track(self, track: discord.AudioSource):\n        self.queue.append(track)\n        if len(self.queue) == 1:\n            self.play(track, after=self.track_finished)\n\n    def skip_track(self):\n        if self.is_playing():\n            self.stop()\n        elif self.queue:\n            self.queue.pop(0)\n\n\nclass PlayerView(discord.ui.View):\n    def __init__(self, voice_client: CustomVoiceClient):\n        super().__init__(timeout=None)\n        self.voice_client = voice_client\n\n    @discord.ui.button(emoji=\"\ud83d\udd09\")\n    async def reduce_volume(self, interaction: discord.Interaction, button: discord.Button):\n        self.voice_client.source.volume -= 0.1\n        await interaction.response.send_message(f\"Volume is now {int(self.voice_client.source.volume * 100)}%\", ephemeral=True)\n\n    @discord.ui.button(emoji=\"\u23ef\ufe0f\")\n    async def pause_or_resume(self, interaction: discord.Interaction, button: discord.Button):\n        if self.voice_client.is_paused():\n            self.voice_client.resume()\n            await interaction.response.send_message(\"Resumed!\", ephemeral=True)\n        else:\n            self.voice_client.pause()\n            await interaction.response.send_message(\"Paused!\", ephemeral=True)\n\n    @discord.ui.button(emoji=\"\ud83d\udd0a\")\n    async def increase_volume(self, interaction: discord.Interaction, button: discord.Button):\n        self.voice_client.source.volume += 0.1\n        await interaction.response.send_message(f\"Volume is now {int(self.voice_client.source.volume * 100)}%\", ephemeral=True)\n\n    @discord.ui.button(emoji=\"\u23ed\ufe0f\")\n    async def next_track(self, interaction: discord.Interaction, button: discord.Button):\n        self.voice_client.skip_track()\n        await interaction.response.send_message(f\"Track skipped!\", ephemeral=True)\n\n\n@bot.command()\nasync def play(ctx: commands.Context, file: str):\n    if ctx.author.voice is None:\n        return await ctx.send(\"You are not connected to the voice channel!\")\n    if ctx.voice_client is None:\n        voice_client = await ctx.author.voice.channel.connect(cls=CustomVoiceClient)\n        voice_client.add_track(discord.PCMVolumeTransformer(discord.FFmpegPCMAudio(f\"music/{file}.mp3\")))\n        await ctx.send(embed=discord.Embed(title=\"\ud83c\udfb6 \ud83c\udfb5 \ud83c\udfb6 Playing music \ud83c\udfb6 \ud83c\udfb5 \ud83c\udfb6\"), view=PlayerView(voice_client))\n    else:\n        ctx.voice_client.add_track(discord.PCMVolumeTransformer(discord.FFmpegPCMAudio(f\"music/{file}.mp3\")))\n\n\nbot.run(\"token\")\n</code></pre> <p>Tip</p> <p>You can use your custom emojis to make the buttons look very cool</p> <p></p>"},{"location":"audio-playback/#getting-music-from-soundcloud","title":"Getting music from SoundCloud","text":"<p>For that we will use a very nice wrapper of Lavalink for discord.py named wavelink. In addition, it can work with other platforms besides SoundCloud.</p> <p>This is just a tiny sample of what you can do. Check out wavelink docs for more</p> <p>Run this in a terminal to install it:</p> <pre><code>pip install wavelink\n</code></pre> <p>A Lavalink node will then be required. You can set it up by yourself, or you can find some in the internet. Actually, there are plenty of free ones.</p> <pre><code>import discord\nfrom discord.ext import commands\nimport wavelink\n\nintents = discord.Intents.default()\nintents.message_content = True\n\nbot = commands.Bot(command_prefix=\".\", intents=intents)\n\n\ndef format_duration(mseconds):\n    minutes, seconds = divmod(mseconds // 1000, 60)\n    if minutes &gt;= 60:\n        hours, minutes = divmod(minutes, 60)\n        return f\"{hours:02}:{minutes:02}:{seconds:02}\"\n    return f\"{minutes:02}:{seconds:02}\"\n\n\ndef create_bar(position, duration):\n    n = int(position * 15 // duration)\n    return \"\u2588\" * n + \"\u2592\" * (15 - n)\n\n\nclass MyBot(commands.Bot):\n    async def setup_hook(self):\n        nodes = [wavelink.Node(uri=\"...\", password=\"...\")]\n        await wavelink.Pool.connect(nodes=nodes, client=self)\n\n\nbot = MyBot(command_prefix=\".\", intents=intents)\n\n\n@bot.event\nasync def on_wavelink_track_end(payload: wavelink.TrackEndEventPayload):\n    player = payload.player\n    if player.queue:\n        await player.play(player.queue.get())\n    else:\n        await player.disconnect()\n\n\n@bot.command()\nasync def play(ctx: commands.Context, query: str):\n    tracks = await wavelink.Pool.fetch_tracks(f\"scsearch:{query}\")\n    if not tracks:\n        return await ctx.send(\"Nothing found.\")\n    if ctx.author.voice is None:\n        return await ctx.send(\"You are not connected to the voice channel!\")\n    if ctx.voice_client is None:\n        player = await ctx.author.voice.channel.connect(cls=wavelink.Player)\n    else:\n        player = ctx.voice_client\n    track = tracks[0]\n    if player.playing:\n        player.queue.put(track)\n        embed = discord.Embed(title=\"Song added to playlist\", description=f\"[{track.title}]({track.uri})\")\n    else:\n        await player.play(track)\n        embed = discord.Embed(title=\"Started playing\", description=f\"[{track.title}]({track.uri})\")\n    await ctx.send(embed=embed)\n\n\n@bot.command()\nasync def np(ctx: commands.Context):\n    player = ctx.voice_client\n    if not player or not player.playing:\n        return await ctx.send(\"I am not playing anything now\")\n    track = player.current\n    embed = discord.Embed(\n        title=f\"Now Playing {['\u25b6\ufe0f', '\u23f8\ufe0f'][player.paused]}\",\n        description=f\"[{track.title}]({track.uri})\\n{format_duration(player.position)}  {create_bar(player.position, track.length)}  {format_duration(track.length)}\")\n    embed.set_thumbnail(url=track.artwork)\n    await ctx.send(embed=embed)\n\n\n@bot.command()\nasync def pause(ctx: commands.Context):\n    if not ctx.voice_client:\n        return await ctx.send(\"I am not playing anything now\")\n    await ctx.voice_client.pause(True)\n\n\n@bot.command()\nasync def resume(ctx: commands.Context):\n    if not ctx.voice_client:\n        return await ctx.send(\"I am not playing anything now\")\n    await ctx.voice_client.pause(False)\n\n\n@bot.command()\nasync def skip(ctx: commands.Context):\n    if not ctx.voice_client:\n        return await ctx.send(\"I am not playing anything now\")\n    await ctx.voice_client.skip()\n\n\n@bot.command()\nasync def volume(ctx: commands.Context, volume: int):\n    if not ctx.voice_client:\n        return await ctx.send(\"I am not playing anything now\")\n    ctx.voice_client.set_volume(volume)\n    await ctx.send(f\"Changed volume to {volume}%\")\n\n\nbot.run(\"token\")\n</code></pre> <p></p> <p></p>"},{"location":"checks/","title":"Checks","text":"<p>Checks are utility decorators that are called before to the execution of commands.</p> <p>These checks should be predicates that take in a single parameter taking a Context. If the check returns a False-like value then during invocation a CheckFailure exception is raised.</p> <p>If an exception should be thrown in the predicate then it should be a subclass of CommandError. Any exception not subclassed from it will be propagated.</p>"},{"location":"checks/#usage","title":"Usage","text":"<p>Check is only a function that, based on the input, either throws an error or returns True/False.</p>"},{"location":"checks/#per-command-apply","title":"Per-command apply","text":"<p>Adding check to any single command</p> Prefix CommandsSlash Commands"},{"location":"checks/#commandscheck","title":"commands.check","text":"<p>A decorator that adds a single check to the prefix command</p> <pre><code>def some_single_check(ctx: commands.Context):\n    ...\n\n@bot.command()\n@commands.check(some_single_check)\nasync def foo(ctx: commands.Context):\n    await ctx.send('You passed the check!')\n</code></pre>"},{"location":"checks/#commandscheck_any","title":"commands.check_any","text":"<p>A check() that is added that checks if any of the checks passed will pass, i.e. using logical OR.</p> <pre><code>def first_check(ctx: commands.Context):\n    ...\n\ndef second_check(ctx: commands.Context):\n    ...\n\n@bot.command()\n@commands.check_any(first_check, second_check)\nasync def foo(ctx: commands.Context):\n    await ctx.send('You passed at least one check!')\n</code></pre>"},{"location":"checks/#app_commandscheck","title":"app_commands.check","text":"<p>A decorator that adds a single check to the slash command</p> <pre><code>def some_single_check(interaction: discord.Interaction):\n    ...\n\n@bot.command()\n@app_commands.check(some_single_check)\nasync def foo(interaction: discord.Interaction):\n    await ctx.send('You passed the check!')\n</code></pre>"},{"location":"checks/#global-apply","title":"Global apply","text":"<p>Adding check to all existing prefix commands</p> <p>To add a kind of global check for slash commands you can override CommandTree.interaction_check method.</p>"},{"location":"checks/#botcheck","title":"bot.check","text":"<p>A decorator that adds a global check to the bot.</p> <p>A global check is similar to a check() that is applied on a per command basis except it is run before any command checks have been verified and applies to every command the bot has.</p> <pre><code>@bot.check\ndef check(ctx: commands.Context):\n    ...\n</code></pre>"},{"location":"checks/#botcheck_once","title":"bot.check_once","text":"<p>Same as bot.check except it is called only once per invoke() call</p> <p>Regular global checks are called whenever a command is called or Command.can_run() is called. This type of check bypasses that and ensures that it\u2019s called only once, even inside the default help command.</p> <pre><code>@bot.check_once\ndef check(ctx: commands.Context):\n    ...\n</code></pre>"},{"location":"checks/#botbefore_invoke","title":"bot.before_invoke","text":"<p>A decorator that registers a coroutine as a pre-invoke hook.</p> <pre><code>@bot.before_invoke\nasync def handler(ctx: commands.Context):\n    print(f\"Command '{ctx.command.name}' is started\")\n</code></pre> <p>Note</p> <p>The bot.before_invoke and bot.after_invoke hooks are only called if all checks and argument parsing procedures pass without error. If any check or argument parsing procedures fail then the hooks are not called.</p>"},{"location":"checks/#botafter_invoke","title":"bot.after_invoke","text":"<p>A decorator that registers a coroutine as a post-invoke hook.</p> <pre><code>@bot.after_invoke\nasync def handler(ctx: commands.Context):\n    print(f\"Command '{ctx.command.name}' is finished\")\n</code></pre>"},{"location":"checks/#per-cog-apply","title":"Per-cog apply","text":"<p>Adding a check on each command inside the cog</p> Prefix CommandsSlash Commands"},{"location":"checks/#cog_check","title":"cog_check","text":"<p>A special method that is registered as a commands.check() for every prefix command and subcommand in this cog.</p> <pre><code>class MyCog(commands.Cog):\n    async def cog_check(self, ctx: commands.Context):\n        ...\n\n    @commands.command()\n    async def foo(self, ctx: commands.Context):\n        ...\n</code></pre>"},{"location":"checks/#interaction_check","title":"interaction_check","text":"<p>A special method that is registered as a app_commands.check() for every slash command and subcommand in this cog.</p> <pre><code>class MyCog(commands.Cog):\n    async def interaction_check(self, interaction: discord.Interaction):\n        ...\n\n    @app_commands.command()\n    async def foo(self, interaction: discord.Interaction):\n        ...\n</code></pre>"},{"location":"checks/#handling-check-failures","title":"Handling check failures","text":"<p>When an error inside check happens, the error is propagated to the error handlers.</p> <p>If you don't raise an exception but return false-like value, then it will get wrapped up into a CheckFailure exception.</p> <p>Tip</p> <p>Check out Error Handling page for more examples and explanations about error handling</p> <p>This is an example of how you can handle check failure for a single command</p> <pre><code>class CustomException(commands.CommandError): ...\n\nasync def check(ctx: commands.Context):\n    if \"1\" in ctx.message.content:\n        raise CustomException()\n    if \"2\" in ctx.message.content:\n        return False\n    return True\n\n@commands.check(check)\n@bot.command()\nasync def foo(ctx: commands.Context):\n    await ctx.send(\"Success!\")\n\n@foo.error\nasync def handler(ctx: commands.Context, error: commands.CommandError):\n    if isinstance(error, CustomException):\n        await ctx.send(\"CustomException was raised inside check!\")\n    elif isinstance(error, commands.CheckFailure):\n        await ctx.send(\"Check has failed!\")\n    else:\n        await ctx.send(f\"Got unexpected error: {error}\")\n</code></pre> <p></p> <p>Note</p> <p>This error handler is used here for further demonstration <pre><code>@foo.error\nasync def handler(ctx: commands.Context, error: commands.CommandError):\n    await ctx.send(f\"{error.__class__.__name__} | {error}\")\n</code></pre></p>"},{"location":"checks/#built-in-checks","title":"Built-in checks","text":"<p>You may view all of discord.py's relevant checks in the documentation.</p>"},{"location":"checks/#roles","title":"Roles","text":""},{"location":"checks/#has_role","title":"has_role","text":"<p>Checks if the member invoking the command has the role specified via the name or ID specified.</p> Prefix CommandsSlash CommandsHybrid Commands With NameWith ID <pre><code>@bot.command()\n@commands.has_role(\"x\")\nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre> <pre><code>@bot.command()\n@commands.has_role(1124650487942225970)\nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre> With NameWith ID <pre><code>@bot.tree.command()\n@app_commands.checks.has_role(\"x\")\nasync def foo(interaction: discord.Interaction):\n    await interaction.response.send_message(f\"Success!\")\n</code></pre> <pre><code>@bot.tree.command()\n@app_commands.checks.has_role(1124650487942225970)\nasync def foo(interaction: discord.Interaction):\n    await interaction.response.send_message(f\"Success!\")\n</code></pre> With NameWith ID <pre><code>@bot.hybrid_command()\n@commands.has_role(\"x\")\nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre> <pre><code>@bot.hybrid_command()\n@commands.has_role(1124650487942225970)\nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre> <p></p> <p></p> <p></p>"},{"location":"checks/#has_any_role","title":"has_any_role","text":"<p>Similar to has_role, but takes unspecified amount of argument and returns True if the member invoking the command has any of the roles specified</p>"},{"location":"checks/#bot_has_role","title":"bot_has_role","text":"<p>Similar to has_role except checks if the bot itself has the role.</p>"},{"location":"checks/#bot_has_any_role","title":"bot_has_any_role","text":"<p>Similar to has_any_role except checks if the bot itself has the role.</p>"},{"location":"checks/#permissions","title":"Permissions","text":"<p>List of existing permissions</p> <p>They are attributes of discord.Permissions</p> <p><code>add_reactions</code>, <code>administrator</code>, <code>attach_files</code>, <code>ban_members</code>, <code>change_nickname</code>, <code>connect</code>, <code>create_instant_invite</code>, <code>create_private_threads</code>, <code>create_public_threads</code>, <code>deafen_members</code>, <code>embed_links</code>, <code>external_emojis</code>, <code>external_stickers</code>, <code>kick_members</code>, <code>manage_channels</code>, <code>manage_emojis</code>, <code>manage_emojis_and_stickers</code>, <code>manage_events</code>, <code>manage_guild</code>, <code>manage_messages</code>, <code>manage_nicknames</code>, <code>manage_permissions</code>, <code>manage_roles</code>, <code>manage_threads</code>, <code>manage_webhooks</code>, <code>mention_everyone</code>, <code>moderate_members</code>, <code>move_members</code>, <code>mute_members</code>, <code>priority_speaker</code>, <code>read_message_history</code>, <code>read_messages</code>, <code>request_to_speak</code>, <code>send_messages</code>, <code>send_messages_in_threads</code>, <code>send_tts_messages</code>, <code>speak</code>, <code>stream</code>, <code>use_application_commands</code>, <code>use_embedded_activities</code>, <code>use_external_emojis</code>, <code>use_external_stickers</code>, <code>use_voice_activation</code>, <code>view_audit_log</code>, <code>view_channel</code>, <code>view_guild_insights</code></p>"},{"location":"checks/#has_permissions","title":"has_permissions","text":"<p>Checks if the member has all of the permissions necessary.</p> Prefix CommandsSlash CommandsHybrid Commands <pre><code>@bot.command()\n@commands.has_permissions(manage_messages=True)\nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre> <pre><code>@bot.tree.command()\n@app_commands.checks.has_permissions(manage_messages=True)\nasync def foo(interaction: discord.Interaction):\n    await interaction.response.send_message(f\"Success!\")\n</code></pre> <pre><code>@bot.hybrid_command()\n@commands.has_permissions(manage_messages=True)\nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre> <p>Note</p> <p>This check operates on the current channel permissions, not the guild wide permissions</p> <p></p> <p></p>"},{"location":"checks/#has_guild_permissions","title":"has_guild_permissions","text":"<p>Similar to has_permissions, but operates on guild wide permissions instead of the current channel permissions.</p>"},{"location":"checks/#bot_has_permissions","title":"bot_has_permissions","text":"<p>Similar to has_permissions except checks if the bot itself has the permissions listed.</p>"},{"location":"checks/#bot_has_guild_permissions","title":"bot_has_guild_permissions","text":"<p>Similar to has_guild_permissions except checks if the bot itself has the permissions listed.</p>"},{"location":"checks/#channel","title":"Channel","text":""},{"location":"checks/#dm_only","title":"dm_only","text":"<p>Checks if command is invoked inside a DM</p> Prefix CommandsSlash CommandsHybrid Commands <pre><code>@bot.command()\n@commands.dm_only()\nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre> <ul> <li>There is no such check for application commands built-in.</li> </ul> <pre><code>def dm_only(interaction):\n    return interaction.guild is None\n\n@bot.tree.command()\n@app_commands.check(dm_only)\nasync def foo(interaction: discord.Interaction):\n    await interaction.response.send_message(f\"Success!\")\n</code></pre> <pre><code>@bot.hybrid_command()\n@commands.dm_only()\nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre>"},{"location":"checks/#guild_only","title":"guild_only","text":"<p>Checks if command is invoked inside a guild</p> Prefix CommandsSlash CommandsHybrid Commands <pre><code>@bot.command()\n@commands.guild_only()\nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre> <ul> <li>There is no such check for application commands built-in.</li> </ul> <pre><code>def guild_only(interaction):\n    return interaction.guild is not None\n\n@bot.tree.command()\n@app_commands.check(guild_only)\nasync def foo(interaction: discord.Interaction):\n    await interaction.response.send_message(f\"Success!\")\n</code></pre> <p>Tip</p> <p>You can use app_commands.guild_only() instead of check</p> <pre><code>@bot.tree.command()\n@discord.app_commands.guild_only()\nasync def foo(interaction: discord.Interaction):\n    await interaction.response.send_message(f\"Success!\")\n</code></pre> <p>With it everything will be handled by discord itself</p> <pre><code>@bot.hybrid_command()\n@commands.guild_only()\nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre>"},{"location":"checks/#is_nsfw","title":"is_nsfw","text":"<p>Checks if the channel is a NSFW channel.</p> Prefix CommandsSlash CommandsHybrid Commands <pre><code>@bot.command()\n@commands.is_nsfw()\nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre> <ul> <li>There is no such check for application commands built-in.</li> </ul> <pre><code>def is_nsfw(interaction):\n    return interaction.channel.is_nsfw()\n\n@bot.tree.command()\n@app_commands.check(is_nsfw)\nasync def foo(interaction: discord.Interaction):\n    await interaction.response.send_message(f\"Success!\")\n</code></pre> <p>Tip</p> <p>You can use <code>nsfw=True</code> argument instead of check</p> <pre><code>@bot.tree.command(nsfw=True)\nasync def foo(interaction: discord.Interaction):\n    await interaction.response.send_message(f\"Success!\")\n</code></pre> <p>With it everything will be handled by discord itself</p> <pre><code>@bot.hybrid_command()\n@commands.is_nsfw()\nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre>"},{"location":"checks/#person","title":"Person","text":""},{"location":"checks/#is_owner","title":"is_owner","text":"<p>Checks if the person invoking this command is the owner of the bot.</p> <p>This is powered by Bot.is_owner().</p> Prefix CommandsSlash CommandsHybrid Commands <pre><code>@bot.command()\n@commands.is_owner()\nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre> <ul> <li>There is no such check for application commands built-in.</li> </ul> <pre><code>async def is_owner(interaction):\n    return await bot.is_owner(interaction.user)\n\n@bot.tree.command()\n@app_commands.check(is_owner)\nasync def foo(interaction: discord.Interaction):\n    await interaction.response.send_message(f\"Success!\")\n</code></pre> <pre><code>@bot.hybrid_command()\n@commands.is_owner()  \nasync def foo(ctx: commands.Context):\n    await ctx.send(f\"Success!\")\n</code></pre>"},{"location":"checks/#hooks","title":"Hooks","text":""},{"location":"checks/#before_invoke","title":"before_invoke","text":"<p>Registers a coroutine as a pre-invoke hook.</p> Prefix CommandsSlash CommandsHybrid Commands <pre><code>async def func(ctx: commands.Context):\n    await ctx.send(\"hook\")\n\n\n@bot.command()\n@commands.before_invoke(func)\nasync def foo(ctx: commands.Context):\n    await ctx.send(\"command\")  \n</code></pre> <pre><code>async def func(interaction: discord.Interaction):\n    await interaction.channel.send(\"hook\")\n\n\n@bot.tree.command()\n@commands.before_invoke(func)\nasync def foo(interaction: discord.Interaction):\n    await interaction.response.send_message(\"command\")  \n</code></pre> <pre><code>async def func(ctx: commands.Context):\n    await ctx.send(\"hook\")\n\n\n@bot.hybrid_command()\n@commands.before_invoke(func)\nasync def foo(ctx: commands.Context):\n    await ctx.send(\"command\")  \n</code></pre> <p></p>"},{"location":"checks/#after_invoke","title":"after_invoke","text":"<p>Registers a coroutine as a post-invoke hook.</p> Prefix CommandsSlash CommandsHybrid Commands <pre><code>async def func(ctx: commands.Context):\n    await ctx.send(\"hook\")\n\n\n@bot.command()\n@commands.after_invoke(func)\nasync def foo(ctx: commands.Context):\n    await ctx.send(\"command\")  \n</code></pre> <pre><code>async def func(interaction: discord.Interaction):\n    await interaction.channel.send(\"hook\")\n\n\n@bot.tree.command()\n@commands.after_invoke(func)\nasync def foo(interaction: discord.Interaction):\n    await interaction.response.send_message(\"command\")  \n</code></pre> <pre><code>async def func(ctx: commands.Context):\n    await ctx.send(\"hook\")\n\n\n@bot.hybrid_command()\n@commands.after_invoke(func)\nasync def foo(ctx: commands.Context):\n    await ctx.send(\"command\")  \n</code></pre> <p></p>"},{"location":"checks/#cooldowns","title":"Cooldowns","text":"<p>A cooldown allows a command to only be used a specific amount of times in a specific time frame. These cooldowns can be based either on a per-guild, per-channel, per-user, per-role or global basis. Denoted by the third argument of <code>type</code> which must be of enum type BucketType.</p>"},{"location":"checks/#cooldown","title":"cooldown","text":"<p>Adds a cooldown to a Command</p> Prefix CommandsSlash CommandsHybrid Commands <pre><code>@bot.command()\n@commands.cooldown(1, 10, commands.BucketType.user)\nasync def foo(ctx: commands.Context):\n    await ctx.send(\"Success!\")\n</code></pre> <pre><code>@bot.tree.command()\n@app_commands.checks.cooldown(1, 10, key=lambda i: (i.user.id,))\nasync def foo(ctx: commands.Context):\n    await ctx.send(\"Success!\")\n</code></pre> <pre><code>@bot.hybrid_command()\n@commands.cooldown(1, 10, commands.BucketType.user)\nasync def foo(ctx: commands.Context):\n    await ctx.send(\"Success!\")\n</code></pre> <p></p>"},{"location":"checks/#dynamic_cooldown","title":"dynamic_cooldown","text":"<p>Adds a dynamic cooldown to a Command</p> <p>This differs from cooldown in that it takes a function that accepts a single parameter of type Context for prefix commands or Interaction for slash commands and must return a Cooldown or <code>None</code>. If <code>None</code> is returned then that cooldown is effectively bypassed.</p> Prefix CommandsSlash CommandsHybrid Commands <pre><code>def cooldown(ctx: commands.Context):\n    \"\"\"A cooldown for 10 seconds for everyone except listed users\"\"\"\n    if ctx.author.id in (656919778572632094, 703327554936766554):\n        return\n    return commands.Cooldown(1, 10)\n\n\n@bot.command()\n@commands.dynamic_cooldown(cooldown, commands.BucketType.user)\nasync def foo(ctx: commands.Context):\n    await ctx.send(\"Success!\")\n</code></pre> <pre><code>def cooldown(interaction: discord.Interaction):\n    \"\"\"A cooldown for 10 seconds for everyone except listed users\"\"\"\n    if interaction.author.id in (656919778572632094, 703327554936766554):\n        return\n    return app_commands.Cooldown(1, 10)\n\n\n@bot.tree.command()\n@app_commands.checks.dynamic_cooldown(cooldown, commands.BucketType.user)\nasync def foo(interaction: discord.Interaction):\n    await interaction.response.send_message(\"Success!\")\n</code></pre> <pre><code>def cooldown(ctx: commands.Context):\n    \"\"\"A cooldown for 10 seconds for everyone except listed users\"\"\"\n    if ctx.author.id in (656919778572632094, 703327554936766554):\n        return\n    return commands.Cooldown(1, 10)\n\n\n@bot.hybrid_command()\n@commands.dynamic_cooldown(cooldown, commands.BucketType.user)\nasync def foo(ctx: commands.Context):\n    await ctx.send(\"Success!\")\n</code></pre> <p></p>"},{"location":"checks/#max_concurrency","title":"max_concurrency","text":"<p>Adds a maximum concurrency to a <code>Command</code></p> <p>This enables you to only allow a certain number of command invocations at the same time, for example if a command takes too long or if only one user can use it at a time. This differs from a cooldown in that there is no set waiting period or token bucket \u2013 only a set number of people can run the command.</p> Prefix CommandsSlash CommandsHybrid Commands <pre><code>@bot.command()\n@commands.max_concurrency(1, commands.BucketType.member, wait=False)\nasync def foo(ctx: commands.Context):\n    await asyncio.sleep(1)\n    await ctx.send(\"Success!\")\n</code></pre> <pre><code>@bot.tree.command()\n@commands.max_concurrency(1, commands.BucketType.member, wait=False)\nasync def foo(interaction: discord.Interaction):\n    await asyncio.sleep(1)\n    await interaction.response.send_message(\"Success!\")\n</code></pre> <pre><code>@bot.hybrid_command()\n@commands.max_concurrency(1, commands.BucketType.member, wait=False)\nasync def foo(ctx: commands.Context):\n    await asyncio.sleep(1)\n    await ctx.send(\"Success!\")\n</code></pre> <p></p>"},{"location":"checks/#custom-checks","title":"Custom Checks","text":""},{"location":"checks/#creating-a-new-check","title":"Creating a new check","text":""},{"location":"checks/#is_me","title":"is_me","text":"<p>Creating a basic check to see if the command invoker is you.</p> <pre><code>def check_if_it_is_me(ctx):\n    return ctx.message.author.id == 85309593344815104\n\n\n@bot.command()\n@commands.check(check_if_it_is_me)\nasync def only_for_me(ctx):\n    await ctx.send('I know you!')\n</code></pre>"},{"location":"checks/#safe_content","title":"safe_content","text":"<p>Checks if there are no banned words in the command's message content</p> <pre><code>banwords = {\"rabbit\", \"horse\"}\n\n\nasync def safe_content(ctx):\n    return not (set(ctx.message.content.lower().split()) &amp; banwords)\n\n\n@bot.command()\n@commands.check(safe_content)\nasync def check_content(ctx):\n    await ctx.send(\"Content is clean!\")\n</code></pre>"},{"location":"checks/#extending-existing-checks","title":"Extending existing checks","text":"<p>A special attribute named <code>predicate</code> is bound to the value returned by commands.check decorator to retrieve the predicate passed to the decorator.</p> <pre><code>def owner_or_permissions(**perms):\n    original = commands.has_permissions(**perms).predicate\n\n    async def extended_check(ctx):\n        if ctx.guild is None:\n            return False\n        return ctx.guild.owner_id == ctx.author.id or await original(ctx)\n\n    return commands.check(extended_check)\n</code></pre> <p>This will create a check that uses <code>commands.has_permissions</code> with our custom check together to determine whether the user is the guild owner or he has the required permissions.</p>"},{"location":"cogs/","title":"Cogs","text":""},{"location":"cogs/#what-are-cogs","title":"What are cogs?","text":"<p>Cogs allow you to structure your bot's code into modules. They keep your code tidy and orderly while also preventing your bot code from becoming a monolithic monstrosity. Cogs are a technique to organize related commands, events, and tasks together, with the goal of making bot programming easier by using a few special methods.</p>"},{"location":"cogs/#difference-between-cogs-and-extensions","title":"Difference between Cogs and Extensions","text":"Cogs Extensions A class that inherits from <code>commands.Cog</code> A Python module (file) that contains a Cog or a bunch of standalone callbacks (commands, events, listeners, etc.) Used to organize commands, events, and tasks Used to load cogs, commands, events, listeners, etc. into the bot, using the <code>setup</code> function as an entry point <p>Note</p> <p>A cog doesn't have to be an extension. You can define a cog in the same file as your bot and use it without loading it as an extension. However, it is a good practice to separate your cogs into different files and load them as extensions, as it prevents you from having a cluttered codebase.</p> Cog in the same fileCog in a separate file bot.py<pre><code>from discord.ext import commands\n\nclass SuperCog(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n    @commands.command()\n    async def super_command(self, ctx):\n        await ctx.send(\"Hello from SuperCog!\")\n\nclass MyBot(commands.Bot):\n    async def setup_hook(self):\n        await self.add_cog(SuperCog(self))\n\nbot = MyBot(command_prefix=\"!\", intents=discord.Intents.default())\nbot.run(\"TOKEN\")\n</code></pre> <p><pre><code>.\n\u251c\u2500\u2500 bot.py\n\u2514\u2500\u2500 cogs\n    \u2514\u2500\u2500 super_cog.py\n</code></pre> cogs/super_cog.py<pre><code>from discord.ext import commands\n\nclass SuperCog(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n    @commands.command()\n    async def super_command(self, ctx):\n        await ctx.send(\"Hello from SuperCog!\")\n\nasync def setup(bot):\n    await bot.add_cog(SuperCog(bot))\n</code></pre> bot.py<pre><code>from discord.ext import commands\n\nclass MyBot(commands.Bot):\n    async def setup_hook(self):\n        await self.load_extension(\"cogs.super_cog\")\n\nbot = MyBot(command_prefix=\"!\", intents=discord.Intents.default())\nbot.run(\"TOKEN\")\n</code></pre></p>"},{"location":"cogs/#extensions","title":"Extensions","text":"<p>An extension is a Python module that contains a Cog or a bunch of standalone callbacks (commands, events, listeners, etc.). To load an extension, you need to define a <code>setup</code> function in the extension that takes the bot as an argument using which you can add commands, cogs, and tasks to the bot.</p> <p>Note</p> <p>The concept of extensions is not limited to cogs or discord.py. It is a general concept in programming. Extensions are used to extend the functionality of a program by adding new features or modifying existing ones.</p> <p>In context of python the term <code>extension</code> more often entails utilizing C/C++ to extend the functionality of python. You can read more about it here.</p> <p>A more day to day example of an \"extension\" in python would be packages or modules you use in your code via <code>import</code> statement. Here is an example utilizing python modules:</p> <pre><code>|\n\u251c\u2500\u2500 src\n\u2502   \u2514\u2500\u2500 my_module\n\u2502       \u2514\u2500\u2500 cool_module.py\n\u2514\u2500\u2500 main.py\n</code></pre> main.py<pre><code>import my_module.cool_module\n\nmy_module.cool_module.cool_function()\n</code></pre> <p>my_module/cool_module.py<pre><code>def cool_function():\n    print(\"I'm cool!\")\n</code></pre> In this example <code>cool_module.py</code> is a python module that is being loaded into <code>main.py</code> using the <code>import</code> statement.</p>"},{"location":"cogs/#loading-extensions","title":"Loading extensions","text":"<p>To load an extension, you need to define a <code>setup</code> function in the extension that takes the bot as an argument. This function is called by the bot when you load the extension.</p> <pre><code>from discord.ext import commands\n\n@commands.command()\nasync def super_command(ctx: commands.Context):\n    ...\n\nclass SuperCog(commands.Cog):\n    ...\n\nasync def setup(bot):\n    bot.add_command(super_command)\n    await bot.add_cog(SuperCog(bot))\n</code></pre> <p>This setup function is the entry point for the extension. It is called by the bot when you load the extension.</p> <p>To load an extension, you use <code>bot.load_extension()</code> method.</p> <pre><code>await bot.load_extension(\"cogs.super_cog\")\n</code></pre> <p>Note</p> <p>The extension path is similar to pythons import mechanism. The path is relative to the file where you are calling <code>load_extension</code> and folder names are separated by dots. The file extension is not required. So given the following folder structure: <pre><code>.\n\u251c\u2500\u2500 bot.py\n\u2514\u2500\u2500 cogs\n    \u2514\u2500\u2500 super_cog.py\n</code></pre> The path to <code>super_cog.py</code> would be <code>cogs.super_cog</code>.</p> <p>Lets take another more complex example: <pre><code>.\n\u251c\u2500\u2500 bot.py\n\u2514\u2500\u2500 cogs\n    \u251c\u2500\u2500 super_cog.py\n    \u2514\u2500\u2500 subfolder\n        \u2514\u2500\u2500 sub_cog.py\n</code></pre> The path to <code>sub_cog.py</code> would be <code>cogs.subfolder.sub_cog</code>.</p>"},{"location":"cogs/#unloading-extensions","title":"Unloading extensions","text":"<p>To unload an extension, you use <code>bot.unload_extension()</code> method.</p> <pre><code>await bot.unload_extension(\"cogs.super_cog\")\n</code></pre> <p>Note</p> <p>Sometime you may need to perform some cleanup or be notified when an extension is unloaded. You can use the <code>teardown</code> function for this purpose. It is similar to the <code>setup</code> function but is called when the extension is being unloaded.</p> <p><pre><code>async def teardown(bot):\n    print(\"Extension unloaded!\")\n</code></pre> Any exception raised in the <code>teardown</code> function will be ignored and the bot will continue to unload the extension.</p>"},{"location":"cogs/#reloading-extensions","title":"Reloading extensions","text":"<p>You might make some changes to an extension like adding a new command or fixing a bug. In such cases, you can avoid restarting the whole bot by just reloading that particular extension. This can be done using <code>bot.reload_extension()</code> method.</p> <p><pre><code>await bot.reload_extension(\"cogs.super_cog\")\n</code></pre> If reloading fails due to an exception, the bot will continue to run with the old version of the extension.</p> Hot reloading <p>Here is a small example of how you can use hot reloading to reload an extension when a file is modified and saved. This can be useful during development.</p> <pre><code>import os\nimport time\nimport pathlib\nimport asyncio\n\nimport discord\nfrom discord.ext import commands\n\n\nclass MyBot(commands.Bot):\n    _watcher: asyncio.Task\n\n    def __init__(self, ext_dir: str, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.ext_dir = pathlib.Path(ext_dir)\n\n    async def _load_extensions(self):\n        print(\"Loading extensions...\")\n        for file in self.ext_dir.rglob(\"*.py\"):\n            if file.stem.startswith(\"_\"):\n                continue\n            try:\n                await self.load_extension(\".\".join(file.with_suffix(\"\").parts))\n                print(f\"Loaded {file}\")\n            except commands.ExtensionError as e:\n                print(f\"Failed to load {file}: {e}\")\n\n    async def setup_hook(self):\n        await self._load_extensions()\n        self._watcher = self.loop.create_task(self._cog_watcher())\n\n    async def _cog_watcher(self):\n        print(\"Watching for changes...\")\n        last = time.time()\n        while True:\n            extensions: set[str] = set()\n            for name, module in self.extensions.items():\n                if module.__file__ and os.stat(module.__file__).st_mtime &gt; last:\n                    extensions.add(name)\n            for ext in extensions:\n                try:\n                    await self.reload_extension(ext)\n                    print(f\"Reloaded {ext}\")\n                except commands.ExtensionError as e:\n                    print(f\"Failed to reload {ext}: {e}\")\n            last = time.time()\n            await asyncio.sleep(1)\n\n\nbot = MyBot(\"cogs\", command_prefix=\"!\", intents=discord.Intents.default())\nbot.run(\"TOKEN\")\n</code></pre>"},{"location":"cogs/#example-extension","title":"Example Extension","text":"<p>Here is an example of a simple extension.</p> cogs/super_cog.py<pre><code>from discord.ext import commands\n\nclass SuperCog(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n\n    @commands.command()\n    async def super_command(self, ctx: commands.Context):\n        ...\n\n    @commands.Cog.listener()\n    async def on_message(self, message: discord.Message):\n        ...\n\n    @tasks.loop(...)\n    async def super_task(self):\n        ...\n\nasync def setup(bot):\n    await bot.add_cog(SuperCog(bot))\n\nasync def teardown(bot):\n    print(\"Extension unloaded!\")\n</code></pre> <p>Lets break this down.</p>"},{"location":"cogs/#setup-function","title":"<code>setup</code> function","text":"<p>This function is used to load the extension into your bot. It is called by the bot when you load the extension.</p> <p>Note</p> <p>This function is required for the extension to work properly.</p>"},{"location":"cogs/#teardown-function","title":"<code>teardown</code> function","text":"<p>This function is called when the extension is being unloaded. It is used to cleanup.</p>"},{"location":"cogs/#botadd_cog-method","title":"<code>bot.add_cog</code> method","text":"<p>This method is used to add the Cog to the bot.</p>"},{"location":"cogs/#supercog-class","title":"<code>SuperCog</code> class","text":"<p>This is the <code>Cog</code> class. It inherits from <code>commands.Cog</code> and has a constructor that takes <code>bot</code> as an argument. This allows you to access the bot instance within the Cog.</p>"},{"location":"cogs/#how-to-load-extensions-from-a-folder","title":"How to load extensions from a folder","text":"<p>Lets say you have a folder called <code>cogs</code> and you want to load all extensions from it. We can use <code>os</code> module to get all files from the folder and then load them.</p> Using os.listdirUsing pathlib <pre><code>import os\n\nclass MyBot(commands.Bot):\n    async def setup_hook(self):\n        for file in os.listdir(\"cogs\"):\n            if file.endswith(\".py\") and not file.startswith(\"_\"):\n                await self.load_extension(f\"cogs.{file[:-3]}\")\n</code></pre> <pre><code>import pathlib\n\nclass MyBot(commands.Bot):\n    async def setup_hook(self):\n        for file in pathlib.Path(\"cogs\").rglob(\"*.py\"):\n            if file.stem.startswith(\"_\"):\n                continue\n            await self.load_extension(\".\".join(file.with_suffix(\"\").parts))\n</code></pre> <p>Note</p> <p>We check if the file ends with <code>.py</code> and does not start with <code>_</code> to avoid loading files that are not extensions and files that are private. Prefer using <code>pathlib</code> over <code>os</code> as it resolves the path more accurately over different platforms and has a more modern and pythonic approach.</p>"},{"location":"cogs/#managing-extensions-using-commands","title":"Managing extensions using commands","text":""},{"location":"cogs/#load-extension","title":"Load extension","text":"<p>Loading an extension on demand can be useful when you want to add new features to your bot without restarting it or on certain events.</p> Prefix commandSlash command <pre><code>@bot.command()\nasync def load(ctx: commands.Context, extension: str):\n    await bot.load_extension(f\"cogs.{extension}\")\n    await ctx.send(f\"Loaded {extension}!\")\n</code></pre> <pre><code>extensions: list[pathlib.Path] = [file for file in pathlib.Path(\"cogs\").rglob(\"*.py\") if not file.stem.startswith(\"_\")]\n\n@bot.tree.command()\nasync def load(inter: discord.Interaction, extension: str):\n    await inter.bot.load_extension(f\"cogs.{extension}\")\n    await inter.response.send_message(f\"Loaded {extension}!\")\n\n@load.autocomplete(\"extension\")\nasync def extension_autocomplete(inter: discord.Interaction, current: str) -&gt; list[app_commands.Choice[str]]:\n    options: list[app_commands.Choice[str]] = []\n    for ext in extensions:\n        if ext.stem.startswith(current):\n            options.append(app_commands.Choice(name=ext.stem, value=ext.stem)\n    return options[:25]\n</code></pre>"},{"location":"cogs/#reload-extension","title":"Reload extension","text":"<p>Reloading extensions can be useful when you are developing your bot and want to test changes on the fly.</p> Prefix commandSlash command <pre><code>@bot.command()\nasync def reload(ctx: commands.Context, extension: str):\n    await bot.reload_extension(f\"cogs.{extension}\")\n    await ctx.send(f\"Reloaded {extension}!\")\n</code></pre> <pre><code>@bot.tree.command()\nasync def reload(inter: discord.Interaction, extension: str):\n    await inter.bot.reload_extension(f\"cogs.{extension}\")\n    await inter.response.send_message(f\"Reloaded {extension}!\")\n\n@reload.autocomplete(\"extension\")\nasync def extension_autocomplete(inter: discord.Interaction, current: str) -&gt; list[app_commands.Choice[str]]:\n    extensions = list(inter.bot.extensions.keys())\n    options: list[app_commands.Choice[str]] = []\n    for ext in extensions:\n        if ext.startswith(current):\n            options.append(app_commands.Choice(name=ext, value=ext)\n    return options[:25]\n</code></pre>"},{"location":"cogs/#unload-extension","title":"Unload extension","text":"<p>Unloading extension allows you to remove features from your bot on demand or when the feature is broken/obsolete.</p> Prefix commandSlash command <pre><code>@bot.command()\nasync def unload(ctx: commands.Context, extension: str):\n    await bot.unload_extension(f\"cogs.{extension}\")\n    await ctx.send(f\"Unloaded {extension}!\")\n</code></pre> <pre><code>@bot.tree.command()\nasync def unload(inter: discord.Interaction, extension: str):\n    await inter.bot.unload_extension(f\"cogs.{extension}\")\n    await inter.response.send_message(f\"Unloaded {extension}!\")\n\n@unload.autocomplete(\"extension\")\nasync def extension_autocomplete(inter: discord.Interaction, current: str) -&gt; list[app_commands.Choice[str]]:\n    extensions = list(inter.bot.extensions.keys())\n    options: list[app_commands.Choice[str]] = []\n    for ext in extensions:\n        if ext.startswith(current):\n            options.append(app_commands.Choice(name=ext, value=ext)\n    return options[:25]\n</code></pre>"},{"location":"cogs/#cogs","title":"Cogs","text":"<p>Cogs are a way to organize your bot's commands, events, and tasks into modules. They allow you to group related commands together and keep your code tidy and orderly and modular.</p>"},{"location":"cogs/#register-command","title":"Register command","text":"<p>We can register a command by defining a method inside the Cog and using the command types respective decorator.</p> Prefix commandSlash commandHybrid command <pre><code>class SuperCog(commands.Cog):\n    @commands.command()\n    async def super_command(self, ctx: commands.Context):\n        ...\n</code></pre> <pre><code>class SuperCog(commands.Cog):\n    @app_commands.command()\n    async def super_command(self, inter: discord.Interaction):\n        ...\n</code></pre> <pre><code>class SuperCog(commands.Cog):\n    @commands.hybrid_command()\n    async def super_command(self, ctx: commands.Context):\n        ...\n</code></pre>"},{"location":"cogs/#register-event","title":"Register event","text":"<p>To register an event we use <code>@commands.Cog.listener()</code> decorator. You can define any number of listeners as required. For a comprehensive list of events refer to the this.</p> <pre><code>class SuperCog(commands.Cog):\n    @commands.Cog.listener()\n    async def on_message(self, message: discord.Message):\n        ...\n</code></pre>"},{"location":"cogs/#register-task","title":"Register task","text":"<p>To register a task we use <code>@tasks.loop()</code> decorator. Refer to the tasks documentation for more information.</p> <pre><code>class SuperCog(commands.Cog):\n    @tasks.loop(...)\n    async def super_task(self):\n        ...\n</code></pre>"},{"location":"cogs/#group-commands-in-cogs","title":"Group Commands in Cogs","text":"<p>Cogs are a great way to group related commands together. Here are a few ways to group commands, for different types of commands.</p> Prefix commandHybrid commandSlash command <p><pre><code>class SuperCog(commands.Cog):\n    # &lt;prefix&gt;super_group\n    @commands.group()\n    async def foo(self, ctx: commands.Context):\n        if ctx.invoked_subcommand is None:\n            await ctx.send(\"foo\")\n\n    @foo.group()\n    async def bar(self, ctx: commands.Context):\n        if ctx.invoked_subcommand is None:\n            await ctx.send(\"bar\")\n\n    @bar.command()\n    async def baz(self, ctx: commands.Context):\n        await ctx.send(\"baz\")\n</code></pre> </p> <p><pre><code>class SuperCog(commands.Cog):\n    # /foo foo | !foo or !foo foo\n    @commands.hybrid_group(fallback=\"foo\")\n    async def foo(self, ctx: commands.Context):\n        \"\"\"This is a hybrid command group.\"\"\"\n        await ctx.send(\"foo\")\n\n    # /foo bar | !foo bar\n    @foo.command()\n    async def bar(self, ctx: commands.Context):\n        \"\"\"This is a subcommand.\"\"\"\n        await ctx.send(\"bar\")\n\n    # /foo baz | !foo baz\n    @foo.command()\n    async def baz(self, ctx: commands.Context):\n        \"\"\"This is a regular command.\"\"\"\n        await ctx.send(\"baz\")\n</code></pre> </p> <p>Warning</p> <p>Due to a limitation in discord, the parent/group command itself will not be listed and will not be able to be invoked. However, you can still use the parent/group command as a regular prefix command. To get around this limitation, you can use the <code>fallback</code> parameter to specify a subcommand that will be invoked if the parent/group command is invoked without a subcommand.</p> <p><pre><code>class SuperCog(commands.GroupCog, name=\"foo\", description=\"A super cog\"):\n    _bar = app_commands.Group(name=\"bar\", description=\"A bar group\")\n\n    @app_commands.command()\n    async def foo(self, inter: discord.Interaction):\n        await inter.response.send_message(\"foo\")\n\n    @_bar.command()\n    async def baz(self, inter: discord.Interaction):\n        await inter.response.send_message(\"baz\")\n</code></pre> </p> <p>Warning</p> <p>There is no way to define a fallback command for a slash command group. You can only define subcommands. The <code>app_commands</code> also dosen't define any <code>group</code> decorator. So instead you can define a <code>GroupCog</code> class which is a subclass of <code>Cog</code> and all commands in the Cog will be registered as subcommands of the group or you can define a <code>Group</code> object and add commands to it. For more information refer to the slash commands documentation.</p> <p>Warning</p> <p>Group Cogs only work with slash commands and hybrid commands. If you define a prefixed command inside it will be defined at root level and not as a subcommand. Slash commands can currently be nested only one level deep. So for example <code>/foo bar baz</code> is the maximum depth you can go. Prefix commands do not have this limitation.</p>"},{"location":"cogs/#advanced-settings","title":"Advanced settings","text":""},{"location":"cogs/#cog_load-method","title":"<code>cog_load</code> method","text":"<p>This method is called when the Cog is being loaded. It is used to start tasks and do other setup.</p> <pre><code>class SuperCog(commands.Cog):\n    async def cog_load(self):\n        print(\"Cog loaded!\")\n</code></pre>"},{"location":"cogs/#cog_unload-method","title":"<code>cog_unload</code> method","text":"<p>This method is called when the Cog is being unloaded. It is used to cancel tasks and do other cleanup.</p> <pre><code>class SuperCog(commands.Cog):\n    async def cog_unload(self):\n        print(\"Cog unloaded!\")\n</code></pre>"},{"location":"cogs/#cog_check-method","title":"<code>cog_check</code> method","text":"<p>This method registers a check that will be used for all commands in the Cog. This method must take <code>ctx</code> as an argument.</p> <pre><code>class SuperCog(commands.Cog):\n    async def cog_check(self, ctx: commands.Context):\n        return ctx.author.id == 1234567890\n</code></pre>"},{"location":"cogs/#interaction_check-method","title":"<code>interaction_check</code> method","text":"<p>This method registers a check that will be used for all interactions in the Cog. This method must take <code>interaction</code> as an argument.</p> <pre><code>class SuperCog(commands.Cog):\n    async def interaction_check(self, interaction: discord.Interaction):\n        return interaction.user.id == 1234567890\n</code></pre>"},{"location":"cogs/#cog_before_invoke-method","title":"<code>cog_before_invoke</code> method","text":"<p>This method registers a before invoke hook that will be used for all commands in the Cog. This method must take <code>ctx</code> as an argument.</p> <pre><code>class SuperCog(commands.Cog):\n    async def cog_before_invoke(self, ctx: commands.Context):\n        print(\"Before invoke!\")\n</code></pre>"},{"location":"cogs/#cog_after_invoke-method","title":"<code>cog_after_invoke</code> method","text":"<p>This method registers a after invoke hook that will be used for all commands in the Cog. This method must take <code>ctx</code> as an argument.</p> <pre><code>class SuperCog(commands.Cog):\n    async def cog_after_invoke(self, ctx: commands.Context):\n        print(\"After invoke!\")\n</code></pre>"},{"location":"cogs/#cogs-metadata","title":"Cogs metadata","text":""},{"location":"cogs/#name-attribute","title":"<code>name</code> attribute","text":"<p>This attribute is used to set the name of the Cog. If not set, the name will be the class name.</p> <pre><code>class SuperCog(commands.Cog, name=\"Super Cog\"):\n    ...\n</code></pre>"},{"location":"cogs/#description-attribute","title":"<code>description</code> attribute","text":"<p>This attribute is used to set the description of the Cog. If not set, the description will be empty.</p> Keyword argumentDocstring <pre><code>class SuperCog(commands.Cog, description=\"This is a super cog!\"):\n    ...\n</code></pre> <pre><code>class SuperCog(commands.Cog):\n    \"\"\"This is a super cog!\"\"\"\n    ...\n</code></pre>"},{"location":"cogs/#jishaku","title":"Jishaku","text":"<p>Jishaku is an extension for bot developers that enables rapid prototyping, experimentation, and debugging of features for bots. It provides a set of commands that can be used to interact with the bot and the environment it is running in.</p>"},{"location":"cogs/#usage","title":"Usage","text":"<p>To use Jishaku, first you need to install it using pip.</p> <pre><code>pip install jishaku\n</code></pre> <p>Then you can load it as an extension.</p> <pre><code>await bot.load_extension(\"jishaku\")\n</code></pre> <ul> <li>Github</li> <li>PyPi</li> <li>Documentation</li> </ul>"},{"location":"converters/","title":"Converters","text":""},{"location":"converters/#basic","title":"Basic","text":"<p>Basic converter is a function or type that can be invoked with one argument to transform an input argument into a different form or representation.</p>"},{"location":"converters/#using-function","title":"Using function","text":"<p>Example usage:</p> <pre><code>def swap_characters(argument: str):\n    return argument.swapcase()\n\n@bot.command()\nasync def swapcase(ctx: commands.Context, *, text: swap_characters):\n    await ctx.send(text)\n</code></pre> <p> </p>"},{"location":"converters/#using-built-in-types","title":"Using built-in types","text":"<pre><code>@bot.command()\nasync def double(ctx, number: int):\n    result = number * 2\n    await ctx.send(f\"The double of {number} is {result}\")\n\n@bot.command()\nasync def square(ctx, number: float):\n    result = number ** 2\n    await ctx.send(f\"The square of {number} is {result}\")\n</code></pre> <p>Note</p> <p>By default, when passing arguments to a command, they are treated as strings. Therefore, it is necessary to convert them to the appropriate data type, such as integers, in order to perform operations on them.</p> <p>Warning</p> <p>The <code>bool</code> type converter is handled in a slightly different way, and you can find more information about it here</p>"},{"location":"converters/#discordpy-built-in","title":"Discord.py built-in","text":"<p>Built-in converters in Discord.py are provided by the library and are readily available for use. They help in converting user input into specific data types such as <code>discord.Member</code>, <code>discord.User</code>, <code>discord.TextChannel</code>, <code>discord.Role</code> and many more full list can be found here.</p> <p>Example usage:</p> <pre><code>@bot.command()\nasync def greet(ctx, member: discord.Member):\n    await ctx.send(f\"Hello, {member.mention}!\")\n</code></pre> <p></p>"},{"location":"converters/#advanced","title":"Advanced","text":"<p>Advanced converters in Discord.py allow you to define your own conversion logic for specific types of inputs. You can create a custom converter by subclassing the <code>commands.Converter</code> class provided by Discord.py and implementing the <code>convert</code> method.</p> <p>Example usage:</p> <pre><code>class DurationConverter(commands.Converter):\n    async def convert(self, ctx: commands.Context, argument: str) -&gt; datetime.timedelta:\n        multipliers = {\n            's': 1,  # seconds\n            'm': 60,  # minutes\n            'h': 3600,  # hours\n            'd': 86400,  # days\n            'w': 604800  # weeks\n        }\n\n        try:\n            amount = int(argument[:-1])\n            unit = argument[-1]\n            seconds = amount * multipliers[unit]\n            delta = datetime.timedelta(seconds=seconds)\n            return delta\n        except (ValueError, KeyError):\n            raise commands.BadArgument(\"Invalid duration provided.\")\n\n@bot.command()\nasync def timeout(ctx: commands.Context, member: discord.Member, duration: DurationConverter):\n    await member.timeout(duration)\n    await ctx.send(f\"Timed out {member.mention} for {duration}\")\n</code></pre> <p> </p>"},{"location":"converters/#inline-advanced","title":"Inline Advanced","text":"<p>Even if we choose not to inherit from the <code>Converter</code> class, we can still offer a <code>convert</code> class method that incorporates the advanced functionalities typically associated with an advanced converter.</p> <pre><code>class Percentage:\n    def __init__(self, value: float):\n        self.value = value\n\n    @classmethod\n    async def convert(cls, ctx: commands.Context, argument: str):\n        try:\n            percentage = float(argument.strip(\"%\")) / 100\n            return cls(percentage)\n        except ValueError:\n            raise commands.BadArgument(\"Invalid percentage provided.\")\n\n@bot.command()\nasync def discount(ctx: commands.Context, original_price: float, percentage: Percentage):\n    discounted_price = original_price * (1 - percentage.value)\n    savings = original_price - discounted_price\n\n    await ctx.send(f\"Original Price: ${original_price:.2f}\\n\"\n                   f\"Discount: {percentage.value * 100}%\\n\"\n                   f\"Discounted Price: ${discounted_price:.2f}\\n\"\n                   f\"Savings: ${savings:.2f}\")\n</code></pre> <p> </p>"},{"location":"converters/#special","title":"Special","text":"<p>Warning</p> <p>If you are using Python 3.9 or below when using <code>Union</code>, <code>Optional</code>, <code>Literal</code> or <code>Annotated</code> you have to import <code>typing</code> module</p>"},{"location":"converters/#union","title":"Union","text":"<p>The Union converter allows a command to accept multiple specific types instead of just one type. It provides a way to introduce more relaxed and dynamic grammar to commands.</p> Python 3.9Python 3.10 and above <pre><code>@bot.command()\nasync def union(ctx, channel: typing.Union[discord.TextChannel, discord.DMChannel], *, message: str):\n    await channel.send(message)\n</code></pre> <pre><code>@bot.command()\nasync def union(ctx, channel: discord.TextChannel | discord.DMChannel, *, message: str):\n    await channel.send(message)\n</code></pre>"},{"location":"converters/#optional","title":"Optional","text":"<p>The Optional converter allows for \"back-referencing\" behavior. If the converter fails to parse the input into the specified type, the parser will skip the parameter. Then, either None or the specified default value will be passed to the parameter. The parser will continue to the next parameters and converters, if any.</p> Python 3.9Python 3.10 and above <pre><code>@bot.command()\nasync def greet(ctx: commands.Context, member: typing.Optional[discord.Member] = None):\n    member = member or ctx.author\n    await ctx.send(f\"Hello, {member.mention}!\")\n</code></pre> <pre><code>@bot.command()\nasync def greet(ctx: commands.Context, member: discord.Member | None = None):\n    member = member or ctx.author\n    await ctx.send(f\"Hello, {member.mention}!\")\n</code></pre> <p> </p>"},{"location":"converters/#literal","title":"Literal","text":"<p>The Literal converter specifies that the passed parameter must be exactly one of the listed values.</p> <pre><code>@bot.command()\nasync def rps(ctx: commands.Context, move: typing.Literal[\"rock\", \"paper\", \"scissors\"]):\n    await ctx.send(f\"You played {move}\")\n\n@rps.error\nasync def rps_error(ctx: commands.Context, error: commands.CommandInvokeError):\n    if isinstance(error, commands.BadLiteralArgument):\n        await ctx.send(\"Invalid choice. Valid choices are: rock, paper, scissors.\")\n        return\n    print(error)\n</code></pre> <p>Warning</p> <p>If none of the options from the Literal are passed then <code>BadLiteralArgument</code> is raised.</p>"},{"location":"converters/#annotated","title":"Annotated","text":"<p>In Python 3.9, a new feature called <code>typing.Annotated</code> was introduced. It enables the type checker to view one type, while allowing the library to see a different type. This feature proves valuable when dealing with intricate converters, as it helps satisfy the type checker's requirements. The converter, which the library should utilize, must be specified as the second parameter of <code>typing.Annotated</code>.</p> <p>We can update the definition of the previously defined command swapcase in a way that informs the type checker that the variable text will be of type <code>str</code>.</p> <pre><code>def swap_characters(argument: str):\n    return argument.swapcase()\n\n@bot.command()\nasync def swapcase(ctx: commands.Context, *, text: typing.Annotated[str, swap_characters]):\n    await ctx.send(text)\n</code></pre> <p> </p> <p>Note</p> <p>If you're using a Python version lower than 3.9, you can import <code>Annotated</code> from the <code>typing_extensions</code> module, as it was introduced in Python 3.9.</p>"},{"location":"converters/#greedy","title":"Greedy","text":"<p>The Greedy converter is for a list of arguments. It attempts to convert as much as possible until it can't convert anymore.</p> <pre><code>@bot.command()\nasync def add(ctx: commands.Context, numbers: commands.Greedy[int]):\n    total = sum(numbers)\n    await ctx.send(f\"The sum of the numbers is: {total}\")\n</code></pre> <p></p> <p>Warning</p> <p>The provided command definition <code>async def command(ctx: commands.Context, argument1: commands.Greedy[int], argument2: int)</code> won't work as expected because the <code>Greedy</code> type annotation consumes all available <code>int</code> values, leaving no values for the argument2. As a result, argument2 will be missing and <code>MissingRequiredArgument</code> will be raised. To ensure the availability of a value for argument2 annotate it with a different type, such as <code>str</code> or other.</p>"},{"location":"converters/#attachment","title":"Attachment","text":"<p>Unlike the other built-in Discord.py converters, the <code>Attachment</code> converter does not handle text input. Instead, its purpose is to search for and retrieve uploaded files.</p> <pre><code>@bot.command()\nasync def upload(ctx: commands.Context, attachment: discord.Attachment):\n    await ctx.send(f'You have uploaded &lt;{attachment.url}&gt;')\n</code></pre>"},{"location":"converters/#flag-converters","title":"Flag Converters","text":"<p>With the help of a <code>FlagConverter</code>, users can conveniently indicate user-friendly \"flags\" using PEP 526 type annotations.</p> <p>Default syntax for flag converters: <pre><code>!command argument1: value1 argument2: value2 ...\n</code></pre></p> <p>If you wish to learn more about this feature please refer to the documentation here.</p>"},{"location":"converters/#parameter-metadata","title":"Parameter metadata","text":"<p>The parameter feature enables the addition of metadata to command parameters, including details like converters, default values, descriptions, and displayed names. For a list of all available parameters, please refer to the documentation here.</p> <p>We can update the definition of the previously defined command timeout, allowing us to type hint it as <code>datetime.timedelta</code> and utilize the converter argument of the parameter.</p> <pre><code>@bot.command()\nasync def timeout(ctx: commands.Context, member: discord.Member, duration: datetime.timedelta = commands.parameter(converter=DurationConverter)):\n    await member.timeout(duration)\n    await ctx.send(f\"Timed out {member.mention} for {duration}\")\n</code></pre> <p> </p> <p>We can also update the definition of the previously defined command greet, incorporating the use of the <code>parameter</code> feature to define a default value. Instead of explicitly checking if the member was passed or using the command author, we can set a default value using <code>parameter</code>.</p> <pre><code>@bot.command()\nasync def greet(ctx: commands.Context, member: discord.Member = commands.parameter(default=lambda ctx: ctx.author)):\n    await ctx.send(f\"Hello, {member.mention}!\")\n</code></pre> <p>We can further simplify the code by taking advantage of some common use-case defaults provided by the library. The <code>Author</code>, <code>CurrentChannel</code>, and <code>CurrentGuild</code> options can be used as default values, eliminating the need for explicit checks or manual setting.</p> <pre><code>@bot.command()\nasync def greet(ctx: commands.Context, member: discord.Member = commands.Author):\n    await ctx.send(f\"Hello, {member.mention}!\")\n</code></pre> <p> </p>"},{"location":"creating-a-bot/","title":"Creating a discord Bot","text":""},{"location":"creating-a-bot/#prerequisites","title":"Prerequisites","text":"<ul> <li> Python 3.8 or higher installed on your computer.</li> <li> A Discord bot created on the Discord Developer Portal.</li> <li> The bot token copied to your clipboard or saved somewhere safe.</li> <li> The bot added to a server.</li> </ul> <p>Make sure to have the above prerequisites ready before moving on to the next section. If you don't have any of the above, please go back to the previous section and complete it.</p>"},{"location":"creating-a-bot/#creating-a-bot","title":"Creating a Bot","text":"<p>Now that we have the prerequisites ready, we can start creating the bot. To do this, we need to create a new folder for our bot. You can name this folder anything you want. After creating the folder, open it in your favorite code editor. I will be using Visual Studio Code for this tutorial.</p> <p>After opening the folder in your code editor, we need to create a new file called <code>main.py</code>. This is the main file of our bot. This is where we will be writing all our code. After creating the file, we need to create a new file called <code>.env</code>. This is where we will be storing our bot token.</p> <p></p> <p></p> .env<pre><code>TOKEN=your_token_here\n</code></pre> <p>Warning</p> <p>Please make sure to keep your bot token safe. If someone gets access to your bot token, they can do anything with your bot. If you think someone has access to your bot token, you can regenerate it on the Discord Developer Portal.</p> <p>Replace <code>your_token_here</code> with your bot token. After adding the token, we need to install the discord.py library. To do this, open a new terminal in your code editor and run the following command:</p> Without Voice SupportWith Voice Support <pre><code>pip install discord.py\n</code></pre> <pre><code>pip install discord.py[voice]\n</code></pre> <p>Linux users might need to install the following packages to enable voice support:</p> Debian/UbuntuFedora/RHEL/CentOSArch <pre><code>sudo apt install libffi-dev libsodium-dev python3-dev\n</code></pre> <pre><code>sudo dnf install libffi-devel libsodium-devel python3-devel\n</code></pre> <pre><code>sudo pacman -Syu libffi libsodium\n</code></pre> <p>Warning</p> <p>If you are on any other distribution, you will need to install the required packages using your package manager.</p> <ul> <li><code>libffi-dev</code> or <code>libffi-devel</code></li> <li><code>libsodium-dev</code> or <code>libsodium-devel</code></li> </ul> <p>Note</p> <p>You can use Ctrl+` to open a new terminal in Visual Studio Code.  </p> <p>For more advanced users, it's recommended to use a virtual environment or a package manager like Poetry. A virtual environment is a tool that helps manage dependencies for different projects. This means that you can have different versions of the same package installed for different projects. This is useful when you are working on multiple projects that use different versions of the same package. It does this by creating isolated environments for each project.</p> Virtual EnvironmentPoetry WindowsMac &amp; Linux <pre><code># Initialize the virtual environment\npy -m venv venv\n# Activate the virtual environment\nvenv/Scripts/activate\n# Install discord.py\npip install discord.py\n</code></pre> <pre><code># Initialize the virtual environment\npython3 -m venv venv\n# Activate the virtual environment\nsource venv/bin/activate\n# Install discord.py\npip install discord.py\n</code></pre> <p> </p> <p>Note</p> <p>You will need to activate the virtual environment every time you open a new terminal. As an indicator, you will see <code>(venv)</code> in your terminal.</p> <p>Warning</p> <p>If you get an error in windows saying <code>Activate.ps1 cannot be loaded because running scripts is disabled on this system</code>, you will need to run the following command in an elevated PowerShell session:</p> <pre><code>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n</code></pre> <p><pre><code>poetry init\npoetry add discord.py\n</code></pre> </p> <p>Note</p> <p>You will need to run <code>poetry shell</code> every time you open a new terminal. As an indicator, you will see <code>(&lt;project-name&gt;)</code> in your terminal.</p>"},{"location":"creating-a-bot/#writing-the-code","title":"Writing the Code","text":"<p>Before we jump into writing code we need to install one more package. This package is called <code>python-dotenv</code>. This package allows us to read the <code>.env</code> file we created earlier. To install this package, run the following command in your terminal:</p> <pre><code>pip install python-dotenv\n</code></pre> <p>Note</p> <p>A <code>.env</code> file is a file that contains environment variables. These variables are used to store sensitive information like API keys and tokens. These variables are not shared with anyone and are only used by the developer.</p> <p>Now that we have everything ready, we can start writing the code. Open the <code>main.py</code> file and add the following code:</p> Using ClientUsing Bot <pre><code>import os\n\nimport discord\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nTOKEN = os.getenv(\"TOKEN\")\n\nclient = discord.Client(intents=discord.Intents.all())\n\n@client.event\nasync def on_ready() -&gt; None:\n    print(f\"Logged in as {client.user}\")\n\nclient.run(TOKEN)\n</code></pre> <pre><code>import os\n\nimport discord\nfrom discord.ext import commands\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nTOKEN = os.getenv(\"TOKEN\")\n\nbot = commands.Bot(command_prefix=\"!\", intents=discord.Intents.all())\n\n@bot.event\nasync def on_ready() -&gt; None:\n    print(f\"Logged in as {bot.user}\")\n\nbot.run(TOKEN)\n</code></pre> <p>Note</p> <p>To run the bot, you can use the following command:</p> <p><pre><code>python main.py # Make sure you are in the same directory as the main.py file in your terminal.\n</code></pre> If you are using a virtual environment or Poetry, you will need to activate it first. And to stop the bot, you can use Ctrl+C.</p>"},{"location":"creating-a-bot/#differences-between-client-and-bot","title":"Differences between Client and Bot","text":"<p>Now looking at the code, you might be wondering what the difference between <code>Client</code> and <code>Bot</code> is and when to use which. The <code>commands.Bot</code> class is a subclass of the <code>discord.Client</code> class. This means that the <code>commands.Bot</code> class has all the functionality of the <code>discord.Client</code> class and more.  </p> <p>The <code>commands.Bot</code> class is used to create a bot that can respond to commands. The <code>discord.Client</code> class is used to create a bot that can respond to events. For example, if you want to create a bot that responds to prefix commands with a bunch of complex commands and functionalities, it is recommended to use the <code>commands.Bot</code> class. If you want to just create a minimal bot that responds to events or with just a few slash commands, you can use the <code>discord.Client</code> class.</p> <p>In most cases, you will be using the <code>commands.Bot</code> class.</p> Client Bot Capable of only responding to events and slash commands if configured. Capable of responding to events, commands, and slash commands with out of the box support. Can be used to create a minimal bot. Can be used to create a bot with more functionality. Not possible to add cogs. Possible to add cogs. Not possible to make prefix commands. Possible to make prefix commands. Only possible to have 1 callback per event. Possible to have multiple callbacks per event using <code>listen</code> decorators. <p>Note</p> <p>A <code>discord.Client</code> instance allows for only 1 callback per event. This means that if you have 2 <code>on_message</code> callbacks, only 1 of them will be called.</p> <p><pre><code>@client.event\nasync def on_message(message: discord.Message) -&gt; None:\n    print(\"First callback\")\n\n@client.event\nasync def on_message(message: discord.Message) -&gt; None:\n    print(\"Second callback\")\n</code></pre> In the above example, only the first callback will be called.</p> <p>But if you are using an instance of <code>commands.Bot</code>, you can use the <code>listen</code> decorator to add multiple callbacks to the same event.</p> <p><pre><code>@bot.event\nasync def on_message(message: discord.Message) -&gt; None:\n    print(\"First callback\")\n\n@bot.listen(\"on_message\")\nasync def on_message(message: discord.Message) -&gt; None:\n    print(\"Second callback\")\n</code></pre> In the above example, both callbacks will be called.</p> <p>Warning</p> <p>Don't use both the <code>discord.Client</code> and <code>commands.Bot</code> class at the same time it will cause confusion and unexpected behavior and errors.</p>"},{"location":"creating-a-bot/#using-intents","title":"Using Intents","text":"<p>Intents are a way to tell Discord what events your bot is interested in. For example, if you want to receive messages from users, you would need to enable the <code>discord.Intents.messages</code> intent. If you want to receive reactions from users, you would need to enable the <code>discord.Intents.reactions</code> intent.  </p> <p>If you want to receive all events, you would need to enable all intents. This can be done by using the <code>discord.Intents.all()</code> intent. If you want to receive only the default events, you would need to enable the <code>discord.Intents.default()</code> intent. This can be done by using the <code>discord.Intents.default()</code> intent.  </p> <p>The default intents contain all intents except for the <code>discord.Intents.members</code>, <code>discord.Intents.message_content</code> and <code>discord.Intents.presences</code> intents. This is because these intents are privileged intents. This means that you need to enable them on the Discord Developer Portal before you can use them.</p> <p>Note</p> <p>Make sure to only enable the intents you need. If you enable all intents, your bot might be slower and consume more resources unnecessarily.</p>"},{"location":"creating-a-bot/#using-commands-and-events","title":"Using Commands and Events","text":"<p>Now that we have our bot ready, we can start adding commands and events. Here is the list of possible events.</p> Prefix CommandsSlash CommandsHybrid Commands <p><pre><code>import os\n\nimport discord\nfrom discord.ext import commands\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nTOKEN = os.getenv(\"TOKEN\")\n\nintents = discord.Intents.default()\nintents.message_content = True\nbot = commands.Bot(command_prefix=commands.when_mentioned_or(\"!\"), intents=intents)  # commands.when_mentioned_or(\"!\") is used to make the bot respond to !ping and @bot ping\n\n@bot.event\nasync def on_ready() -&gt; None:  # This event is called when the bot is ready\n    print(f\"Logged in as {bot.user}\")\n\n@bot.event\nasync def on_message(message: discord.Message) -&gt; None:  # This event is called when a message is sent\n    if message.author.bot:  # If the message is sent by a bot, return\n        return\n\n    if message.content == \"Hello\":  # If the message content is Hello, respond with Hi\n        await message.channel.send(\"Hi\")\n\n    await bot.process_commands(message)  # This is required to process commands\n\n@bot.command()\nasync def ping(ctx: commands.Context) -&gt; None:  \n    await ctx.send(f\"&gt; Pong! {round(bot.latency * 1000)}ms\")\n\nbot.run(TOKEN)\n</code></pre> </p> <p>Warning</p> <p>If you don't call <code>bot.process_commands(message)</code> in the <code>on_message</code> event, the bot will not process commands the way it is supposed to. This means that the bot will not respond to commands.</p> <p>Greedy Arguments</p> <p>If you want to pass multiple arguments to a command, you can use the <code>*</code> operator. The <code>*</code> operator marks the parameter after it as a greedy argument. This means that the parameter will consume all the arguments passed to the command.</p> <p><pre><code>@bot.command()\nasync def echo(ctx: commands.Context, *, message: str) -&gt; None:\n    await ctx.send(message)\n</code></pre> In the above example, the <code>message</code> parameter will consume all the arguments passed to the command. This also means that any parameter after the <code>message</code> parameter will cause an error due to missing arguments.</p> <p>A thing to note however is that this specific behavior is only with respect to <code>discord.py</code> and not Python itself. In Python, any parameters defined after a <code>*</code> operator are considered keyword-only arguments.</p> <p><pre><code>import os\n\nimport discord\nfrom discord.ext import commands\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nTOKEN = os.getenv(\"TOKEN\")\n\nintents = discord.Intents.default()\nintents.message_content = True\nbot = commands.Bot(command_prefix=commands.when_mentioned_or(\"!\"), intents=intents)  # commands.when_mentioned_or(\"!\") is used to make the bot respond to !ping and @bot ping\n\nasync def setup_hook() -&gt; None:  # This function is automatically called before the bot starts\n    await bot.tree.sync()   # This function is used to sync the slash commands with Discord it is mandatory if you want to use slash commands\n\nbot.setup_hook = setup_hook  # Not the best way to sync slash commands, but it will have to do for now. A better way is to create a command that calls the sync function.\n\n@bot.event\nasync def on_ready() -&gt; None:  # This event is called when the bot is ready\n    print(f\"Logged in as {bot.user}\")\n\n@bot.tree.command()\nasync def ping(inter: discord.Interaction) -&gt; None:\n    await inter.response.send_message(f\"&gt; Pong! {round(bot.latency * 1000)}ms\")\n\nbot.run(TOKEN)\n</code></pre> </p> <p>Note</p> <p>The first required argument of a slash command is always <code>inter: discord.Interaction</code> and all further arguments must be type hinted.</p> <p><pre><code>import os\n\nimport discord\nfrom discord.ext import commands\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nTOKEN = os.getenv(\"TOKEN\")\n\nintents = discord.Intents.default()\nintents.message_content = True\nbot = commands.Bot(command_prefix=commands.when_mentioned_or(\"!\"), intents=intents)  # commands.when_mentioned_or(\"!\") is used to make the bot respond to !ping and @bot ping\n\nasync def setup_hook() -&gt; None:  # This function is automatically called before the bot starts\n    await bot.tree.sync()   # This function is used to sync the slash commands with Discord it is mandatory if you want to use slash commands\n\nbot.setup_hook = setup_hook  # Not the best way to sync slash commands, but it will have to do for now. A better way is to create a command that calls the sync function.\n\n@bot.event\nasync def on_ready() -&gt; None:  # This event is called when the bot is ready\n    print(f\"Logged in as {bot.user}\")\n\n@bot.hybrid_command()\nasync def ping(ctx: commands.Context) -&gt; None:  # This is a hybrid command, it can be used as a slash command and as a normal command\n    await ctx.send(f\"&gt; Pong! {round(bot.latency * 1000)}ms\")\n\nbot.run(TOKEN)\n</code></pre> </p> <p>Note</p> <p>In hybrid commands, the first required argument must be <code>ctx: commands.Context</code> and all further arguments must be type hinted so as to support slash commands.</p> <p>Danger</p> <p>You should be careful when using the <code>on_ready</code> event. This event is called whenever the bot is ready. This means that if the bot disconnects and reconnects, the <code>on_ready</code> event will be called again. This can cause unexpected behavior in your bot by running the same code multiple times. If you want to run a piece of code only once before the bot starts, you should use the <code>setup_hook</code> function.</p> <pre><code>async def setup_hook() -&gt; None:\n    # Your code here\n\nbot.setup_hook = setup_hook\n</code></pre> <p>Note</p> <p>If you want to use <code>discord.Client</code> for slash commands, the process is the same as the one for <code>discord.ext.commands.Bot</code>. The only difference is that you need to create a tree attribute for your client instance manually. Documentation for <code>discord.app_commands.CommandTree</code> can be found here.</p> <pre><code>client = discord.Client(intents=discord.Intents.all())\nclient.tree = discord.app_commands.CommandTree(client)\n</code></pre>"},{"location":"creating-a-bot/#making-an-advanced-bot","title":"Making an Advanced Bot","text":"<p>Now that we have a basic bot, we will apply what we learned to make an advanced bot and add more functionality to it creating a robust core for our bot.</p> <pre><code>import datetime\nimport logging\nimport os\nimport traceback\nimport typing\n\nimport aiohttp\nimport discord\nfrom discord.ext import commands\nfrom dotenv import load_dotenv\n\n\nclass CustomBot(commands.Bot):\n    client: aiohttp.ClientSession\n    _uptime: datetime.datetime = datetime.datetime.utcnow()\n\n    def __init__(self, prefix: str, ext_dir: str, *args: typing.Any, **kwargs: typing.Any) -&gt; None:\n        intents = discord.Intents.default()\n        intents.members = True\n        intents.message_content = True\n        super().__init__(*args, **kwargs, command_prefix=commands.when_mentioned_or(prefix), intents=intents)\n        self.logger = logging.getLogger(self.__class__.__name__)\n        self.ext_dir = ext_dir\n        self.synced = False\n\n    async def _load_extensions(self) -&gt; None:\n        if not os.path.isdir(self.ext_dir):\n            self.logger.error(f\"Extension directory {self.ext_dir} does not exist.\")\n            return\n        for filename in os.listdir(self.ext_dir):\n            if filename.endswith(\".py\") and not filename.startswith(\"_\"):\n                try:\n                    await self.load_extension(f\"{self.ext_dir}.{filename[:-3]}\")\n                    self.logger.info(f\"Loaded extension {filename[:-3]}\")\n                except commands.ExtensionError:\n                    self.logger.error(f\"Failed to load extension {filename[:-3]}\\n{traceback.format_exc()}\")\n\n    async def on_error(self, event_method: str, *args: typing.Any, **kwargs: typing.Any) -&gt; None:\n        self.logger.error(f\"An error occurred in {event_method}.\\n{traceback.format_exc()}\")\n\n    async def on_ready(self) -&gt; None:\n        self.logger.info(f\"Logged in as {self.user} ({self.user.id})\")\n\n    async def setup_hook(self) -&gt; None:\n        self.client = aiohttp.ClientSession()\n        await self._load_extensions()\n        if not self.synced:\n            await self.tree.sync()\n            self.synced = not self.synced\n            self.logger.info(\"Synced command tree\")\n\n    async def close(self) -&gt; None:\n        await super().close()\n        await self.client.close()\n\n    def run(self, *args: typing.Any, **kwargs: typing.Any) -&gt; None:\n        load_dotenv()\n        try:\n            super().run(str(os.getenv(\"TOKEN\")), *args, **kwargs)\n        except (discord.LoginFailure, KeyboardInterrupt):\n            self.logger.info(\"Exiting...\")\n            exit()\n\n    @property\n    def user(self) -&gt; discord.ClientUser:\n        assert super().user, \"Bot is not ready yet\"\n        return typing.cast(discord.ClientUser, super().user)\n\n    @property\n    def uptime(self) -&gt; datetime.timedelta:\n        return datetime.datetime.utcnow() - self._uptime\n\n\ndef main() -&gt; None:\n    logging.basicConfig(level=logging.INFO, format=\"[%(asctime)s] %(levelname)s: %(message)s\")\n    bot = CustomBot(prefix=\"!\", ext_dir=\"cogs\")\n    bot.run()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>This bot has a lot of new features, so let's go over them one by one. This bot template can be used for both slash commands and regular commands or hybrid commands.</p> <ul> <li> <code>CustomBot</code> has a <code>logger</code> attribute that is used to log messages to the console.</li> <li> <code>CustomBot</code> has an <code>ext_dir</code> attribute that is used to store the path to the directory where the bot's extensions/cogs are stored and loaded from.</li> <li> <code>CustomBot</code> has a <code>synced</code> attribute that is used to check if the bot's slash commands are synced with Discord.</li> <li> <code>CustomBot</code> has a <code>client</code> attribute that is used to make HTTP requests.</li> <li> <code>CustomBot</code> has a basic error handler that logs the error to the console.</li> <li> <code>CustomBot</code> has an <code>uptime</code> property that is used to get the bot's uptime.</li> </ul> <p>Warning</p> <p>For conducting specific actions on startup, you should use the <code>setup_hook</code> function. This function is called before the bot starts and is the best place to put your startup code. Please do not put your startup code in <code>on_ready</code> as this event is fired whenever bot connection to discord gateway is established. This means that <code>on_ready</code> can be called multiple times during the bot's lifetime.</p>"},{"location":"creating-a-bot/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we learned how to create a simple bot application using discord.py. We also learned how to create a more advanced bot application that can be used as a template for future projects. Going forward, we will further expand on this template and add more functionality to it.</p>"},{"location":"custom-context/","title":"Custom Context Class","text":"<p>There are many uses for context and its properties, however occasionally we wish to add some additional methods or attributes.</p> <p>Here is how you do it in discord.py:</p>"},{"location":"custom-context/#creating-custom-context-class","title":"Creating custom context class","text":"<ul> <li>Subclass context and add your features</li> </ul> <pre><code>import typing\n\nfrom discord.ext import commands\n\nclass MyContext(commands.Context):\n    def __init__(self, *args: typing.Any, **kwargs: typing.Any):\n        super().__init__(*args, **kwargs)\n        self.test = 123\n\n    async def send_test(self):\n        await self.send(f\"{self.test}\")\n</code></pre> <p>Note</p> <p>You can override any library methods of context if you want.</p>"},{"location":"custom-context/#overriding-get_context","title":"Overriding get_context","text":"<ul> <li>Make discord.py use your context class by overriding the get_context method in the bot subclass.</li> </ul> <pre><code>import discord\nfrom discord.ext import commands\n\nclass MyBot(commands.Bot):\n    async def get_context(self, message: discord.Message, *, cls=CustomContext):\n        return await super().get_context(message, cls=cls)\n</code></pre> <ul> <li>Don't forget to use your custom bot class, not default one</li> </ul> <pre><code>bot = MyBot(\".\", intents=intents)\n</code></pre>"},{"location":"custom-context/#creating-example-command","title":"Creating example command","text":"<pre><code>@bot.command()\nasync def foo(ctx: MyContext) -&gt; None:\n    await ctx.send_test()\n</code></pre>"},{"location":"custom-context/#result","title":"Result","text":"<p>And that's it! You can now use your custom context class.</p> <p>Note</p> <p>Custom class context is limited to commands which you <code>commands.Context</code> as a required argument. Meaning that you can't use it with slash commands.</p>"},{"location":"custom-context/#more-examples","title":"More examples","text":""},{"location":"custom-context/#tick-method","title":"Tick method","text":"<p>Here, we're adding a method called <code>tick</code> to the context, which, based on the value provided, adds a cross or a checkmark emoji.</p> <p> Example from discord.py</p> <p></p>"},{"location":"custom-context/#storing-custom-attribute-for-server","title":"Storing custom attribute for server","text":"<p>Let's create a simple table to hold a guild secret value.</p> <pre><code>CREATE TABLE `test`.`secret` (\n  `guild_id` BIGINT UNSIGNED NOT NULL,\n  `value` VARCHAR(64) NOT NULL DEFAULT 'nothing',\n  PRIMARY KEY (`guild_id`));\n</code></pre> <p>After that, let's add two methods in the context: one retrieves the value from this table, the other modifies it.</p> <pre><code>import aiomysql\nimport discord\nfrom discord.ext import commands\n\n\nclass MyContext(commands.Context):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    async def get_secret_value(self):\n        async with aiomysql.connect(...) as connection:\n            async with connection.cursor() as cursor:\n                await cursor.execute(\"SELECT value FROM secret WHERE guild_id = %s\", (self.guild.id,))\n                data = await cursor.fetchone()\n                if data is None:\n                    await cursor.execute(\"INSERT INTO secret (guild_id) VALUES (%s)\", (self.guild.id,))\n                    await connection.commit()\n                    return \"nothing\"\n                return data[0]\n\n    async def set_secret_value(self, new_value):\n        async with aiomysql.connect(...) as connection:\n            async with connection.cursor() as cursor:\n                await cursor.execute(\"UPDATE secret SET value = %s WHERE guild_id = %s\", (new_value, self.guild.id))\n                await connection.commit()\n\n\nclass MyBot(commands.Bot):\n    async def get_context(self, message, *, cls=MyContext):\n        return await super().get_context(message, cls=cls)\n\n\nintents = discord.Intents.default()\nintents.message_content = True\n\nbot = MyBot('.', intents=intents)\n\n\n@bot.command()\nasync def get(ctx: MyContext):\n    secret = await ctx.get_secret_value()\n    await ctx.send(f\"||{secret}||\")\n\n\n@bot.command()\nasync def change(ctx: MyContext, new_value: str):\n    await ctx.set_secret_value(new_value)\n    await ctx.send(f\"Secret value changed\")\n\nbot.run(\"token\")\n</code></pre> <p></p>"},{"location":"embeds/","title":"Embeds","text":""},{"location":"embeds/#what-is-an-embed","title":"What is an Embed?","text":"<p>Discord Embed object is a message component that is used as a way of adding rich content with different structures and formatting styles. Discord embeds also allow you to use markdown in the fields and descriptions, which can be useful for formatting. Check out our Markdown page for more information.</p>"},{"location":"embeds/#overview","title":"Overview","text":"<p>Here is an example of an embed with all its features.</p> <pre><code>@bot.command()\nasync def foo(ctx: commands.Context):\n    some_url = \"https://fallendeity.github.io/discord.py-masterclass/\"\n    embed = discord.Embed(\n        title=\"Title\",\n        description=\"Description\",\n        url=some_url,\n        color=discord.Color.random(),\n        timestamp=datetime.datetime.utcnow()\n    )\n    embed.add_field(name=\"Field name\", value=\"Color sets that &lt;\")\n    embed.add_field(name=\"Field name\", value=\"Color should be an integer or discord.Colour object\")\n    embed.add_field(name=\"Field name\", value=\"You can't set image width/height\")\n    embed.add_field(name=\"Non-inline field name\", value=\"The number of inline fields that can shown on the same row is limited to 3\", inline=False)\n    embed.set_author(name=\"Author\", url=some_url,\n                     icon_url=\"https://cdn.discordapp.com/attachments/1112418314581442650/1124820259384332319/fd0daad3d291ea1d.png\")\n    embed.set_image(url=\"https://cdn.discordapp.com/attachments/1028706344158634084/1124822236801544324/ea14e81636cb2f1c.png\")\n    embed.set_thumbnail(url=\"https://media.discordapp.net/attachments/1112418314581442650/1124819948317986926/db28bfb9bfcdd1f6.png\")\n    embed.set_footer(text=\"Footer\", icon_url=\"https://cdn.discordapp.com/attachments/1112418314581442650/1124820375587528797/dc4b182a87ecee3d.png\")\n    await ctx.send(embed=embed)\n</code></pre> <p>Note</p> <p>Since most embed methods return the embed itself, you can chain them like this: <pre><code>discord.Embed(...).set_image(...).add_field(...)\n</code></pre> Almost all methods have a default value of <code>None</code>, so you can skip them if you don't need them.</p> <p></p>"},{"location":"embeds/#creating-an-embed","title":"Creating an Embed","text":"<p>To create an embed, you need to create an instance of the <code>discord.Embed</code> class. You can pass various parameters to the constructor to set the properties of the embed.</p> <pre><code>embed = discord.Embed(\n    title=\"Title\",\n    description=\"Description\",\n    color=discord.Color.random(),\n    timestamp=datetime.datetime.utcnow()\n)\n</code></pre> <ul> <li><code>title</code> - The title of the embed</li> <li><code>description</code> - The description of the embed</li> <li><code>color</code> - The color of the embed, you can use <code>discord.Colour</code> to set the color or construct colors using the following methods:<ul> <li><code>discord.Color.from_rgb(r, g, b)</code></li> <li><code>discord.Color.from_hsv(h, s, v)</code></li> <li><code>discord.Color.from_str(\"0x&lt;HEX&gt; | #&lt;HEX&gt; | 0x#&lt;HEX&gt; | rgb(r, g, b)\")</code></li> </ul> </li> <li><code>timestamp</code> - The timestamp of the embed, you can use <code>discord.utils.utcnow()</code> to get the current time</li> </ul>"},{"location":"embeds/#working-with-specific-fields","title":"Working with specific fields","text":""},{"location":"embeds/#getting-a-list-of-fields","title":"Getting a list of fields","text":"<p>property discord.Embed.fields</p> Python Console Session<pre><code>&gt;&gt;&gt; import discord\n&gt;&gt;&gt; embed = discord.Embed()\n&gt;&gt;&gt; embed.fields\n[]\n&gt;&gt;&gt; embed.add_field(name=\"name\", value=\"value\")\n&gt;&gt;&gt; embed.fields\n[EmbedProxy(inline=True, name='name', value='value')]\n&gt;&gt;&gt; embed.fields[0].value\n'value'\n</code></pre> <p>Warning</p> <p>Working with attribute <code>_fields</code> directly is a bad practice. Use special embed methods instead</p> <p>_single_leading_underscore: weak \u201cinternal use\u201d indicator. E.g. from M import * does not import objects whose names start with an underscore. (pep8)</p>"},{"location":"embeds/#appending-a-field","title":"Appending a field","text":"<p>method discord.Embed.add_field</p> Python Console Session<pre><code>&gt;&gt;&gt; import discord\n&gt;&gt;&gt; embed = discord.Embed()\n&gt;&gt;&gt; embed.add_field(name=\"name1\", value=\"value1\")\n&gt;&gt;&gt; embed.add_field(name=\"name2\", value=\"value2\")\n&gt;&gt;&gt; embed.add_field(name=\"name3\", value=\"value3\")\n&gt;&gt;&gt; embed.fields\n[EmbedProxy(inline=True, name='name1', value='value1'), EmbedProxy(inline=True, name='name2', value='value2'), EmbedProxy(inline=True, name='name3', value='value3')]\n</code></pre>"},{"location":"embeds/#inserting-field-at-index","title":"Inserting field at index","text":"<p>method discord.Embed.insert_field_at</p> Python Console Session<pre><code>&gt;&gt;&gt; import discord\n&gt;&gt;&gt; embed = discord.Embed()\n&gt;&gt;&gt; embed.add_field(name=\"name1\", value=\"value1\")\n&gt;&gt;&gt; embed.add_field(name=\"name2\", value=\"value2\")\n&gt;&gt;&gt; embed.add_field(name=\"name3\", value=\"value3\")\n&gt;&gt;&gt; embed.insert_field_at(1, name=\"new\", value=\"new\")\n&gt;&gt;&gt; embed.fields\n[EmbedProxy(inline=True, name='name1', value='value1'), EmbedProxy(inline=True, name='new', value='new'), EmbedProxy(inline=True, name='name2', value='value2'), EmbedProxy(inline=True, name='name3', value='value3')]\n</code></pre>"},{"location":"embeds/#changing-field-at-index","title":"Changing field at index","text":"<p>method discord.Embed.set_field_at</p> Python Console Session<pre><code>&gt;&gt;&gt; import discord\n&gt;&gt;&gt; embed = discord.Embed()\n&gt;&gt;&gt; embed.add_field(name=\"name1\", value=\"value1\")\n&gt;&gt;&gt; embed.add_field(name=\"name2\", value=\"value2\")\n&gt;&gt;&gt; embed.add_field(name=\"name3\", value=\"value3\")\n&gt;&gt;&gt; embed.set_field_at(1, name=\"new\", value=\"new\")\n&gt;&gt;&gt; embed.fields\n[EmbedProxy(inline=True, name='name1', value='value1'), EmbedProxy(inline=True, name='new', value='new'), EmbedProxy(inline=True, name='name3', value='value3')]\n</code></pre>"},{"location":"embeds/#removing-one-field","title":"Removing one field","text":"<p>method discord.Embed.remove_field</p> Python Console Session<pre><code>&gt;&gt;&gt; import discord\n&gt;&gt;&gt; embed = discord.Embed()\n&gt;&gt;&gt; embed.add_field(name=\"name1\", value=\"value1\")\n&gt;&gt;&gt; embed.add_field(name=\"name2\", value=\"value2\")\n&gt;&gt;&gt; embed.add_field(name=\"name3\", value=\"value3\")\n&gt;&gt;&gt; embed.remove_field(1)\n&gt;&gt;&gt; embed.fields\n[EmbedProxy(inline=True, name='name1', value='value1'), EmbedProxy(inline=True, name='name3', value='value3')]\n</code></pre>"},{"location":"embeds/#removing-all-fields","title":"Removing all fields","text":"<p>method discord.Embed.clear_fields</p> Python Console Session<pre><code>&gt;&gt;&gt; import discord\n&gt;&gt;&gt; embed = discord.Embed()\n&gt;&gt;&gt; embed.add_field(name=\"name1\", value=\"value1\")\n&gt;&gt;&gt; embed.add_field(name=\"name2\", value=\"value2\")\n&gt;&gt;&gt; embed.add_field(name=\"name3\", value=\"value3\")\n&gt;&gt;&gt; embed.fields\n[EmbedProxy(inline=True, name='name1', value='value1'), EmbedProxy(inline=True, name='name2', value='value2'), EmbedProxy(inline=True, name='name3', value='value3')]\n&gt;&gt;&gt; embed.clear_fields()\n&gt;&gt;&gt; embed.fields\n[]\n</code></pre>"},{"location":"embeds/#embed-with-multiple-images","title":"Embed with multiple images","text":"<pre><code>@bot.command()\nasync def foo(ctx: commands.Context):\n    embed = discord.Embed(url=\"https://fallendeity.github.io/discord.py-masterclass/\")\n    embed.set_image(url=\"https://cdn.discordapp.com/attachments/1028706344158634084/1125040932635549818/0e0eb12ccd76d766.png\")\n    await ctx.send(embeds=[embed, embed])\n</code></pre> <p>Note</p> <p>Embeds must have urls, and these urls have to be the same.</p> <p></p>"},{"location":"embeds/#deserialization","title":"(De)serialization","text":"<p>Converting embed objects to the Python dictionary and vice versa is very simple.</p> <p>For that we can use from_dict and to_dict methods</p> Python Console Session<pre><code>&gt;&gt;&gt; import discord\n&gt;&gt;&gt; embed = discord.Embed(title=\"Hello\", description=\"world!\")\n&gt;&gt;&gt; embed.add_field(name=\"Field name\", value=\"Field value\")\n&gt;&gt;&gt; embed_dict = embed.to_dict()\n&gt;&gt;&gt; _\n{'fields': [{'inline': True, 'name': 'Field name', 'value': 'Field value'}], 'type': 'rich', 'description': 'world!', 'title': 'Hello'}\n&gt;&gt;&gt; embed_dict[\"description\"] = \"test\"\n&gt;&gt;&gt; embed = discord.Embed.from_dict(embed_dict)\n&gt;&gt;&gt; type(embed)\n&lt;class 'discord.embeds.Embed'&gt;\n&gt;&gt;&gt; embed.description\n'test'\n</code></pre>"},{"location":"embeds/#how-to-create-an-empty-field","title":"How to create an empty field?","text":"<p>You can't create an empty field due to Discord API restrictions, however you can get around them by using invisible characters</p> <pre><code>@bot.command()\nasync def foo(ctx: commands.Context):\n    embed = discord.Embed()\n    # embed.add_field(name=\"\") -&gt; Error\n    embed.add_field(name=\"\\u200b\", value=\"Where is the name?\")\n    await ctx.send(embed=embed)\n</code></pre> <p></p>"},{"location":"embeds/#how-to-use-local-image-for-an-embed-image","title":"How to use local image for an embed image?","text":"<p>Discord.py allows you to send images as attachments in messages. You can use the <code>discord.File</code> class to send images as attachments in messages. You can then use the <code>attachment://</code> protocol followed by the filename to reference the attachment in the embed.</p> <pre><code>file = discord.File(\"path/to/my/image.png\", filename=\"image.png\")\nembed = discord.Embed()\nembed.set_image(url=\"attachment://image.png\")\nawait channel.send(file=file, embed=embed)\n</code></pre> <p>Always remember to also send pass the <code>file</code> object when sending the message, without it discord will not be able to find the image you are trying to refer to.</p>"},{"location":"embeds/#embed-limits","title":"Embed limits","text":"<p>Embed title is limited to 256 characters</p> <p>Embed description is limited to 4096 characters</p> <p>An embed can contain a maximum of 25 fields</p> <p>A field name/title is limited to 256 character and the value of the field is limited to 1024 characters</p> <p>Embed footer is limited to 2048 characters</p> <p>Embed author name is limited to 256 characters</p> <p>The total of characters allowed in an embed is 6000</p>"},{"location":"embeds/#embed-playgrounds","title":"Embed Playgrounds","text":"<ul> <li>Discord Embed Sandbox</li> <li>Embed Visualizer</li> </ul> <p>Warning</p> <p>We don't advise using the website to create embeds: it's best to do it on your own and far more efficient and customizable. But however, the site can be a good playground for testing and learning.</p>"},{"location":"error-handling/","title":"Error Handling","text":"<p>There are many reasons why you can get an error, ranging from Discord API errors raised by the discord.py library to simple coding mistakes.</p>"},{"location":"error-handling/#example-command-with-error","title":"Example command with error","text":"<p>Let's take the command <code>foo</code>, which gets some error. We will simply divide by zero within in the example, although there may be any error.</p> <pre><code>@bot.command()\nasync def foo(ctx: commands.Context):\n    1 / 0\n</code></pre> <p>When we run the command, we will encounter the following error:</p> <pre><code>Traceback (most recent call last):\n  File \"...\\lib\\site-packages\\discord\\ext\\commands\\core.py\", line 235, in wrapped\n    ret = await coro(*args, **kwargs)\n  File \"main.py\", line ..., in foo\n    1 / 0\nZeroDivisionError: division by zero\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"...\\lib\\site-packages\\discord\\ext\\commands\\bot.py\", line 1350, in invoke\n    await ctx.command.invoke(ctx)\n  File \"...\\lib\\site-packages\\discord\\ext\\commands\\core.py\", line 1029, in invoke\n    await injected(*ctx.args, **ctx.kwargs)  # type: ignore\n  File \"...\\lib\\site-packages\\discord\\ext\\commands\\core.py\", line 244, in wrapped\n    raise CommandInvokeError(exc) from exc\ndiscord.ext.commands.errors.CommandInvokeError: Command raised an exception: ZeroDivisionError: division by zero\n</code></pre> <p>Usually, we don't want that, right? We wish to respond to the error in some way, like informing the user.</p> <p>So let's handle the error!</p>"},{"location":"error-handling/#basic-error-handling-try-except","title":"Basic error handling (try-except)","text":"<p>In Python, try-except is typically used to capture exceptions. Of course, you can also use them in discord.py, but doing so is less comfortable and has some drawbacks (not everything in discord.py can be captured with it).</p> <pre><code>@bot.command()\nasync def foo(ctx: commands.Context):\n    try:\n        1 / 0\n    except ZeroDivisionError:\n        await ctx.send(\"Error: division by zero attempt\")\n</code></pre> <p></p> <p>Note</p> <p>With such code, you cannot handle exceptions from things like checks or cooldowns and errors which occur in the command itself, but not in the try-except block.</p>"},{"location":"error-handling/#what-library-does-with-the-errors","title":"What library does with the errors","text":"<p>When a command in Discord.py encounters an error, the library handles it in the following order rather than terminating the code with an error:</p> <ul> <li>Run the command's error handler if it has one.</li> <li>Run the cog error handler if command is contained within a cog and the cog has one.</li> <li>Run the global command error handler if exists.</li> <li>Print the error in the stderr without quitting the program if there are no error handlers.</li> </ul> <pre><code>graph LR\n    A[Command] --&gt;|exists?| B[Command Error Handler]\n    A --&gt; C[Cog]\n    C --&gt;|exists?| D[Cog Error Handler]\n    C --&gt; E[Global]\n    E --&gt;|exists?| F[Global Command Error Handler]\n    E -. no handlers? .-&gt; G[Print error in stderr]</code></pre> <p>Warning</p> <p>Making an error handler will suppress any errors, making it difficult to debug your code. Normally, if your handler doesn't pass any conditions, you print out the error (or do something similar).</p>"},{"location":"error-handling/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>The discord.py documentation contains a list of all errors and their hierarchy.</p>"},{"location":"error-handling/#command-handler","title":"Command Handler","text":"<p>To create a handler for a single command, use Command.error decorator.  This handler will only operate with this command, not any others.</p> <pre><code>@bot.command()\nasync def foo(ctx: commands.Context):\n    1 / 0\n\n@foo.error\nasync def foo_error(ctx: commands.Context, error: commands.CommandError):\n    await ctx.send(error)\n</code></pre> <p></p> <p>Much better! But to a user who is not a programmer, it does not appear to be very understandable So we can simply format it whatever we like. Built-in isinstance function is suggested as a method for determining the type of error.</p> <pre><code>@foo.error\nasync def foo_error(ctx: commands.Context, error: commands.CommandError):\n    embed = discord.Embed(title=\"Error\")\n    if isinstance(error, commands.CommandInvokeError):\n        error = error.original\n    if isinstance(error, ZeroDivisionError):\n        embed.description = \"Division by zero attempt\"\n    else:\n        embed.description = \"Unknown error\"\n    await ctx.send(embed=embed)\n</code></pre> <p></p> <p>Note</p> <p>If there is an actual error in your code, then it will be a CommandInvokeError. We can use its <code>original</code> or <code>__cause__</code> attribute to retrieve the original error. <pre><code>error = error.__cause__\n</code></pre></p>"},{"location":"error-handling/#cog-handler","title":"Cog Handler","text":"<p>You can set up a cog handler if there are several commands with the same exceptions in the same cog.</p> <p>For that you need create a cog and override Cog.cog_command_error method.</p> <pre><code>import traceback\n\nimport discord\nfrom discord.ext import commands\n\nclass Example(commands.Cog):\n    @commands.command()\n    async def foo(self, ctx: commands.Context):\n        1 / 0\n\n    async def cog_command_error(self, ctx: commands.Context, error: commands.CommandError):\n        embed = discord.Embed(title=\"Error\")\n        if isinstance(error, commands.CommandInvokeError):\n            error = error.original\n        if isinstance(error, ZeroDivisionError):\n            embed.description = \"Division by zero attempt\"\n        else:\n            error_data = \"\".join(traceback.format_exception(type(error), error, error.__traceback__))\n            embed.description = f\"Unknown error\\n```py\\n{error_data[:1000]}\\n```\"\n        await ctx.send(embed=embed)\n\n\nasync def setup(bot: commands.Bot):\n    await bot.add_cog(Example())\n</code></pre> <p></p> <p>Warning</p> <p>Make sure to load your cogs otherwise commands will not be registered to bot and there will be no response. To load cogs, use the Bot.load_extension method.</p> <pre><code>await bot.load_extension(\"cogs.example\")\n</code></pre>"},{"location":"error-handling/#global-handler","title":"Global Handler","text":"<p>It can get very boring to handle errors for each command or cog separately. Especially when we do it similarly everywhere.</p> <p>Let's make a global error handler, that will be used by all commands.</p> <p>For that you need to override bot's on_command_error method.</p> <p>In order to accomplish this, you can either subclass the bot and modify its method, or use Bot.event or Bot.listen decorator.</p> <pre><code>import traceback\n\nimport discord\nfrom discord.ext import commands\n\n@bot.command()\nasync def foo(ctx: commands.Context):\n    1 / 0\n\n@bot.event\nasync def on_command_error(ctx: commands.Context, error: commands.CommandError):\n    embed = discord.Embed(title=\"Error\")\n    if isinstance(error, commands.CommandInvokeError):\n        error = error.original\n    if isinstance(error, ZeroDivisionError):\n        embed.description = \"Division by zero attempt\"\n    else:\n        error_data = \"\".join(traceback.format_exception(type(error), error, error.__traceback__))\n        embed.description = f\"Unknown error\\n```py\\n{error_data[:1000]}\\n```\"\n    await ctx.send(embed=embed)\n</code></pre> <p></p> <p>Warning</p> <p>Always make sure to have an <code>else</code> clause in your error handler. Otherwise, you will not be able to see the actual error if it is not one of the expected ones.</p> <p><pre><code>@bot.event\nasync def on_command_error(ctx: commands.Context, error: commands.CommandError):\n    embed = discord.Embed(title=\"Error\")\n    if isinstance(error, commands.CommandInvokeError):\n        error = error.original\n    if isinstance(error, ZeroDivisionError):\n        embed.description = \"Division by zero attempt\"\n    # else:\n    #     embed.description = \"Unknown error\"\n    await ctx.send(embed=embed)\n</code></pre> In such a situation, you will not be able to see the actual error as the error handler will be eating away the error.</p>"},{"location":"error-handling/#expanded-example","title":"Expanded Example","text":""},{"location":"error-handling/#sequential-handling","title":"Sequential handling","text":"<p>Both will be executed if command has an error handler and command's cog has an error handler. We can use it to only check for errors where we have to.</p> <p>Let's use such command <code>foo</code> and consider that the first error might occur in any command, the second could occur only in that command cog, and the third could only occur in this command.</p> <pre><code>class Example(commands.Cog):\n    async def cog_command_error(self, ctx: commands.Context, error: commands.CommandError):\n        if isinstance(error, commands.CommandInvokeError) and isinstance(error.original, ValueError):\n            await ctx.send(\"Got ValueError inside the cog handler\")\n\n    @commands.command()\n    async def foo(self, ctx: commands.Context, arg: int):\n        if arg == 1:\n            1 / 0\n        if arg == 2:\n            int(\"x\")\n        if arg == 3:\n            {\"hello\": \"world\"}[\"test\"]\n\n    @foo.error\n    async def foo_error(self, ctx: commands.Context, error: commands.CommandError):\n        if isinstance(error, commands.CommandInvokeError) and isinstance(error.original, KeyError):\n            await ctx.send(\"Got KeyError inside the command handler\")\n\n\nclass MyBot(commands.Bot):\n    async def setup_hook(self):\n        await self.add_cog(Example())\n\n\nbot = MyBot(command_prefix=\".\", intents=intents)\n\n@bot.event\nasync def on_command_error(ctx: commands.Context, error: commands.CommandError):\n    if isinstance(error, commands.CommandInvokeError) and isinstance(error.original, ZeroDivisionError):\n        await ctx.send(\"Got ZeroDivisionError inside the global handler\")\n</code></pre> <p></p>"},{"location":"error-handling/#full-bot-with-more-errors","title":"Full bot with more errors","text":"<p>An expanded example with some additional errors:</p> <pre><code>import datetime\nimport traceback\n\nimport discord\nfrom discord.ext import commands\n\nintents = discord.Intents.default()\nintents.message_content = True\nbot = commands.Bot(\".\", intents=intents)\n\n\nclass AuthorHasLowerRole(commands.CommandError):\n    \"\"\"Exception raised when user tries to move the user which has a better role\"\"\"\n\n\n@bot.event\nasync def on_command_error(ctx: commands.Context, error: commands.CommandError):\n    if isinstance(error, commands.CommandNotFound):\n        return\n    if not isinstance(error, commands.CommandOnCooldown):\n        ctx.command.reset_cooldown(ctx)\n    embed = discord.Embed(\n        title=f\"Error in command {ctx.command}!\",\n        description=\"Unknown error occurred while using the command\",\n        color=discord.Color.red(),\n        timestamp=datetime.datetime.utcnow()\n    )\n    if isinstance(error, commands.CommandInvokeError):\n        if isinstance(error.original, ZeroDivisionError):\n            embed.description = \"Can't divide by zero\"\n    elif isinstance(error, commands.CommandOnCooldown):\n        embed.description = f\"This command is on cooldown. You need to wait {error.retry_after:.2f} to use that command\"\n    elif isinstance(error, AuthorHasLowerRole):\n        embed.description = \"You can't manage this member because he has a better role than yours\"\n    elif isinstance(error, commands.BotMissingPermissions):\n        embed.description = f\"I am missing required permissions to do that\"\n        embed.add_field(name=\"List of permissions\", value=', '.join(error.missing_permissions))\n    elif isinstance(error, commands.MissingPermissions):\n        embed.description = f\"You are missing required permissions to do that\"\n        embed.add_field(name=\"List of permissions\", value=', '.join(error.missing_permissions))\n    elif isinstance(error, commands.BadArgument):\n        if isinstance(error, commands.MemberNotFound):\n            embed.description = f\"Member `{error.argument}` not found\"\n        elif isinstance(error, commands.ChannelNotFound):\n            embed.description = f\"Channel `{error.argument}` not found\"\n    elif isinstance(error, commands.MissingRequiredArgument):\n        embed.description = f\"Missing required argument: `{error.param.name}`\"\n    else:\n        error_data = \"\".join(traceback.format_exception(type(error), error, error.__traceback__))\n        embed.description = f\"Unknown error\\n```py\\n{error_data[:1000]}\\n```\"\n    await ctx.send(embed=embed)\n\n\n@bot.command()\nasync def divide(ctx: commands.Context, a: int, b: int):\n    await ctx.send(f\"{a} / {b} = {a / b}\")\n\n\n@bot.command()\n@commands.cooldown(1, 10, commands.BucketType.user)\n@commands.has_guild_permissions(move_members=True)\nasync def move(ctx: commands.Context, member: discord.Member, channel: discord.VoiceChannel, *, reason=\"No reason provided\"):\n    if ctx.author.top_role &lt;= member.top_role:\n        raise AuthorHasLowerRole()\n    await member.move_to(channel, reason=reason)\n    await ctx.reply(\"Moved!\")\n\nbot.run(\"TOKEN\")\n</code></pre> <p>Note</p> <p>When a command encounters any exception, it still updates the cooldown, so this code resets it: <pre><code>if not isinstance(error, commands.CommandOnCooldown):\n    ctx.command.reset_cooldown(ctx)\n</code></pre> Using it or not is entirely up to you.</p> <p></p> <p></p> <ul> <li>If we use that command and the member is not connected to any voice, we receive an unknown error because we didn't handle it (none of our conditions were met).</li> </ul> <p></p> <ul> <li>However, this command will function properly if the user is connected to a voice channel.</li> </ul> <p></p>"},{"location":"help-command/","title":"Help Command","text":"<p>The help command is used to display information about the bot and its commands, cogs/extensions, and groups. There are two types of commands:</p> <ol> <li>Prefix/Message Commands: These are commands that are used by sending a message to the bot. They are of the form <code>&lt;prefix&gt;&lt;command&gt; [arguments]</code>. For example, <code>!help</code> is a prefix command. Your application uses the underlying <code>on_message</code> event to handle these commands and discord holds no information about them.</li> <li>Slash Commands: These are commands that are registered with discord. They are of the form <code>/command [arguments]</code>. Discord holds information about these commands and can provide information about them to users. This means discord can display to users the commands that your application has registered, required arguments, and its description.</li> </ol> <p><code>discord.py</code> by default provides a minimal help command for prefix commands. The help command can be customized to display information about the bot's commands, cogs/extensions, and groups.</p> <p>In this guide, we will cover how to customize the help command to display information about the bot's commands, cogs/extensions, and groups for prefix commands first and then extend it to display information about slash commands.</p>"},{"location":"help-command/#custom-help-command","title":"Custom Help Command","text":"<p><code>discord.py</code> has a set of base classes that can be used to create a custom help command.</p> <ul> <li><code>discord.ext.commands.DefaultHelpCommand</code>: The default help command that comes with <code>discord.py</code>. It is a subclass of <code>commands.HelpCommand</code> and acts as a basic help command for prefix and hybrid commands.</li> </ul> Default Help CommandCommand HelpGroup HelpCog Help <p></p> <p></p> <p></p> <p></p> <ul> <li><code>discord.ext.commands.MinimalHelpCommand</code>: Similar to <code>discord.ext.commands.DefaultHelpCommand</code> but with a minimalistic design, using plain text instead of code blocks and simplified formatting.</li> </ul> Minimal Help CommandCommand HelpGroup HelpCog Help <p></p> <p></p> <p></p> <p></p> <ul> <li><code>discord.ext.commands.HelpCommand</code>: The base class for creating custom help commands. It provides methods that can be overridden to customize the help command's behavior. By default, it does nothing and is meant to be subclassed.</li> </ul>"},{"location":"help-command/#methods-of-helpcommand","title":"Methods of HelpCommand","text":"<p>The <code>discord.ext.commands.HelpCommand</code> class provides the following methods that can be overridden to customize the help command's behavior and utility methods to construct the help message.</p> Method Description <code>get_bot_mapping()</code> Returns a mapping of command and command group objects to their respective cogs/extensions. If a command is not part of any cog/extension, it is mapped to <code>None</code>. <code>get_command_signature(command)</code> Returns the signature of the command. Example: <code>!command [arg1] [arg2]</code>. <code>command_not_found(string)</code> Returns a string to display when a command is not found. <code>subcommand_not_found(command, string)</code> Returns a string to display when a subcommand under a command group is not found. <code>filter_commands(commands, *, sort=False, key=None)</code> Filters the commands based on the provided parameters. It runs all associated checks with the command and takes into account weather the command is hidden. <code>get_destination()</code> Returns the destination where the help command information should be sent. <code>send_error_message(error)</code> Sends an error message to the destination. For example, the output of <code>command_not_found()</code> would be passed here. <code>on_help_command_error(ctx, error)</code> Handles the error that occurs during the execution of the help command. <code>send_bot_help(mapping)</code> Sends the help message for the bot. Invoked when no other argument was passed when calling the help command. Example: <code>!help</code>. <code>send_cog_help(cog)</code> Sends the help message for a cog/extension. Invoked when a cog/extension name was passed when calling the help command. Example: <code>!help cog_name</code>. <code>send_group_help(group)</code> Sends the help message for a command group. Invoked when a command group name was passed when calling the help command. Example: <code>!help group_name</code>. <code>send_command_help(command)</code> Sends the help message for a command. Invoked when a command name was passed when calling the help command. Example: <code>!help command_name</code>."},{"location":"help-command/#customizing-the-help-command","title":"Customizing the Help Command","text":"<p>To create a custom help command, you need to subclass <code>commands.HelpCommand</code> and override the methods you want to customize. These customizations can include formatting the help message, altering the help message's appearance, paginating the help message, and handling interactions with the user.</p> <p>We can divide the customization into two parts:</p> <ol> <li>Formatting the Help Message: This involves formatting the help message to display relevant information and also to make it visually appealing.</li> <li>Sending the Help Message: This involves sending the formatted help message to the user, and handling interactions with the user.</li> </ol> <p>Note</p> <p>In this guide, we will be utilizing the pagination classes from the Pagination guide to paginate the help message.</p>"},{"location":"help-command/#formatter-class","title":"Formatter Class","text":"<p>The <code>Formatter</code> class is responsible for formatting the help message. It contains methods to format the command signature, help, aliases, cooldown, enabled status, and description. It also contains methods to format the command, cog/extension, and group help messages.</p> help_command.py<pre><code>from typing import Optional, List\n\nimport discord\nimport humanfriendly\nfrom discord.ext import commands\n\n\nclass Formatter:\n    def __init__(self, help_command: commands.HelpCommand) -&gt; None:\n        self.ctx = help_command.context\n        self.help_command = help_command\n\n    def __format_command_signature(self, command: commands.Command) -&gt; tuple[str, str]:\n        params = self.__format_param(command)\n        return f\"{command.qualified_name}\\n\", f\"```yaml\\n{params}```\"\n\n    def __format_param(self, param: commands.Command) -&gt; str:\n        signature = self.help_command.get_command_signature(param)\n        return signature\n\n    @staticmethod\n    def __format_command_help(command: commands.Command) -&gt; str:\n        # command.help is the docstring of the command, might be None.\n        return command.help or \"No help provided.\"\n\n    @staticmethod\n    def __format_command_aliases(command: commands.Command) -&gt; str:\n        # Join the aliases with a comma and space.\n        return f\"```yaml\\nAliases: {', '.join(command.aliases)}```\" if command.aliases else \"No aliases.\"\n\n    @staticmethod\n    def __format_command_cooldown(command: commands.Command) -&gt; str:\n        # Humanfriendly is used to format the cooldown time in a human-readable format.\n        # Source: https://github.com/xolox/python-humanfriendly\n        return (\n            f\"Cooldown: {humanfriendly.format_timespan(command.cooldown.per, max_units=2)} per user.\"\n            if command.cooldown\n            else \"No cooldown set.\"\n        )\n\n    @staticmethod\n    def __format_command_enabled(command: commands.Command) -&gt; str:\n        return f\"Enabled: {command.enabled}\" if command.enabled else \"Command is disabled.\"\n\n    def format_command(self, command: commands.Command) -&gt; discord.Embed:\n        signature = self.__format_command_signature(command)\n        embed = discord.Embed(\n            title=signature[0],\n            description=signature[1] + self.__format_command_help(command),\n            color=discord.Color.blue(),\n        )\n        embed.add_field(name=\"Aliases\", value=self.__format_command_aliases(command), inline=True)\n        embed.add_field(name=\"Cooldown\", value=self.__format_command_cooldown(command), inline=True)\n        embed.add_field(name=\"Enabled\", value=self.__format_command_enabled(command), inline=True)\n        embed.set_footer(\n            text=f\"Requested by {self.ctx.author}\",\n            icon_url=self.ctx.author.display_avatar,\n        )\n        embed.set_thumbnail(url=self.ctx.bot.user.display_avatar)\n        return embed\n\n    async def format_cog_or_group(\n        self, cog_or_group: Optional[commands.Cog | commands.Group], commands_: List[commands.Command | commands.Group]\n    ) -&gt; List[discord.Embed]:\n        # Commands or command groups may be created standalone or outside a cog, in which case cog_or_group is None.\n        category_name = cog_or_group.qualified_name if cog_or_group else \"No Category\"\n        # Get the description of the cog or group.\n        if isinstance(cog_or_group, commands.Group):\n            category_desc = cog_or_group.help or \"No description provided.\"\n        else:\n            # cog_or_group is a Cog object, might be None.\n            category_desc = cog_or_group.description if cog_or_group and cog_or_group.description else \"No description provided.\"\n        cog_embed = (\n            discord.Embed(\n                title=f\"{category_name} Commands\",\n                description=f\"*{category_desc}*\" or \"*No description provided.*\",\n                color=discord.Color.blue(),\n            )\n            .set_thumbnail(url=self.ctx.bot.user.display_avatar)\n            .set_footer(\n                text=f\"Requested by {self.ctx.author}\",\n                icon_url=self.ctx.author.display_avatar,\n            )\n        )\n        embeds: List[discord.Embed] = []\n\n        # Create multiple embeds if the number of commands exceeds 5, with 5 commands per embed.\n        for i in range(0, len(commands_), 5):\n            embed = cog_embed.copy()\n            # Create chunks of 5 commands and add them to the embed.\n            for command in commands_[i : i + 5]:\n                signature = self.__format_command_signature(command)\n                embed.add_field(\n                    name=signature[0],\n                    value=signature[1] + self.__format_command_help(command),\n                    inline=False,\n                )\n            embed.set_thumbnail(url=self.ctx.bot.user.display_avatar)\n            embeds.append(embed)\n        return embeds if embeds else [cog_embed]\n</code></pre> Method Description <code>__format_command_signature</code> Formats the command signature. It returns the command name and its signature. For example, <code>&lt;prefix&gt;command [arg1] [arg2]</code>. <code>__format_param</code> Formats the command parameters, arguments, and usage. It returns the command signature. For example, <code>&lt;arg1&gt;</code>, <code>[arg2=default value]</code>. <code>__format_command_help</code> Returns the command help/description or a default message if no help is provided. <code>__format_command_aliases</code> Returns the command aliases or a default message if no aliases are provided. For example, <code>Aliases: alias1, alias2</code>. <code>__format_command_cooldown</code> Returns the command cooldown or a default message if no cooldown is set. For example, <code>Cooldown: 5 seconds per user</code>. <code>__format_command_enabled</code> Returns the command enabled status or a default message if the command is disabled. For example, <code>Enabled: True</code>. <code>format_command</code> Formats the command help message, utilizing the above methods. <code>format_cog_or_group</code> Formats the cog/extension or group help message, utilizing the above methods. Creates multiple embeds if the number of commands exceeds 5, with 5 commands per embed."},{"location":"help-command/#sending-the-help-message","title":"Sending the Help Message","text":"<p>The <code>CustomHelpCommand</code> class is responsible for sending the help message. It contains methods we need to override as per our requirements.</p> <p>Here is a flowchart which visualizes the flow of the help command, and how the methods are called:</p> <p>Flowchart of the Help Command. Image credit: InterStella0</p> help_command.py<pre><code>from typing import Mapping, Optional, List, Any, Iterable\n\nimport discord\nfrom discord.ext import commands\nfrom discord.ext.commands import Cog, Command, Group\n\nfrom paginators.advanced_paginator import EmbedCategoryPaginator, CategoryEntry\nfrom paginators.button_paginator import EmbedButtonPaginator\n\n\nclass CustomHelpCommand(commands.HelpCommand):\n    @staticmethod\n    def flatten_commands(commands_: Iterable[commands.Command | commands.Group]) -&gt; List[commands.Command]:\n        flattened = []\n        for command in commands_:\n            if isinstance(command, commands.Group):\n                flattened.extend(CustomHelpCommand.flatten_commands(command.commands))\n            else:\n                flattened.append(command)\n        return flattened\n\n    async def send_bot_help(self, mapping: Mapping[Optional[Cog], List[Command[Any, ..., Any]]], /) -&gt; None:\n        home_embed = (\n            discord.Embed(\n                title=\"Home\",\n                description=\"Documentation Bot Home Page - Custom Help Command\",\n                color=discord.Color.blue(),\n            )\n            .set_thumbnail(url=self.context.bot.user.display_avatar)\n            .set_footer(\n                text=f\"Requested by {self.context.author}\",\n                icon_url=self.context.author.display_avatar,\n            )\n        )\n\n        home_pages: List[discord.Embed] = []\n\n        for i in range(0, len(mapping), 5):\n            embed = home_embed.copy()\n            for cog, cmds in mapping.items():\n                filtered_cmds = await self.filter_commands(self.flatten_commands(cmds), sort=True)\n                embed.add_field(\n                    name=cog.qualified_name if cog else \"No Category\",\n                    value=f\"*{cog.description if cog and cog.description else 'No description provided.'}* `[Commands: {len(filtered_cmds)}]`\",\n                    inline=False,\n                )\n            home_pages.append(embed)\n\n        categories: List[CategoryEntry[discord.Embed]] = [\n            CategoryEntry(\n                category_title=\"Home\",\n                category_description=\"Documentation Bot Home Page\",\n                pages=home_pages,\n            )\n        ]\n        for cog, cmds in mapping.items():\n            filtered_cmds = await self.filter_commands(self.flatten_commands(cmds), sort=True)\n\n            # mapping includes a None key for commands that are not part of any cog, we need to check for it.\n            cog_name = cog.qualified_name if cog else \"No Category\"\n            cog_desc = cog.description if cog and cog.description else \"No description provided.\"\n\n            categories.append(\n                CategoryEntry(\n                    category_title=cog_name,\n                    category_description=cog_desc,\n                    pages=await Formatter(self).format_cog_or_group(cog, filtered_cmds),\n                )\n            )\n\n        paginator = EmbedCategoryPaginator(self.context.author, pages=categories)\n        await paginator.start_paginator(self.context)\n\n    async def send_cog_help(self, cog: Cog, /) -&gt; None:\n        commands_ = await self.filter_commands(self.flatten_commands(cog.get_commands()), sort=True)\n        embeds = await Formatter(self).format_cog_or_group(cog, commands_)\n        paginator = EmbedButtonPaginator(self.context.author, pages=embeds)\n        await paginator.start_paginator(self.context)\n\n    async def send_group_help(self, group: Group[Any, ..., Any], /) -&gt; None:\n        commands_ = await self.filter_commands(self.flatten_commands(group.commands), sort=True)\n        embeds = await Formatter(self).format_cog_or_group(group, commands_)\n        paginator = EmbedButtonPaginator(self.context.author, pages=embeds)\n        await paginator.start_paginator(self.context)\n\n    async def send_command_help(self, command: Command[Any, ..., Any], /) -&gt; None:\n        command_ = await self.filter_commands([command], sort=True)\n        embed = Formatter(self).format_command(command_[0])\n        await self.context.send(embed=embed)\n\n    async def send_error_message(self, error: str, /) -&gt; None:\n        embed = discord.Embed(\n            title=\"Error\",\n            description=error,\n            color=discord.Color.red(),\n        ).set_footer(\n            text=f\"Requested by {self.context.author}\",\n            icon_url=self.context.author.display_avatar,\n        )\n        await self.context.send(embed=embed)\n</code></pre> <p>Now let's take a look at how the <code>CustomHelpCommand</code> class works:</p> <ul> <li><code>flatten_commands</code>: For prefix commands, you can build command groups with subcommands. A command group can also have another command group registered under it, hence forming a hierarchy. This method flattens the command groups and returns a list of commands.</li> <li><code>send_bot_help</code>: This function receives a mapping or in more simple terms, a dictionary where the key is a <code>commands.Cog</code> object and the value is a list of <code>commands.Command</code> and <code>commands.Group</code> objects. There is also a singular <code>None</code> key that holds all the commands that are not part of any cog.<ul> <li>The function creates a home page that displays each cog and the number of commands it has, and the <code>No Category</code> section for commands that are not part of any cog.</li> <li>It then creates a list of <code>CategoryEntry</code> objects, where each object represents a category (cog or <code>No Category</code>) and a corresponding list of pages which include a short description for the category and the commands it contains.</li> <li>Finally, it creates an <code>EmbedCategoryPaginator</code> object and starts the paginator.</li> </ul> </li> <li><code>send_cog_help</code>: This function receives a <code>commands.Cog</code> object and sends the help message for the cog. It filters the commands of the cog, formats the cog help message, and starts the paginator. Each page contains a maximum of 5 commands.</li> <li><code>send_group_help</code>: This function receives a <code>commands.Group</code> object and sends the help message for the group. It filters the commands of the group, formats the group help message, and starts the paginator. Each page contains a maximum of 5 commands.</li> <li><code>send_command_help</code>: This function receives a <code>commands.Command</code> object and sends the help message for the command. It filters the command, formats the command help message, and sends the embed.</li> <li><code>send_error_message</code>: This function receives an error message and creates an embed with the error message. It then sends the embed to the user.</li> </ul> Bot HelpCog HelpGroup HelpCommand HelpError Message <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"help-command/#registering-the-custom-help-command","title":"Registering the Custom Help Command","text":"<p>To use the custom help command, you need to register it with the bot. You can do this by passing an instance of the <code>CustomHelpCommand</code> class to the <code>help_command</code> parameter of the <code>commands.Bot</code> constructor.</p> <pre><code>from discord.ext import commands\n\nfrom help_command import CustomHelpCommand\n\nbot = commands.Bot(command_prefix=\"!\", help_command=CustomHelpCommand())\n</code></pre> <p>Now, when you run the bot and use the help command, you will see the custom help message. This will also register your help command under ungrouped or under the <code>None</code> key in the mapping.</p> <p>Alternatively, to avoid this you can register the help command under a cog. This will group the help command under the cog name in the mapping.</p> <pre><code>from discord.ext import commands\n\nfrom help_command import CustomHelpCommand\n\n\nclass HelpCog(commands.Cog):\n    def __init__(self, bot: commands.Bot):\n        self.bot = bot\n        self._help_command = CustomHelpCommand()\n        self._help_command.cog = self\n        self._original_help_command = bot.help_command\n        bot.help_command = self._help_command\n\n    def cog_unload(self):\n        self.bot.help_command = self._original_help_command\n</code></pre> <p></p>"},{"location":"help-command/#slash-help-command","title":"Slash Help Command","text":"<p>The custom help command we created so far only works for prefix commands. This is because by default the <code>mapping</code> or the list of commands in the <code>DefaultHelpCommand</code> class does not include slash commands. Of course, there are a few more nuances to consider when altering the help command to work with slash commands. We will cover these aspects as we go along.</p> <p>There are 2 ways we can approach this:</p> <ul> <li>We modify our custom help command to include slash commands. Then we remove the default help command and register our custom help command, as a slash or hybrid command.</li> </ul> <p>This is how it would look like:</p> <pre><code>bot = commands.Bot(prefix=\"!\", intents=discord.Intents.default(), help_command=None)\n\n@bot.hybrid_command(name=\"help\", description=\"Show help for a command\")\nasync def help_(ctx: commands.Context, command: str = None) -&gt; None:\n    help_command = CustomHelpCommand(with_app_command=True)\n    help_command.context = ctx\n    await help_command.command_callback(ctx, query=command)\n</code></pre> <ul> <li>In the second approach, we create patch/update the internal <code>_HelpCommandImpl</code> to utilize the default behavior of <code>discord.py</code>'s help command for slash commands. This is a more complex approach and requires a deeper understanding of the internals of <code>discord.py</code>.</li> </ul> <pre><code>bot = commands.Bot(prefix=\"!\", intents=discord.Intents.default(), help_command=CustomHelpCommand(with_app_command=True))\n</code></pre>"},{"location":"help-command/#modifying-the-custom-help-command","title":"Modifying the Custom Help Command","text":"<p>For now we will focus on the first approach. We will patch the <code>CustomHelpCommand</code> to include slash commands and make necessary changes to the methods to handle slash commands.</p> help_command.py<pre><code># Create a complete command signature for slash commands, including subcommands and groups.\ndef _construct_full_name(command: commands.Command | app_commands.Command) -&gt; str:\n    parent: Optional[app_commands.Group] = command.parent\n    entries = []\n    while parent is not None:\n        entries.append(parent.name)\n        parent = parent.parent\n    entries.reverse()\n    entries.append(command.name)\n    return \" \".join(entries)\n\nclass CustomHelpCommand(commands.HelpCommand):\n    def __init__(\n        self,\n        *,\n        with_app_command: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        # Whether to include slash commands in the help command.\n        self.with_app_command = with_app_command\n</code></pre> <p>We add a new parameter <code>with_app_command</code> to the <code>CustomHelpCommand</code> class to include slash commands in the help command. We also define a helper function <code>_construct_full_name</code> to construct the full name of the command, including subcommands and groups.</p> <pre><code># We are using this method to construct the full name of the command, in our Formatter class.\ndef get_command_signature(\n    self, command: commands.Command[Any, ..., Any] | app_commands.Command[Any, ..., Any]\n) -&gt; str:\n    # By default, the signature of the prefix command is returned.\n    if isinstance(command, commands.Command):\n        return super().get_command_signature(command)\n    # We construct the same signature but for slash commands.\n    command_path = _construct_full_name(command)\n\n    def _format_param(data: str, *, required: bool = False) -&gt; str:\n        return f\"&lt;{data}&gt;\" if required else f\"[{data}]\"\n\n    params = []\n    for param in command.parameters:\n        # check for attachment type\n        if param.type == discord.AppCommandOptionType.attachment:\n            params.append(_format_param(f\"{param.name} (upload a file)\", required=param.required))\n            continue  \n        # check if choices are provided\n        choices = (\n            \"|\".join(\n                f\"'{choice.value}'\" if isinstance(choice.value, str) else choice.name for choice in param.choices\n            )\n            if param.choices\n            else \"\"\n        )\n        # check if default value is provided\n        default = (\n            f\"={param.default}\"\n            if not param.required and param.default is not discord.utils.MISSING and param.default not in (None, \"\")\n            else \"\"\n        )\n        # format name, choices, and default\n        formatted = f\"{param.name}{default} ({choices})\" if choices else f\"{param.name}{default}\"\n        params.append(_format_param(formatted, required=param.required))\n\n    return f\"/{command_path} {' '.join(params)}\"\n</code></pre> <p>Overrides the <code>get_command_signature</code> method to construct the full name of the command for slash commands. It constructs the command path by traversing the parent groups and subcommands. The final command signature includes the command path, parameters, choices, and default values.</p> <p>Methods with minimal changes</p> <p>The following methods have minimal changes and are used as is:</p> <pre><code>@staticmethod\ndef flatten_commands(\n-    commands_: Iterable[commands.Command | commands.Group]\n+    commands_: Iterable[commands.Command | commands.Group | app_commands.Command | app_commands.Group]\n) -&gt; List[commands.Command | app_commands.Command]:\n    flattened = []\n    for command in commands_:\n-        if isinstance(command, commands.Group):\n+        if isinstance(command, commands.Group | app_commands.Group):\n            flattened.extend(CustomHelpCommand.flatten_commands(command.commands))\n        else:\n            flattened.append(command)\n    return flattened\n</code></pre> <pre><code>-   async def send_bot_help(self, mapping: Mapping[Optional[Cog], List[Command[Any, ..., Any]]], /) -&gt; None:\n+   async def send_bot_help(self, mapping: Mapping[Optional[Cog], List[Command[Any, ..., Any] | app_commands.Command[Any, ..., Any]]], /) -&gt; None:\n</code></pre> <pre><code>-   async def send_cog_help(self, cog: Cog, /) -&gt; None:\n+   async def send_cog_help(self, cog: commands.GroupCog | commands.Cog, /) -&gt; None:\n-   commands_ = await self.filter_commands(self.flatten_commands(cog.get_commands()), sort=True)\n+   commands = cog.get_commands() + (cog.get_app_commands() if self.with_app_command else [])\n+   if isinstance(cog, commands.GroupCog):\n+       commands.extend(cog.app_command.commands)\n+   commands_ = await self.filter_commands(self.flatten_commands(commands), sort=True)\n    embeds = await Formatter(self).format_cog_or_group(cog, commands_)\n    paginator = EmbedButtonPaginator(self.context.author, pages=embeds)\n    await paginator.start_paginator(self.context)\n</code></pre> <pre><code>-   async def send_group_help(self, group: Group[Any, ..., Any], /) -&gt; None:\n+   async def send_group_help(self, group: Group[Any, ..., Any] | app_commands.Group, /) -&gt; None:\n</code></pre> <pre><code>-   async def send_command_help(self, command: Command[Any, ..., Any], /) -&gt; None:\n+   async def send_command_help(self, command: Command[Any, ..., Any] | app_commands.Command[Any, ..., Any], /) -&gt; None:\n</code></pre> <p>For complete set of changes, refer to the source code.</p> <pre><code># This method is used to construct the `mapping` for the help command.\ndef get_all_commands(\n    self,\n) -&gt; Mapping[Optional[Cog], List[Command[Any, ..., Any] | app_commands.Command[Any, ..., Any]]]:\n    # Default mapping for prefix commands.\n    mapping = self.get_bot_mapping()\n    # Update mapping for slash commands, if enabled\n    if self.with_app_command:\n        for cog, cmds in self.get_app_command_mapping().items():\n            for cmd in cmds:\n                if cmd.name not in (c.name for c in mapping.get(cog, [])):\n                    mapping.setdefault(cog, []).append(cmd)\n    return mapping\n\ndef get_app_command_mapping(\n    self,\n) -&gt; Mapping[Optional[Cog], List[app_commands.Command[Any, ..., Any] | app_commands.Group]]:\n    # App commands can exist under a cog, or unbound not under any category\n\n    mapping = {}\n    # Iterate through each cog\n    for cog in self.context.bot.cogs.values():\n        # If it's a GroupCog, you can define prefix commands inside it, but it will not be included as a subcommand.\n        # And prefix or text part of a hybrid command defined here is not included in the default mapping.\n        # Hence, we also perform `cog.get_commands()` to get the prefix commands for this edge case.\n        if isinstance(cog, commands.GroupCog):\n            mapping.setdefault(cog, [*cog.get_commands()]).extend(cog.app_command.commands)\n            continue\n        # Include app commands present in the cog.\n        mapping.setdefault(cog, []).extend(cog.get_app_commands())\n\n    # Get unbound commands, i.e., commands not part of any cog.\n    def get_unbound_cmds(with_guild=None):\n        return [\n            c\n            for c in self.context.bot.tree.get_commands(guild=with_guild)\n            if isinstance(c, app_commands.Command) and c.binding is None\n        ]\n\n    # Include unbound commands, specific to a guild if available.\n    if self.context.guild:\n        mapping.setdefault(None, []).extend(get_unbound_cmds(self.context.guild))\n\n    # Include unbound commands, not specific to any guild (global commands).\n    mapping.setdefault(None, []).extend(get_unbound_cmds())\n\n    return mapping\n</code></pre> <p>One of the major changes is the addition of the <code>get_app_command_mapping</code> method. This method constructs the mapping for slash commands. It iterates through each cog and includes the app commands present in the cog. It also includes unbound commands, i.e., commands not part of any cog. The <code>get_all_commands</code> method is updated to include the mapping for both prefix and slash commands.</p> <pre><code># This where the internal logic of the help command is handled and different help messages are sent based on the query.\nasync def command_callback(self, ctx: commands.Context[commands.Bot], /, *, query: Optional[str] = None) -&gt; None:\n    \"\"\"\n    This is the entry point of the help command.\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation.\n    query: Optional[str]\n        The command, group, or cog to get help for.\n    \"\"\"\n    command = query\n    # Empty function by default, you can override to perform some pre-processing or setup.\n    await self.prepare_help_command(ctx, command)\n\n    bot = ctx.bot\n\n    # If no command is provided, send the bot help message. (e.g., !help)\n    if command is None:\n        mapping = self.get_all_commands()\n        return await self.send_bot_help(mapping)\n\n    # Check if the command is a cog or extension.\n    cog = bot.get_cog(command)\n    if cog:\n        return await self.send_cog_help(cog)\n\n    maybe_coro = discord.utils.maybe_coroutine\n\n    # Split the command into parts. (e.g., !help command subcommand)\n    keys = command.split()\n    # Get the initial command or group, if it exists.\n    cmd = bot.all_commands.get(keys[0])\n\n    if self.with_app_command:\n        guild_id = ctx.guild.id if ctx.guild else None\n\n        if cmd is None:\n            cmd = bot.tree.get_command(keys[0], guild=discord.Object(id=guild_id))\n\n        if cmd is None:\n            cmd = bot.tree.get_command(keys[0])\n\n    # If the command does not exist, send an error message.\n    if cmd is None:\n        string = await maybe_coro(self.command_not_found, self.remove_mentions(command))\n        return await self.send_error_message(string)\n\n    # If the command is a group and query has subcommands, get the subcommand.\n    for key in keys[1:]:\n        try:\n            cmds = getattr(cmd, \"all_commands\", None) or cmd._children\n            found = cmds.get(key) if cmds else None\n        except AttributeError:\n            string = await maybe_coro(self.subcommand_not_found, cmd, self.remove_mentions(key))  # type: ignore\n            return await self.send_error_message(string)\n        else:\n            if found is None:\n                string = await maybe_coro(self.subcommand_not_found, cmd, self.remove_mentions(key))  # type: ignore\n                return await self.send_error_message(string)\n            cmd = found\n\n    # Send group help if it's a group.\n    if isinstance(cmd, commands.Group | app_commands.Group):\n        return await self.send_group_help(cmd)\n\n    # Send command help if it's a command.\n    return await self.send_command_help(cmd)\n</code></pre> <p>The <code>command_callback</code> method is the entry point for the help command logic. It handles the internal logic of the help command and sends different help messages based on the query.</p> <ul> <li>If no query is provided, it sends the bot help message.</li> <li>If the query is a cog or extension, it sends the cog help message.</li> <li>If the query is a command group, it sends the group help message.</li> <li>If the query is a command, it sends the command help message.</li> <li>If the command does not exist, it sends an error message.</li> </ul> <pre><code># The default `filter_commands` method only works for prefix commands.\n# We need to override it to function with slash commands.\nasync def filter_commands(\n    self,\n    commands: Iterable[Command[Any, ..., Any] | app_commands.Command[Any, ..., Any]],\n    /,\n    *,\n    sort: bool = False,\n    key: Optional[Callable[[Command[Any, ..., Any] | app_commands.Command[Any, ..., Any]], Any] | None] = None,\n) -&gt; List[Command[Any, ..., Any] | app_commands.Command[Any, ..., Any]]:\n    if sort and key is None:\n        key = lambda c: c.name  # noqa: E731\n\n    # Filter commands based on 'hidden' attribute.\n    iterator = commands if self.show_hidden else filter(lambda c: not getattr(c, \"hidden\", None), commands)\n\n    if self.verify_checks is False:\n        # if we do not need to verify the checks then we can just\n        # run it straight through normally without using await.\n        return sorted(iterator, key=key) if sort else list(iterator)  # type: ignore # the key shouldn't be None\n\n    if self.verify_checks is None and not self.context.guild:\n        # if verify_checks is None, and we're in a DM, don't verify\n        return sorted(iterator, key=key) if sort else list(iterator)  # type: ignore\n\n    # if we're here then we need to check every command if it can run\n    async def predicate(cmd: Command[Any, ..., Any] | app_commands.Command) -&gt; bool:\n        ctx = self.context\n\n        # Check if the command can run in the current context, for prefix commands.\n        if isinstance(cmd, Command):\n            try:\n                return await cmd.can_run(ctx)\n            except discord.ext.commands.CommandError:\n                return False\n\n        # Check if the command can run in the current context, for slash commands.\n        no_interaction = ctx.interaction is None\n        # If the command has no checks and there is no interaction\n        if not cmd.checks and no_interaction:\n            binding = cmd.binding\n            if cmd.parent is not None and cmd.parent is not binding:\n                return False  # it has group command interaction check\n\n            if binding is not None:\n                check = getattr(binding, \"interaction_check\", None)\n                if check:\n                    return False  # it has cog interaction check\n\n            return True\n\n        # If there is no interaction, return False.\n        if no_interaction:\n            return False\n\n        try:\n            # Internal method for slash commands to check if the command can run.\n            return await cmd._check_can_run(ctx.interaction)\n        except app_commands.AppCommandError:\n            return False\n\n    # Filter the commands based on the predicate.\n    ret = []\n    for cmd in iterator:\n        valid = await predicate(cmd)\n        if valid:\n            ret.append(cmd)\n\n    if sort:\n        ret.sort(key=key)\n    return ret\n</code></pre> <p><code>filter_commands</code> method is used to filter viable/usable commands based on the context of the invocation. It filters the commands based on checks and attributes defined. The method is overridden to also function with slash commands.</p> <p>Let's now take a look at the how to utilize the custom help command with slash commands.</p> <pre><code>bot = commands.Bot(prefix=\"!\", intents=discord.Intents.default(), help_command=None)\n\n@bot.hybrid_command(name=\"help\", description=\"Show help for a command\")\nasync def help_(ctx: commands.Context, command: str = None) -&gt; None:\n    help_command = CustomHelpCommand(with_app_command=True)\n    help_command.context = ctx\n    await help_command.command_callback(ctx, query=command)\n</code></pre> <p></p> Modified <code>Formatter</code> class <p>A few minor modifications are made to the <code>Formatter</code> class to handle parameter and signature formatting for slash commands.</p> help_command.py<pre><code>class Formatter:\n    def __init__(self, help_command: commands.HelpCommand) -&gt; None:\n        self.ctx = help_command.context\n        self.help_command = help_command\n\n    def __format_command_signature(self, command: commands.Command | app_commands.Command) -&gt; tuple[str, str]:\n        params = self.help_command.get_command_signature(command)\n        return f\"{command.qualified_name}\\n\", f\"```yaml\\n{params}```\"\n\n    # Updated method to generate detail about the command parameters.\n    @staticmethod\n    def __format_param(param: app_commands.Parameter | commands.Parameter) -&gt; str:\n        result = (\n            f\"{param.name}={param.default}\"\n            if not param.required and param.default is not discord.utils.MISSING and param.default not in (None, \"\")\n            else f\"{param.name}\"\n        )\n        result = f\"[{result}]\" if not param.required else f\"&lt;{result}&gt;\"\n        if isinstance(param, commands.Parameter):\n            return f\"```yaml\\n{param.name} ({param.annotation.__name__}) - {result}:\\n\\t{param.description}```\"\n        choices = (\n            \", \".join(f\"'{choice.value}'\" if isinstance(choice.value, str) else choice.name for choice in param.choices)\n            if param.choices\n            else \"\"\n        )\n        result = f\"{param.name} ({param.type.name}) - {result}:\"\n        result += f\"\\n\\t{param.description}\" if param.description else \"\"\n        result += f\"\\n\\tChoices: {choices}\" if choices else \"\"\n        return f\"```yaml\\n{result}```\"\n\n    @staticmethod\n    def __format_command_help(command: commands.Command | app_commands.Command) -&gt; str:\n        return command.description or \"No help provided.\"\n\n    @staticmethod\n    def __format_command_aliases(command: commands.Command | app_commands.Command) -&gt; str:\n        if isinstance(command, app_commands.Command):\n            return \"No aliases.\"\n        return f\"```yaml\\nAliases: {', '.join(command.aliases)}```\" if command.aliases else \"No aliases.\"\n\n    @staticmethod\n    def __format_command_cooldown(command: commands.Command | app_commands.Command) -&gt; str:\n        if isinstance(command, app_commands.Command):\n            return \"No cooldown set.\"\n        return (\n            f\"Cooldown: {humanfriendly.format_timespan(command.cooldown.per, max_units=2)} per user.\"\n            if command.cooldown\n            else \"No cooldown set.\"\n        )\n\n    @staticmethod\n    def __format_command_enabled(command: commands.Command | app_commands.Command) -&gt; str:\n        if isinstance(command, app_commands.Command):\n            return \"Command is enabled.\"\n        return f\"Enabled: {command.enabled}\" if command.enabled else \"Command is disabled.\"\n\n    def format_command(self, command: commands.Command | app_commands.Command) -&gt; discord.Embed:\n        signature = self.__format_command_signature(command)\n        embed = discord.Embed(\n            title=signature[0],\n            description=signature[1] + self.__format_command_help(command),\n            color=discord.Color.blue(),\n        )\n\n        params = command.parameters if isinstance(command, app_commands.Command) else command.params.values()\n        # format each parameter of the command, new method __format_param is used.\n        for param in params:\n            embed.add_field(\n                name=param.name,\n                value=self.__format_param(param),\n                inline=False,\n            )\n        embed.add_field(name=\"Aliases\", value=self.__format_command_aliases(command), inline=True)\n        embed.add_field(name=\"Cooldown\", value=self.__format_command_cooldown(command), inline=True)\n        embed.add_field(name=\"Enabled\", value=self.__format_command_enabled(command), inline=True)\n        embed.set_footer(\n            text=f\"Requested by {self.ctx.author}\",\n            icon_url=self.ctx.author.display_avatar,\n        )\n        embed.set_thumbnail(url=self.ctx.bot.user.display_avatar)\n        return embed\n\n    async def format_cog_or_group(\n        self,\n        cog_or_group: Optional[commands.GroupCog | app_commands.Group | commands.Cog | commands.Group],\n        commands_: List[commands.Command | commands.Group | app_commands.Command | app_commands.Group],\n    ) -&gt; List[discord.Embed]:\n        category_name = cog_or_group.qualified_name if cog_or_group else \"No Category\"\n        if isinstance(cog_or_group, commands.Group):\n            category_desc = cog_or_group.help or \"No description provided.\"\n        else:\n            category_desc = (\n                cog_or_group.description if cog_or_group and cog_or_group.description else \"No description provided.\"\n            )\n        cog_embed = (\n            discord.Embed(\n                title=f\"{category_name} Commands\",\n                description=f\"*{category_desc}*\" or \"*No description provided.*\",\n                color=discord.Color.blue(),\n            )\n            .set_thumbnail(url=self.ctx.bot.user.display_avatar)\n            .set_footer(\n                text=f\"Requested by {self.ctx.author}\",\n                icon_url=self.ctx.author.display_avatar,\n            )\n        )\n        embeds: List[discord.Embed] = []\n        for i in range(0, len(commands_), 5):\n            embed = cog_embed.copy()\n            for command in commands_[i : i + 5]:\n                signature = self.__format_command_signature(command)\n                embed.add_field(\n                    name=signature[0],\n                    value=signature[1] + self.__format_command_help(command),\n                    inline=False,\n                )\n            embed.set_thumbnail(url=self.ctx.bot.user.display_avatar)\n            embeds.append(embed)\n        return embeds if embeds else [cog_embed]\n</code></pre>"},{"location":"help-command/#an-advanced-approach","title":"An advanced approach","text":"<p>Now that we have implemented the custom help command for both prefix and slash commands, we can try to dive a little deeper and integrate this approach with the internal mechanics of <code>discord.py</code>.</p> <p>Note</p> <p>This section is entirely optional and requires a deeper understanding of the internals of <code>discord.py</code>, for the general use case the above approach should suffice.</p> <p>To integrate the custom help command with the internal mechanics of <code>discord.py</code>, we will be creating a custom implementation of the <code>_HelpCommandImpl</code> class.</p> <pre><code>class _InjectorCallback:\n    # This class is to ensure that the help command instance gets passed properly\n    # The final level of invocation will always lead back to the _original instance\n    # hence bind needed to be modified before invoke is called.\n    def __init__(self, original_callback: Any, bind: \"CustomHelpCommand\") -&gt; None:\n        self.callback = original_callback\n        self.bind = bind\n\n    async def invoke(self, *args: Any, **kwargs: Any) -&gt; Any:\n        # *args include ctx/context, command/query\n        # If HelpCommand is registered under a cog, the cog instance is passed as the first argument.\n        # Skip the first argument if it's a cog instance.\n        if self.bind.cog is not None:\n            cog, *args = args\n\n        # self.callback is the `command_callback` bound method of the CustomHelpCommand instance.\n        # self.callback.__func__ returns the original function to be invoked.\n        # await CustomHelpCommand.command_callback(bound_instance, ctx, query)\n        return await self.callback.__func__(self.bind, *args, **kwargs)\n\n\ndef _inject_callback(inject):\n    # This method is used to inject the custom help command callback into the internal help command.\n    try:\n        inject.__original_callback__\n    except AttributeError:\n        inject.__original_callback__ = _InjectorCallback(inject.command_callback, inject)\n\n    caller = inject.__original_callback__  # The _InjectorCallback instance.\n    original_callback = caller.callback  # The 'command_callback' method of the CustomHelpCommand instance.\n\n    # Wrapper method to invoke the original callback.\n    async def wrapper(*args, **kwargs):\n        return await caller.invoke(*args, **kwargs)\n\n    callback = copy.copy(wrapper)\n    # Copy the signature of the original callback to the wrapper method.\n    signature = list(Signature.from_callable(original_callback).parameters.values())\n    callback.__signature__ = Signature.from_callable(callback).replace(parameters=signature)\n    # Update the 'command_callback' method of the CustomHelpCommand instance with the wrapper method.\n    inject.command_callback = callback\n\n\ndef _parse_params_docstring(func: Callable[..., Any]) -&gt; dict[str, str]:\n    doc = inspect.getdoc(func)\n    if doc is None:\n        return {}\n\n    param_docs = {}\n    sphinx_pattern = re.compile(r\"^\\s*:param\\s+(\\S+).*?:\\s*(.+)\", re.MULTILINE)\n    google_pattern = re.compile(r\"^\\s*(\\S+)\\s*\\(.*?\\):\\s*(.+)\", re.MULTILINE)\n    numpy_pattern = re.compile(r\"^\\s*(\\S+)\\s*:\\s*.*?\\n\\s*(.+?)(?=\\n\\S|\\Z)\", re.DOTALL | re.MULTILINE)\n\n    for pattern in (sphinx_pattern, google_pattern, numpy_pattern):\n        for match in pattern.finditer(doc):\n            param_name, desc = match.groups()\n            param_docs[param_name] = desc\n    return param_docs\n\n# Most of the implementation is similar to the default _HelpCommandImpl.\nclass _HelpHybridCommandImpl(commands.HybridCommand):\n    def __init__(self, inject: \"CustomHelpCommand\", *args: Any, **kwargs: Any) -&gt; None:\n        # Create a wrapper around the CustomHelpCommand instance.\n        _inject_callback(inject)\n        super().__init__(inject.command_callback, *args, **kwargs)\n        self._original: \"CustomHelpCommand\" = inject\n        self._injected: \"CustomHelpCommand\" = inject\n        self.params: Dict[str, Parameter] = get_signature_parameters(\n            inject.__original_callback__.callback, globals(), skip_parameters=1\n        )\n\n        # get function params descriptions, from the original callback docstring\n        param_descs = _parse_params_docstring(inject.__original_callback__.callback)\n        if self.app_command:\n            # Describe the parameters for the app command, so they show up in discord client.\n            app_params = [p for p in self.app_command.parameters if p.name in param_descs]\n            app_commands.describe(**{p.name: param_descs[p.name] for p in app_params})(self.app_command)\n\n        self.params.update(\n            (name, param.replace(description=desc))\n            for name, desc in param_descs.items()\n            if (param := self.params.get(name))\n        )\n\n        # Inject the callback metadata for the help command. i.e., AppCommand autocomplete.\n        self.__inject_callback_metadata(inject)\n\n    def __inject_callback_metadata(self, inject: \"CustomHelpCommand\") -&gt; None:\n        if not self.with_app_command:\n            return\n        # A method that can be defined in the CustomHelpCommand to provide autocomplete for the help command.\n        autocomplete = inject.help_command_autocomplete\n        self.autocomplete(list(dict.fromkeys(self.params))[-1])(autocomplete)\n\n    async def prepare(self, ctx: Context[Any]) -&gt; None:\n        self._injected = injected = self._original.copy()\n        injected.context = ctx\n        # Update the bound instance of the callback method.\n        self._original.__original_callback__.bind = injected  # type: ignore\n        self.params = get_signature_parameters(injected.__original_callback__.callback, globals(), skip_parameters=1)\n\n        # get function params descriptions, from the original callback docstring\n        param_descs = _parse_params_docstring(injected.__original_callback__.callback)\n        self.params.update(\n            (name, param.replace(description=desc))\n            for name, desc in param_descs.items()\n            if (param := self.params.get(name))\n        )\n\n        on_error = injected.on_help_command_error\n        if not hasattr(on_error, \"__help_command_not_overridden__\"):\n            if self.cog is not None:\n                self.on_error = self._on_error_cog_implementation\n            else:\n                self.on_error = on_error\n\n        await super().prepare(ctx)\n\n    async def _on_error_cog_implementation(self, _, ctx: Context[commands.Bot], error: CommandError) -&gt; None:\n        await self._injected.on_help_command_error(ctx, error)\n\n    def _inject_into_cog(self, cog: Cog) -&gt; None:\n        # Warning: hacky\n\n        # Make the cog think that get_commands returns this command\n        # as well if we inject it without modifying __cog_commands__\n        # since that's used for the injection and ejection of cogs.\n        def wrapped_get_commands(\n            *, _original: Callable[[], List[Command[Any, ..., Any]]] = cog.get_commands\n        ) -&gt; List[Command[Any, ..., Any]]:\n            ret = _original()\n            ret.append(self)\n            return ret\n\n        # Ditto here\n        def wrapped_walk_commands(\n            *, _original: Callable[[], Generator[Command[Any, ..., Any], None, None]] = cog.walk_commands\n        ):\n            yield from _original()\n            yield self\n\n        functools.update_wrapper(wrapped_get_commands, cog.get_commands)\n        functools.update_wrapper(wrapped_walk_commands, cog.walk_commands)\n        cog.get_commands = wrapped_get_commands\n        cog.walk_commands = wrapped_walk_commands\n        self.cog = cog\n\n    def _eject_cog(self) -&gt; None:\n        if self.cog is None:\n            return\n\n        # revert back into their original methods\n        cog = self.cog\n        cog.get_commands = cog.get_commands.__wrapped__\n        cog.walk_commands = cog.walk_commands.__wrapped__\n        self.cog = None\n\n\n# Remaining methods are same as what we implemented in the CustomHelpCommand class above.\nclass CustomHelpCommand(commands.HelpCommand):\n    __original_callback__: _InjectorCallback\n\n    def __init__(\n        self,\n        *,\n        name: str = \"help\",\n        description: str = \"Shows this message\",\n        with_app_command: bool = False,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(**kwargs)\n        self.with_app_command = with_app_command\n        self.command_attrs[\"with_app_command\"] = with_app_command\n        self.command_attrs[\"name\"] = name\n        self.command_attrs[\"description\"] = description\n        self._command_impl = _HelpHybridCommandImpl(self, **self.command_attrs)\n\n    def _add_to_bot(self, bot: commands.bot.BotBase) -&gt; None:\n        # Add the custom help command to the bot.\n        command = _HelpHybridCommandImpl(self, **self.command_attrs)\n        self._command_impl = command\n        bot.add_command(command)\n\n    def _remove_from_bot(self, bot: commands.bot.BotBase) -&gt; None:\n        # Remove the custom help command from the bot.\n        impl = self._command_impl\n        bot.remove_command(impl.name)\n        app = impl.app_command\n        for snowflake in getattr(app, \"_guild_ids\", None) or []:\n            bot.tree.remove_command(app.name, guild=discord.Object(snowflake))\n        impl._eject_cog()\n\n    async def help_command_autocomplete(\n        self, inter: discord.Interaction[commands.Bot], current: str\n    ) -&gt; list[app_commands.Choice[str]]:\n        help_command = self.copy()\n        help_command.context = await inter.client.get_context(inter)\n\n        all_cmds: dict[str, list[commands.Command | app_commands.Command]] = {\n            cog.qualified_name if cog else \"No Category\": help_command.flatten_commands(cmds)\n            for cog, cmds in help_command.get_all_commands().items()\n        }\n        choices = list(all_cmds.keys()) + [_construct_full_name(cmd) for cmd in sum(all_cmds.values(), [])]\n        matches = difflib.get_close_matches(current, choices, n=25, cutoff=0.4) or sorted(\n            choices, key=lambda x: x.lower()\n        )\n        return [app_commands.Choice(name=match, value=match) for match in matches][:25]\n</code></pre> <p>Finally, we can register the custom help command with the bot.</p> <pre><code>bot = commands.Bot(prefix=\"!\", intents=discord.Intents.default(), help_command=CustomHelpCommand(with_app_command=True))\n</code></pre> Slash Help CommandHelp DescribeHelp Autocomplete <p></p> <p></p> <p>Parameter description is extracted from the docstring of the command callback.</p> <p></p> <p>Overriding the <code>help_command_autocomplete</code> method allows you to provide autocomplete for the help command.</p> <p>The complete source code for the above can be found here.</p>"},{"location":"help-command/#conclusion","title":"Conclusion","text":"<p>Whew! That was a lot of information. We covered in detail each aspect of the help command provided by <code>discord.py</code> and how you can customize it to suit your needs. We also discussed how to integrate the custom help command with slash commands. We hope this guide helps you understand the help command better and how you can customize it to provide a better experience for your users.</p> <ul> <li>Custom Help Command Source Code</li> <li>A Help Command extension library by InterStella0.</li> </ul>"},{"location":"hybrid-commands/","title":"Hybrid Commands","text":"<p>Hybrid commands are commands that can be used both as a slash command and as a regular prefix command. This is useful for commands that you want to be able to use both ways, but don't want to have to write the same code twice. In order for this to work, the callback must have the same subset that is supported by application commands.</p> <p></p> <p>Warning</p> <p>Hybrid commands are only available in discord.py 2.0 and above.</p>"},{"location":"hybrid-commands/#creating-a-hybrid-command","title":"Creating a Hybrid Command","text":"<p>To create a hybrid command, you must use the <code>hybrid_command</code> decorator. This decorator takes an additional <code>name</code> and <code>description</code> parameters, which are used to register the slash command. In case <code>name</code> is not provided, the name of the function will be used.</p> <p>There are two ways to document hybrid commands. You can either use the <code>app_commands.describe</code> decorator or docstrings. <code>discord.py</code> accepts multiple docstring formats, including Google-style, NumPy-style, and Sphinx-style.</p> Using ParametersUsing Docstrings <pre><code>@bot.hybrid_command(name=\"echo\", description=\"Echoes a message\")\n@app_commands.describe(message=\"The message to echo\")\nasync def echo(ctx: commands.Context, message: str):\n    await ctx.send(message)\n</code></pre> <pre><code>@bot.hybrid_command()\nasync def echo(ctx: commands.Context, message: str):\n    \"\"\"\n    Echoes a message\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    message: str\n        The message to echo\n    \"\"\"\n    await ctx.send(message)\n</code></pre> <p> </p> <p>Note</p> <p>The <code>name</code> parameter must be a valid slash command name. This means that it must be between 1 and 32 characters long, and can only contain alphanumeric characters, dashes, and underscores.</p>"},{"location":"hybrid-commands/#hybrid-command-parameters","title":"Hybrid Command Parameters","text":"<p>Hybrid commands similarly to slash commands, have a few parameters that are supported by discord when registering the command.</p> <ul> <li><code>str [AppCommandOptionType.string]</code> - A string parameter</li> <li><code>int [AppCommandOptionType.integer]</code> - An integer parameter</li> <li><code>float [AppCommandOptionType.number]</code> - A float parameter</li> <li><code>bool [AppCommandOptionType.boolean]</code> - A boolean parameter</li> <li><code>discord.User [AppCommandOptionType.user]</code> or <code>discord.Member</code> - A user or member parameter. A user annotation can also result in a member parameter.</li> <li>* <code>discord.abc.GuildChannel</code> - A channel parameter</li> <li><code>discord.Role [AppCommandOptionType.role]</code> - A role parameter</li> <li><code>discord.Attachment [AppCommandOptionType.attachment]</code> - An attachment parameter</li> </ul> <p>All other parameters will be treated as a string parameter and can be converted implicitly using converters</p> <p>Info</p> <ul> <li> <p>* All channel subclasses and unions (e.g. Union[TextChannel, StageChannel]) are also supported.</p> </li> <li> <p>Some combinations of types are also allowed, including:</p> <ul> <li>Union[User, Member] (results in AppCommandOptionType.user)</li> <li>Union[Member, Role] (results in AppCommandOptionType.mentionable)</li> <li>Union[User, Role] (results in AppCommandOptionType.mentionable)</li> <li>Union[User, Member, Role] (results in AppCommandOptionType.mentionable)</li> </ul> </li> </ul> StringIntegerFloatBooleanUserChannelRoleAttachment <pre><code>@bot.hybrid_command()\nasync def echo(ctx: commands.Context, message: str):\n    \"\"\"\n    Echoes a message\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    message: str\n        The message to echo\n    \"\"\"\n    await ctx.send(message)\n</code></pre> <p></p> <pre><code>@bot.hybrid_command()\nasync def echo(ctx: commands.Context, number: int):\n    \"\"\"\n    Echoes a number\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    number: int\n        The number to echo\n    \"\"\"\n    await ctx.send(number)\n</code></pre> <p></p> <pre><code>@bot.hybrid_command()\nasync def echo(ctx: commands.Context, number: float):\n    \"\"\"\n    Echoes a number\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    number: float\n        The number to echo\n    \"\"\"\n    await ctx.send(number)\n</code></pre> <p></p> <pre><code>@bot.hybrid_command()\nasync def echo(ctx: commands.Context, boolean: bool):\n    \"\"\"\n    Echoes a boolean\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    boolean: bool\n        The boolean to echo\n    \"\"\"\n    await ctx.send(boolean)\n</code></pre> <p></p> <pre><code>@bot.hybrid_command()\nasync def echo(ctx: commands.Context, user: discord.User):\n    \"\"\"\n    Echoes a user\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    user: discord.User\n        The user to echo\n    \"\"\"\n    embed = discord.Embed(title=user.display_name, description=f\"{user.mention} is cool\", color=user.color)\n    embed.set_thumbnail(url=user.display_avatar)\n    await ctx.send(embed=embed)\n</code></pre> <p></p> <pre><code>@bot.hybrid_command()\nasync def echo(ctx: commands.Context, channel: discord.abc.GuildChannel):\n    \"\"\"\n    Echoes a channel\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    channel: discord.abc.GuildChannel\n        The channel to echo\n    \"\"\"\n    # channel types include StageChannel, TextChannel, VoiceChannel, CategoryChannel, ForumChannel\n    await ctx.send(channel.mention)\n</code></pre> <p></p> <pre><code>@bot.hybrid_command()\nasync def echo(ctx: commands.Context, role: discord.Role):\n    \"\"\"\n    Echoes a role\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    role: discord.Role\n        The role to echo\n    \"\"\"\n    embed = discord.Embed(title=role.name, description=f\"{role.mention} is cool\", color=role.color)\n    await ctx.send(embed=embed)\n</code></pre> <p></p> <pre><code>@bot.hybrid_command()\nasync def echo(ctx: commands.Context, attachment: discord.Attachment):\n    \"\"\"\n    Echoes an attachment\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    attachment: discord.Attachment\n        The attachment to echo\n    \"\"\"\n    embed = discord.Embed(title=attachment.filename, description=f\"Attachment from {attachment.url}\\nSize: {attachment.size / 1024} KB\", color=discord.Color.random())\n    embed.set_image(url=attachment.url)\n    await ctx.send(embed=embed)\n</code></pre> <p></p>"},{"location":"hybrid-commands/#parameter-ranges","title":"Parameter Ranges","text":"<p>You can also specify a range for integer and float parameters. This can be done by annotating using <code>app_commands.Range</code>, and for string you can specify the minimum and maximum length.</p> IntegerFloatString <pre><code>@bot.hybrid_command()\nasync def echo(ctx: commands.Context, number: app_commands.Range[int, 0, 10]):\n    \"\"\"\n    Echoes a number\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    number: app_commands.Range[int, 0, 10]\n        The number to echo\n    \"\"\"\n    await ctx.send(number)\n</code></pre> <p></p> <pre><code>@bot.hybrid_command()\nasync def echo(ctx: commands.Context, number: app_commands.Range[float, 0.0, 10.0]):\n    \"\"\"\n    Echoes a number\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    number: app_commands.Range[float, 0.0, 10.0]\n        The number to echo\n    \"\"\"\n    await ctx.send(number)\n</code></pre> <p></p> <pre><code>@bot.hybrid_command()\nasync def echo(ctx: commands.Context, message: app_commands.Range[str, 1, 10]):\n    \"\"\"\n    Echoes a message\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    message: app_commands.Range[str, 1, 10]\n        The message to echo\n    \"\"\"\n    await ctx.send(message)\n</code></pre> <p></p> <p>Warning</p> <p>Since <code>Range</code> is a slash command specific annotation, it will not work with regular prefix commands.</p>"},{"location":"hybrid-commands/#choices","title":"Choices","text":"<p>You can also specify choices for parameters. This gives a dropdown menu with the specified choices for the parameter in discord.</p> Using EnumsUsing LiteralUsing Decorator <pre><code>import enum\n\nclass Color(str, enum.Enum):\n    Red = \"red\"\n    Green = \"green\"\n    Blue = \"blue\"\n\n@bot.hybrid_command()\nasync def echo(ctx: commands.Context, color: Color):\n    \"\"\"\n    Echoes a color\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    color: Color\n        The color to echo\n    \"\"\"\n    await ctx.send(color)\n</code></pre> <pre><code>from typing import Literal\n\n@bot.hybrid_command()\nasync def echo(ctx: commands.Context, color: Literal[\"red\", \"green\", \"blue\"]):\n    \"\"\"\n    Echoes a color\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    color: Literal[\"red\", \"green\", \"blue\"]\n        The color to echo\n    \"\"\"\n    await ctx.send(color)\n</code></pre> <pre><code>@bot.hybrid_command()\n@app_commands.choices(color=[\n    app_commands.Choice(name=\"Red\", value=\"red\"),\n    app_commands.Choice(name=\"Green\", value=\"green\"),\n    app_commands.Choice(name=\"Blue\", value=\"blue\")\n])\nasync def echo(ctx: commands.Context, color: str):\n    \"\"\"\n    Echoes a color\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    color: str\n        The color to echo\n    \"\"\"\n    await ctx.send(color)\n</code></pre> <p></p> <p>Warning</p> <p>Since <code>choices</code> is a slash command specific annotation, while using the command as a regular prefix command, the choices will not be available and no checks will be performed on the parameter internally i.e you can pass any value to the parameter.</p> <p>You can have maximum of 25 choices for a parameter.</p>"},{"location":"hybrid-commands/#autocomplete","title":"Autocomplete","text":"<p>You can also specify autocomplete options for parameters. This gives a dropdown menu with the specified autocomplete options for the parameter in discord based on the user's input.</p> <p>Currently, autocomplete is only supported for string, integer and float parameters.</p> Using CallbackUsing Decorator <pre><code>async def color_autocomplete(interaction: discord.Interaction, current: str) -&gt; list[app_commands.Choice[str]]:\n    options = [\"Red\", \"Green\", \"Blue\"]\n    return [app_commands.Choice(name=option, value=option) for option in options if option.lower().startswith(current.lower())][:25]\n\n@bot.hybrid_command()\n@app_commands.autocomplete(color=color_autocomplete)\nasync def echo(ctx: commands.Context, color: str):\n    \"\"\"\n    Echoes a color\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    color: str\n        The color to echo\n    \"\"\"\n    await ctx.send(color)\n</code></pre> <pre><code>@bot.hybrid_command()\nasync def echo(ctx: commands.Context, color: str):\n    \"\"\"\n    Echoes a color\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    color: str\n        The color to echo\n    \"\"\"\n    await ctx.send(color)\n\n@echo.autocomplete(\"color\")\nasync def color_autocomplete(interaction: discord.Interaction, current: str) -&gt; list[app_commands.Choice[str]]:\n    options = [\"Red\", \"Green\", \"Blue\"]\n    return [app_commands.Choice(name=option, value=option) for option in options if option.lower().startswith(current.lower())][:25]\n</code></pre> <p></p> <p>Warning</p> <p>Since <code>autocomplete</code> is a slash command specific annotation, while using the command as a regular prefix command, the autocomplete options will not be available and no checks will be performed on the parameter internally i.e you can pass any value to the parameter.</p> <p>You can have maximum of 25 autocomplete options for a parameter.</p>"},{"location":"hybrid-commands/#groups-and-subcommands","title":"Groups and Subcommands","text":"<p>You can also create groups and subcommands using the <code>hybrid_group</code> decorator. Groups cannot have depth greater than 1 i.e you cannot have a group inside a group.</p> <pre><code>@bot.hybrid_group()\nasync def test(ctx: commands.Context) -&gt; None:\n    \"\"\"Test group\"\"\"\n    await ctx.send(\"Invoked test group\")\n\n@test.command(name=\"test\")\nasync def test_1(ctx: commands.Context) -&gt; None:\n    \"\"\"Test command\"\"\"\n    await ctx.send(\"Test command\")\n\n@test.command(name=\"echo\")\nasync def test_2(ctx: commands.Context, message: str) -&gt; None:\n    \"\"\"Echo command\"\"\"\n    await ctx.send(message)\n</code></pre> <p></p> <p>Note</p> <p>Due to a limitation in discord, the parent/group command itself will not be listed and will not be able to be invoked. However, you can still use the parent/group command as a regular prefix command.</p> <p>One way to get around this is to use the <code>fallback</code> parameter of the <code>hybrid_group</code> decorator. This will create a subcommand under parent group that can be used to invoke the parent/group command.</p> <pre><code>@bot.hybrid_group(fallback=\"get\") # creates a subcommand named \"get\" under the parent/group command\nasync def test(ctx: commands.Context) -&gt; None:\n    \"\"\"Test group\"\"\"\n    await ctx.send(\"Invoked test group\")\n</code></pre> <p></p>"},{"location":"hybrid-commands/#hybrid-commands-in-cogs","title":"Hybrid Commands in Cogs","text":"<p>Here is an example of how you can use hybrid commands in cogs.</p> <pre><code>from discord.ext import commands\n\n\nclass General(commands.Cog):\n    def __init__(self, bot: commands.Bot) -&gt; None:\n        self.bot = bot\n\n    @commands.hybrid_command(name=\"ping\")\n    async def ping(self, ctx: commands.Context[commands.Bot]) -&gt; None:\n        \"\"\"Pong!\"\"\"\n        await ctx.send(\"Pong!\")\n\n    @commands.hybrid_group(name=\"math\")\n    async def math(self, ctx: commands.Context[commands.Bot]) -&gt; None:\n        \"\"\"Math commands\"\"\"\n        pass\n\n    @math.command(name=\"add\")\n    async def add(self, ctx: commands.Context[commands.Bot], a: int, b: int) -&gt; None:\n        \"\"\"\n        Add two numbers\n\n        Parameters\n        ----------\n        a: int\n            The first number\n        b: int\n            The second number\n        \"\"\"\n        await ctx.send(f\"{a} + {b} = {a + b}\")\n\n    @math.command(name=\"subtract\")\n    async def subtract(self, ctx: commands.Context[commands.Bot], a: int, b: int) -&gt; None:\n        \"\"\"\n        Subtract two numbers\n\n        Parameters\n        ----------\n        a: int\n            The first number\n        b: int\n            The second number\n        \"\"\"\n        await ctx.send(f\"{a} - {b} = {a - b}\")\n\n\nasync def setup(bot: commands.Bot) -&gt; None:\n    await bot.add_cog(General(bot))\n</code></pre>"},{"location":"hybrid-commands/#error-handling-and-checks","title":"Error Handling and Checks","text":"<p>Checks and error handlers can be used with hybrid commands just like regular prefix commands you can check out the checks and error handling pages for more information.</p>"},{"location":"hybrid-commands/#permissions","title":"Permissions","text":""},{"location":"hybrid-commands/#app_commandsdefault_permissions","title":"<code>app_commands.default_permissions</code>","text":"<p>You can set the default permissions for a hybrid command using the <code>app_commands.default_permissions</code> decorator. This will set the default permissions for the slash command.</p> <p>Leaving the <code>permissions</code> parameter empty will disable the command for everyone except server administrators.</p> <pre><code>@bot.hybrid_command()\n@app_commands.default_permissions(permissions=discord.Permissions(manage_messages=True))\nasync def echo(ctx: commands.Context, message: str):\n    \"\"\"\n    Echoes a message\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    message: str\n        The message to echo\n    \"\"\"\n    await ctx.send(message)\n</code></pre>"},{"location":"hybrid-commands/#app_commandsguilds","title":"<code>app_commands.guilds</code>","text":"<p>You can also specify the guilds where the command should be enabled using the <code>app_commands.guilds</code> decorator. This will set the guilds where the slash command should be enabled.</p> <pre><code>@bot.hybrid_command()\n@app_commands.guilds(discord.Object(id=1234567890), ...)\nasync def echo(ctx: commands.Context, message: str):\n    \"\"\"\n    Echoes a message\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    message: str\n        The message to echo\n    \"\"\"\n    await ctx.send(message)\n</code></pre>"},{"location":"hybrid-commands/#app_commandsguild_only","title":"<code>app_commands.guild_only</code>","text":"<p>You can also specify that the command should only be enabled in guilds using the <code>app_commands.guild_only</code> decorator. This will set the command to only be enabled in guilds and will not be available in DMs.</p> <pre><code>@bot.hybrid_command()\n@app_commands.guild_only()\nasync def echo(ctx: commands.Context, message: str):\n    \"\"\"\n    Echoes a message\n\n    Parameters\n    ----------\n    ctx: commands.Context\n        The context of the command invocation\n    message: str\n        The message to echo\n    \"\"\"\n    await ctx.send(message)\n</code></pre>"},{"location":"hybrid-commands/#timeouts","title":"Timeouts","text":"<p>Slash commands have a timeout of 3 seconds by default. This means that if the command takes more than 3 seconds to execute, it will fail, this is an API limitation.</p> <p>A workaround for this is to use the <code>defer</code> method to defer the response. This will give you 15 minutes to send the response.</p> <pre><code>import asyncio\n\n@bot.hybrid_command()\nasync def ping(ctx: commands.Context):\n    \"\"\"\n    Pong!\n    \"\"\"\n    await ctx.defer()\n    await asyncio.sleep(5)\n    await ctx.send(f\"Pong! {bot.latency * 1000} ms\")\n</code></pre> <p>Warning</p> <p>You can only use <code>defer</code> once per command invocation. Regular prefix commands do not have timeout limitations.</p> <p>Note</p> <p>For regular prefix commands <code>defer</code> activates the typing status for the bot, for slash commands it shows the user that the bot is thinking as a loading state.</p>"},{"location":"hybrid-commands/#ephemeral-messages","title":"Ephemeral Messages","text":"<p>You can also send ephemeral messages, messages which are only visible to the person invoking the command using the <code>ephemeral</code> parameter of the <code>send</code> method.</p> Before DeferringAfter Deferring <pre><code>@bot.hybrid_command()\nasync def ping(ctx: commands.Context):\n    \"\"\"\n    Pong!\n    \"\"\"\n    await ctx.send(f\"Pong! {bot.latency * 1000} ms\", ephemeral=True)\n</code></pre> <pre><code>@bot.hybrid_command()\nasync def ping(ctx: commands.Context):\n    \"\"\"\n    Pong!\n    \"\"\"\n    await ctx.defer(ephemeral=True)\n    await ctx.send(f\"Pong! {bot.latency * 1000} ms\")\n</code></pre> <p></p>"},{"location":"hybrid-commands/#syncing-commands","title":"Syncing Commands","text":"<p>It is necessary to sync commands with discord before you can use them. This is required as the metadata for slash commands needs to be sent to discord. Since <code>discord.py</code> does not automatically sync commands, you will have to do it manually.</p> <p>You can sync commands in multiple places such as the <code>on_ready</code> event, or in the <code>setup_hook</code>, but while it's convenient to sync here it is not the best way to do it.</p> <p>The pitfalls here for example if you sync your tree before loading your cogs, the commands in your cogs will not be synced. If you sync your tree and then make changes to your commands, the changes will not be reflected in discord without syncing again.</p> <p>So one of the best ways to sync your commands is to use a message command, even if you are making a slash command bot and don't have message content scope enabled, you can still use a message command to sync your commands as bots receive messages on <code>mention</code> and in <code>DMs</code>.</p> <pre><code>@bot.command()\n@commands.is_owner()\nasync def sync(ctx: commands.Context) -&gt; None:\n    \"\"\"Sync commands\"\"\"\n    synced = await ctx.bot.tree.sync()\n    await ctx.send(f\"Synced {len(synced)} commands globally\")\n</code></pre> <p>Note</p> <p>You can pass a <code>Snowflake</code> or a <code>Guild</code> object to the <code>sync</code> method to sync commands for a specific guild.</p> <pre><code>guild = discord.Object(id=1234567890)\nsynced = await ctx.bot.tree.sync(guild=guild)\n</code></pre> <p>You can also pass a <code>list</code> of <code>Snowflake</code> or <code>Guild</code> objects to the <code>sync</code> method to sync commands for multiple guilds.</p> <pre><code>guilds = [discord.Object(id=1234567890), ...]\nsynced = await ctx.bot.tree.sync(guild=guilds)\n</code></pre> <p>Warning</p> <p>It is always better to test your commands in a test server before syncing them globally. This allows you to test your commands without having to worry about breaking your commands for other users.</p> <pre><code>guild = discord.Object(id=1234567890)\nctx.bot.tree.copy_global_to(guild=guild)\nsynced = await ctx.bot.tree.sync(guild=guild)\n</code></pre>"},{"location":"hybrid-commands/#when-to-sync","title":"When to Sync","text":"<ul> <li>When you add a new command.</li> <li>When you remove a command.</li> <li>When a command's name or description changes.</li> <li>When the callback's parameters change.<ul> <li>This includes parameter names, types or descriptions.</li> </ul> </li> <li>If you change a global to a guild command, or vice versa.<ul> <li>NOTE: If you do this, you will need to sync both global and to that guild to reflect the change.</li> </ul> </li> </ul>"},{"location":"hybrid-commands/#conclusion","title":"Conclusion","text":"<p>Hybrid commands are a great way to make your bot more user friendly and easy to use. They allow you to use the same code for both slash commands and regular prefix commands making it easier to maintain your codebase.</p>"},{"location":"markdown-and-ansi/","title":"ANSI and Markdown","text":""},{"location":"markdown-and-ansi/#ansi","title":"ANSI","text":"<p>ANSI stands for American National Standards Institute. It is a set of standards for character and terminal handling. It is used by many programs, including the Linux kernel itself, to produce colored terminal output. The most basic ANSI escape codes are those involved in rendering text. These let you add decorations like Colors, Background Colors or other Decorations to your printed text, but don't do anything fancy.</p> <p></p> <p>Most ANSI escape codes start with <code>\\u001b[</code> and end with <code>m</code>. The codes in between are the actual codes. For example, <code>\\u001b[31m</code> is the code for red text. You can find a list of all the codes here. All the codes are separated by a <code>;</code>. For example, <code>\\u001b[31;1m</code> is the code for bold red text. You can also combine multiple codes. For example, <code>\\u001b[31;1;4m</code> is the code for bold red underlined text.</p> Ansi Format<pre><code>\\u001b[{code}m{text}\\u001b[0m\n</code></pre> <p>Note</p> <p>The <code>\\u001b[0m</code> at the end is the code for resetting the text. If you don't add it, the text will stay in the same format.</p> <p>Warning</p> <p>So far discord supports only 8 colors each for foreground and background and 3 possible formats (bold, italic, underline).</p>"},{"location":"markdown-and-ansi/#building-an-ansi-generator","title":"Building an ANSI Generator","text":"<pre><code>import enum\n\n\nclass Style(enum.IntEnum):\n    def __str__(self) -&gt; str:\n        return f\"{self.value}\"\n</code></pre>"},{"location":"markdown-and-ansi/#foreground-colors","title":"Foreground Colors","text":"Color Code Gray <code>\\u001b[30m</code> Red <code>\\u001b[31m</code> Green <code>\\u001b[32m</code> Yellow <code>\\u001b[33m</code> Blue <code>\\u001b[34m</code> Magenta <code>\\u001b[35m</code> Cyan <code>\\u001b[36m</code> White <code>\\u001b[37m</code> <pre><code>class Colors(Style):\n    GRAY = 30\n    RED = 31\n    GREEN = 32\n    YELLOW = 33\n    BLUE = 34\n    MAGENTA = 35\n    CYAN = 36\n    WHITE = 37\n</code></pre>"},{"location":"markdown-and-ansi/#background-colors","title":"Background Colors","text":"Color Code Firefly Dark Blue <code>\\u001b[40m</code> Orange <code>\\u001b[41m</code> Marble Blue <code>\\u001b[42m</code> Greyish Turquoise <code>\\u001b[43m</code> Gray <code>\\u001b[44m</code> Indigo <code>\\u001b[45m</code> Light Gray <code>\\u001b[46m</code> White <code>\\u001b[47m</code> <pre><code>class Backgrounds(Style):\n    GRAY = 40\n    RED = 41\n    GREEN = 42\n    YELLOW = 43\n    BLUE = 44\n    MAGENTA = 45\n    CYAN = 46\n    WHITE = 47\n</code></pre>"},{"location":"markdown-and-ansi/#text-formats","title":"Text Formats","text":"Format Code Normal <code>\\u001b[0m</code> Bold <code>\\u001b[1m</code> Underline <code>\\u001b[4m</code> <pre><code>class Formats(Style):\n    NORMAL = 0\n    BOLD = 1\n    UNDERLINE = 4\n</code></pre>"},{"location":"markdown-and-ansi/#putting-it-all-together","title":"Putting it all together","text":"<pre><code>import enum\n\n\nclass Style(enum.IntEnum):\n    def __str__(self) -&gt; str:\n        return f\"{self.value}\"\n\n\nclass Colors(Style):\n    GRAY = 30\n    RED = 31\n    GREEN = 32\n    YELLOW = 33\n    BLUE = 34\n    MAGENTA = 35\n    CYAN = 36\n    WHITE = 37\n\n\nclass BackgroundColors(Style):\n    FIREFLY_DARK_BLUE = 40\n    ORANGE = 41\n    MARBLE_BLUE = 42\n    GREYISH_TURQUOISE = 43\n    GRAY = 44\n    INDIGO = 45\n    LIGHT_GRAY = 46\n    WHITE = 47\n\n\nclass Styles(Style):\n    NORMAL = 0\n    BOLD = 1\n    UNDERLINE = 4\n\n\nclass AnsiBuilder:\n    def __init__(self, text: str = \"\", *styles: Style) -&gt; None:\n        self.styles = styles\n        self.cursor = len(text)\n        self.text = f\"\\033[{';'.join(map(str, styles))}m{text}\\033[0m\" if styles and text else text\n\n    def __add__(self, other: str) -&gt; \"AnsiBuilder\":\n        self.text += other\n        self.cursor += len(other)\n        return self\n\n    def write(self, cursor: int, text: str) -&gt; \"AnsiBuilder\":\n        if cursor &gt; self.cursor or cursor &gt; len(self.text):\n            raise ValueError(\"Cursor cannot be greater than the length of the text\")\n        if cursor &lt; 0:\n            raise ValueError(\"Cursor cannot be less than 0\")\n        self.text = self.text[:cursor] + text + self.text[cursor:]\n        self.cursor += len(text)\n        return self\n\n    def __str__(self) -&gt; str:\n        return self.text\n\n    @classmethod\n    def to_ansi(cls, text: str, *styles: Style) -&gt; str:\n        return str(cls(text, *styles))\n\n    @property\n    def block(self) -&gt; str:\n        return f\"```ansi\\n{self.text}```\"\n</code></pre>"},{"location":"markdown-and-ansi/#implementation-in-a-bot","title":"Implementation in a Bot","text":"<pre><code>import os\n\nimport discord\nfrom discord.ext import commands\nfrom dotenv import load_dotenv\n\nbot = commands.Bot(command_prefix=\"!\", intents=discord.Intents.all())\nload_dotenv()\n\n\n@bot.command()\nasync def foreground(ctx: commands.Context[commands.Bot]) -&gt; None:\n    fg = AnsiBuilder(\"Foreground Colors\\n\", Styles.BOLD)\n    for color in Colors:\n        fg += AnsiBuilder.to_ansi(f\"{color.name}\\n\", color)\n    await ctx.send(fg.block)\n\n\n@bot.command()\nasync def background(ctx: commands.Context[commands.Bot]) -&gt; None:\n    bg = AnsiBuilder(\"Background Colors\\n\", Styles.BOLD)\n    for color in BackgroundColors:\n        bg += AnsiBuilder.to_ansi(f\"{color.name}\\n\", color)\n    await ctx.send(bg.block)\n\n\n@bot.command()\nasync def style(ctx: commands.Context[commands.Bot]) -&gt; None:\n    _style = AnsiBuilder(\"Styles\\n\", Styles.BOLD)\n    for s in Styles:\n        _style += AnsiBuilder.to_ansi(f\"{s.name}\\n\", s)\n    await ctx.send(_style.block)\n\n\n@bot.command()\nasync def combo(ctx: commands.Context[commands.Bot]) -&gt; None:\n    # combination of all foreground colors on all background colors\n    for bg in BackgroundColors:\n        combined = AnsiBuilder()\n        for fg in Colors:\n            combined += f\"{AnsiBuilder.to_ansi('Sample', fg, bg)} \"\n        await ctx.send(combined.block)\n\n\n@bot.command()\nasync def style_combo(ctx: commands.Context[commands.Bot], style_: str) -&gt; None:\n    if style_ not in Styles.__members__:\n        await ctx.send(\"Invalid style\")\n        return\n    _style = Styles[style_]\n    combined = AnsiBuilder()\n    for fg in Colors:\n        combined += f\"{AnsiBuilder.to_ansi('Sample', fg, _style)} \"\n    await ctx.send(combined.block)\n\n\nbot.run(str(os.getenv(\"TOKEN\")))\n</code></pre> <p>Note</p> <p>So far, ANSI highlighting is available on all stable desktop and web clients, but not on mobile clients.</p>"},{"location":"markdown-and-ansi/#markdown","title":"Markdown","text":""},{"location":"markdown-and-ansi/#text-formatting","title":"Text Formatting","text":"Format Code Bold <code>**bold**</code> like this bold Italic <code>*italic*</code> like this italic Underline <code>__underline__</code> like this underline Strikethrough <code>~~strikethrough~~</code> like this strikethrough <p>Tip</p> <p>You can combine formats like <code>***bold italic***</code> like this bold italic, <code>__**underline bold**__</code> like this underline bold etc.</p>"},{"location":"markdown-and-ansi/#headers","title":"Headers","text":"Format Code H1 <code># Header 1</code> H2 <code>## Header 2</code> H3 <code>### Header 3</code>"},{"location":"markdown-and-ansi/#links","title":"Links","text":"Format Code Link <code>[text](url)</code> <p><pre><code>[Here](https://google.com)\n</code></pre> </p>"},{"location":"markdown-and-ansi/#spoilers","title":"Spoilers","text":"Format Code Spoiler <code>||spoiler||</code> <pre><code>||spoiler||\n</code></pre>"},{"location":"markdown-and-ansi/#lists","title":"Lists","text":""},{"location":"markdown-and-ansi/#unordered-lists","title":"Unordered Lists","text":"<pre><code>- Item 1\n- Item 2\n  - Item 2.1\n- Item 3\n</code></pre> <p>Tip</p> <p>You can use <code>*</code> instead of <code>-</code> to create unordered lists.</p> <p></p>"},{"location":"markdown-and-ansi/#ordered-lists","title":"Ordered Lists","text":"<pre><code>1. Item 1\n3. Item 2\n   1. Item 2.1\n2. Item 3\n</code></pre> <p>Tip</p> <p>The numbers don't have to be in numerical order, they will be automatically sorted.</p>"},{"location":"markdown-and-ansi/#blockquotes","title":"Blockquotes","text":"<pre><code>&gt; This is a single line blockquote\n&gt; This is another line\n</code></pre> <pre><code>&gt;&gt;&gt; This is a multiline blockquote\nthis continues\n</code></pre>"},{"location":"markdown-and-ansi/#code-blocks","title":"Code Blocks","text":""},{"location":"markdown-and-ansi/#inline-code","title":"Inline Code","text":"<pre><code>This is `inline code`\n</code></pre>"},{"location":"markdown-and-ansi/#code-blocks_1","title":"Code Blocks","text":"<p>Warning</p> <p>Use backticks <code>`</code> and not single quotes <code>'</code> to create code blocks.</p>"},{"location":"markdown-and-ansi/#syntax-highlighting","title":"Syntax Highlighting","text":"<p>To have syntax highlighting in code blocks, you can specify the language after the first set of backticks. For example, to have syntax highlighting for Python, you can use <code>```py</code>.</p> SQLHTMLRustDiff <p><pre><code>SELECT * FROM table\n</code></pre> </p> <p><pre><code>&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;Test&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Test&lt;/h1&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> </p> <p><pre><code>fn main() {\n    println!(\"Hello, world!\");\n}\n</code></pre> </p> <p><pre><code>- this is a removed line\n+ this is an added line\n</code></pre> </p> <p>Tip</p> <p>Above were just a few examples, You can find a list of supported languages here.</p>"},{"location":"markdown-and-ansi/#mentions","title":"Mentions","text":"<p>Discord supports mentioning users, roles, and channels in messages and a few other special mentions such as <code>@everyone</code> and <code>@here</code>.</p> Mention Type Code Remarks User <code>&lt;@user_id&gt;</code> or <code>&lt;@!user_id&gt;</code> Replace <code>user_id</code> with the user's id, this will ping the user. If the user is not found it will display <code>@unknown-user</code>. Role <code>&lt;@&amp;role_id&gt;</code> Replace <code>role_id</code> with the role's id, this will ping all the users with the role. If the role is not found it will display <code>@unknown-role</code>. Channel <code>&lt;#channel_id&gt;</code> Replace <code>channel_id</code> with the channel's id, this will display the channel's name as a hyperlink making it easier to navigate to the channel. If the channel is not found it will display <code>#unknown</code>. Everyone <code>@everyone</code> Pings everyone in the server. Here <code>@here</code> Pings everyone in the server who is online."},{"location":"markdown-and-ansi/#timestamps","title":"Timestamps","text":"<p>You can use timestamps in messages and embeds to display the time in a user's local timezone, in a relative format, or in a specific format.</p> Style Format Example Input Example Output Description t <code>&lt;t:timestamp:t&gt;</code> <code>&lt;t:1633660800:t&gt;</code> <code>8:10 AM</code> Short time format (HH:MM AM/PM) in the user's local timezone. T <code>&lt;t:timestamp:T&gt;</code> <code>&lt;t:1633660800:T&gt;</code> <code>8:10:00 AM</code> Long time format (HH:MM:SS AM/PM) in the user's local timezone. d <code>&lt;t:timestamp:d&gt;</code> <code>&lt;t:1633660800:d&gt;</code> <code>10/8/2021</code> Short date format (MM/DD/YYYY) in the user's local timezone. D <code>&lt;t:timestamp:D&gt;</code> <code>&lt;t:1633660800:D&gt;</code> <code>October 8, 2021</code> Long date format (Month DD, YYYY) in the user's local timezone. f (default) <code>&lt;t:timestamp:f&gt;</code> <code>&lt;t:1633660800:f&gt;</code> <code>October 8, 2021 8:10 AM</code> Short date and time format in the user's local timezone. F <code>&lt;t:timestamp:F&gt;</code> <code>&lt;t:1633660800:F&gt;</code> <code>Friday, October 8, 2021 8:10 AM</code> Long date and time format in the user's local timezone. R <code>&lt;t:timestamp:R&gt;</code> <code>&lt;t:1633660800:R&gt;</code> <code>3 years ago</code> Relative time format. <pre><code>In [1]: import discord\n   ...: import datetime\n   ...:\n   ...: timestamp = datetime.datetime(2021, 10, 8, 8, 10)\n   ...: print(discord.utils.format_dt(timestamp, \"f\"))\n&lt;t:1633660800:f&gt;\n\nIn [2]: print(discord.utils.format_dt(timestamp, \"t\"))\n&lt;t:1633660800:t&gt;\n</code></pre>"},{"location":"markdown-and-ansi/#conclusion","title":"Conclusion","text":"<p>In this tutorial, we learned how to use markdown and ANSI highlighting in discord.py. We also learned how to use the <code>AnsiBuilder</code> class to create custom ANSI blocks. Discord allows you to use markdown and ANSI highlighting in embeds and messages. You can leverage this to make your bot's messages more readable and attractive.</p>"},{"location":"pagination/","title":"Pagination","text":"<p>Pagination is a way to split a large list of items into multiple pages or subsets. This is useful when you have a large number of items to display, and you don't want to overwhelm the user with a long list or when your message surpasses the discord limits for messages.</p> <p>In discord bots, pagination is often used to display a list of items in a more user-friendly way. Instead of displaying all items at once, you can split the information into multiple pages/embeds, and allow the user to navigate between them.</p> <p>There are primarily two ways to implement pagination in discord bots:</p> Reaction-based pagination View-based pagination In this method, you display a list of items in an embed, and allow the user to navigate between pages by reacting to the embed with emojis. In this method, you display a list of items in an embed, and allow the user to navigate between pages by clicking buttons or selecting options. Reactions can only include a single emoji, limited interactivity and usually used for simplistic logic handling. Views can include multiple buttons, dropdowns, and other interactive elements, allowing for more complex logic handling. Utilizes <code>reaction_add</code> and <code>reaction_remove</code> events to handle user interactivity. Utilizes custom interaction objects sent to your application to handle user interactivity. Easier to implement but becomes cluttered with more complex logic or handling. Simple to implement using <code>discord.ui</code> components, but requires more setup and understanding of interactions. <p>In this guide, we'll be focusing on view-based pagination, as it provides more flexibility and control over the user experience.</p> <p>Prerequisites</p> <p>Before you continue, make sure you have a basic understanding of views because we'll be using views to implement pagination in this guide.</p>"},{"location":"pagination/#parts-of-pagination","title":"Parts of Pagination","text":"<p>When implementing pagination in discord bots, there are a few key components that you need to consider:</p> <ol> <li>Data: The list of items that you want to paginate. This could be a list of simple strings, embeds, or attachments.</li> <li>Pagination Logic: The logic that handles how the data is split into pages and how the user can navigate between them.</li> <li>User Interface: The visual representation of the data and the controls that allow the user to interact with the pagination.</li> <li>Interaction Handling: The code that listens for user interactions and updates the pagination accordingly.</li> </ol> <p>By understanding these components and how they interact with each other, you can create a smooth and intuitive pagination system for your discord bot.</p>"},{"location":"pagination/#a-basic-pagination","title":"A Basic Pagination","text":"paginators/__init__.py<pre><code>\"\"\"Base class for paginators.\"\"\"\n\nfrom __future__ import annotations\n\nfrom io import BufferedIOBase\nfrom os import PathLike\nfrom typing import TYPE_CHECKING, Any, Generic, List, TypeVar, Union\n\nimport discord\nfrom views import BaseView\n\nif TYPE_CHECKING:\n    from typing_extensions import TypeAlias\n\nPageLike: TypeAlias = Union[discord.Embed, str, bytes, PathLike[Any], BufferedIOBase, discord.File]\nFileLike: TypeAlias = Union[str, bytes, PathLike[Any], BufferedIOBase]\n\nT = TypeVar(\"T\", bound=PageLike)\n\n\nclass BasePaginator(Generic[T], BaseView):\n    pages: List[T]\n    current_page: int\n\n    def __init__(\n        self,\n        user: Union[discord.User, discord.Member],\n        pages: List[T],\n        *,\n        attachments: List[discord.File] = None\n    ) -&gt; None:\n        super().__init__(user=user, timeout=180)\n        self.pages = pages\n        self.current_page: int = 0\n        self.attachments = attachments or []\n\n    async def send_page(self, inter: discord.Interaction, page: T) -&gt; None:\n        if isinstance(page, discord.Embed):  # Embed\n            # Check if the embed has an associated attachment and send it along with the embed\n            attachment = None\n            if (page.image.url or \"\").startswith(\"attachment://\") and len(self.attachments) &gt; self.current_page:\n                attachment = discord.File(self.attachments[self.current_page].fp.name)\n            attachments = [attachment] if attachment else []\n            if self.message is None:\n                return await inter.response.send_message(embed=page, view=self, files=attachments)\n            self.message = await inter.edit_original_response(embed=page, view=self, attachments=attachments)\n            return\n\n        if isinstance(page, str):  # String\n            # Check if the string has an associated attachment and send it along with the string\n            attachment = None\n            if len(self.attachments) &gt; self.current_page:\n                attachment = discord.File(self.attachments[self.current_page].fp.name)\n            attachments = [attachment] if attachment else []\n            if self.message is None:\n                return await inter.response.send_message(content=page, view=self, files=attachments)\n            self.message = await inter.edit_original_response(content=page, view=self, attachments=attachments)\n            return\n\n        # File\n        file = discord.File(page) if not isinstance(page, discord.File) else discord.File(page.fp.name)\n        if self.message is None:\n            return await inter.response.send_message(file=file, view=self)\n        self.message = await inter.edit_original_response(attachments=[file], view=self)\n\n    async def start_paginator(self, inter: discord.Interaction, *, starting_page: int = 0) -&gt; None:\n        self.current_page = starting_page\n        page = self.pages[starting_page]\n        await self.send_page(inter, page)\n        self.message = await inter.original_response()\n\n    async def stop_paginator(self) -&gt; None:\n        self._disable_all()\n        await self._edit(view=self)\n\n    async def next_page(self, inter: discord.Interaction) -&gt; None:\n        self.current_page = (self.current_page + 1) % len(self.pages)\n        page = self.pages[self.current_page]\n        await self.send_page(inter, page)\n\n    async def previous_page(self, inter: discord.Interaction) -&gt; None:\n        self.current_page = (self.current_page - 1) % len(self.pages)\n        page = self.pages[self.current_page]\n        await self.send_page(inter, page)\n</code></pre> <p>So, let's break down the code above:</p> <ul> <li>We define a <code>BasePaginator</code> class that extends <code>BaseView</code> which is just a simple wrapper around <code>discord.ui.View</code> which we defined here.</li> <li>The <code>BasePaginator</code> class takes a list of pages and an optional list of attachments as input. A page can be an embed, a string, or a file-like object, an additional list of attachments can be provided to be used with the embeds in case they are local files.</li> <li>The <code>send_page</code> method sends the current page to the user. If the page is an embed with an attachment, it sends the attachment along with the embed. If the page is a string or a file, it sends the content or file to the user.</li> <li>The <code>start_paginator</code> method initializes the paginator by sending the first page to the user and storing the message object for future edits and cleanup.</li> <li>The <code>stop_paginator</code> method disables all interactions and disables the view.</li> <li>The <code>next_page</code> and <code>previous_page</code> methods handle moving to the next and previous pages respectively. They update the current page index and send the new page to the user. The modulo operator is used to loop around the pages when reaching the end or beginning of the list.</li> </ul> <p>The class we implemented satisfies requirements <code>2 - Pagination Logic</code> and <code>4 - Interaction Handling</code> from the list above. Now let's look at how we can implement the <code>User Interface</code> part of the pagination based on the <code>Data</code> we possess.</p>"},{"location":"pagination/#pagination-interfaces","title":"Pagination Interfaces","text":"<p>Lets take a look at typical bulk data we could paginate:</p>"},{"location":"pagination/#button-based-pagination","title":"Button Based Pagination","text":"<p>The simplest form of a collection is a list or an array. This can be a list of strings, a list of embeds, or a list of file-like objects.</p> <pre><code>strings = [\"Page 1\", \"Page 2\", \"Page 3\"]\nembeds = [discord.Embed(title=f\"Page {i}\", description=f\"This is page {i}\") for i in range(1, 4)]\nfiles = [discord.File(f\"page_{i}.txt\") for i in range(1, 4)]\n</code></pre> StringsEmbedsFilesEmbeds with Attachments <p></p> <p></p> <p></p> <p></p> paginators/button_paginator.py<pre><code>from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Generic, List, TypeVar, Union\n\nimport discord\nfrom discord import PartialEmoji\nfrom paginators import BasePaginator, FileLike, PageLike\n\nif TYPE_CHECKING:\n    from views import BaseView\n\n\nT = TypeVar(\"T\", bound=PageLike)\n\n\nclass ButtonBasedPaginator(Generic[T], BasePaginator[T]):\n    @discord.ui.button(emoji=PartialEmoji.from_str(\"\u23ea\"))\n    async def goto_first_page_callback(self, inter: discord.Interaction, _: discord.ui.Button[BaseView]) -&gt; None:\n        await inter.response.defer()\n        self.current_page = 0\n        page = self.pages[self.current_page]\n        await self.send_page(inter, page)\n\n    @discord.ui.button(emoji=PartialEmoji.from_str(\"\u25c0\ufe0f\"))\n    async def previous_page_callback(self, inter: discord.Interaction, _: discord.ui.Button[BaseView]) -&gt; None:\n        await inter.response.defer()\n        await self.previous_page(inter)\n\n    @discord.ui.button(emoji=PartialEmoji.from_str(\"\u25b6\ufe0f\"))\n    async def next_page_callback(self, inter: discord.Interaction, _: discord.ui.Button[BaseView]) -&gt; None:\n        await inter.response.defer()\n        await self.next_page(inter)\n\n    @discord.ui.button(emoji=PartialEmoji.from_str(\"\u23e9\"))\n    async def goto_last_page_callback(self, inter: discord.Interaction, _: discord.ui.Button[BaseView]) -&gt; None:\n        await inter.response.defer()\n        self.current_page = len(self.pages) - 1\n        page = self.pages[self.current_page]\n        await self.send_page(inter, page)\n\n    @discord.ui.button(emoji=PartialEmoji.from_str(\"\ud83d\uddd1\ufe0f\"))\n    async def stop_paginator_callback(self, inter: discord.Interaction, _: discord.ui.Button[BaseView]) -&gt; None:\n        await inter.response.defer()\n        await self.stop_paginator()\n</code></pre> <ul> <li>We define a <code>ButtonBasedPaginator</code> class that extends <code>BasePaginator</code> and adds buttons for navigating between pages.</li> <li>The <code>ButtonBasedPaginator</code> class defines button callbacks for going to the first, previous, next, and last pages, as well as stopping the paginator.</li> <li>You may notice the usage of <code>Generic</code> type hints in the class definition and method signatures. This allows us to specify the type of pages that the paginator will handle, which can be a string, an embed, or a file-like object.</li> </ul> <p>Here is how you can use the <code>ButtonBasedPaginator</code> class:</p> StringsEmbedsFiles <pre><code>import discord\nfrom discord.ext import commands\nfrom paginators.button_paginator import ButtonBasedPaginator\n\nclass StringButtonPaginator(ButtonBasedPaginator[str]):\n    def __init__(\n        self,\n        user: Union[discord.User, discord.Member],\n        pages: List[str],\n        *,\n        attachments: List[discord.File] = None,\n    ) -&gt; None:\n        super().__init__(user, pages, attachments=attachments)\n\n# Assuming a bot command\n@bot.tree.command()\nasync def paginate(inter: discord.Interaction):\n    pages = [\"Page 1\", \"Page 2\", \"Page 3\"]\n    paginator = StringButtonPaginator(inter.user, pages=pages)\n    await paginator.start_paginator(inter)\n\n@bot.tree.command()\nasync def paginate_with_attachments(inter: discord.Interaction):\n    pages = [\"Page 1\", \"Page 2\", \"Page 3\"]\n    attachments = [discord.File(f\"assets/{i}.png\") for i in range(1, 4)]\n    paginator = StringButtonPaginator(inter.user, pages=pages, attachments=attachments)\n    await paginator.start_paginator(inter)\n</code></pre> <pre><code>import discord\nfrom discord.ext import commands\nfrom paginators.button_paginator import ButtonBasedPaginator\n\nclass EmbedButtonPaginator(ButtonBasedPaginator[discord.Embed]):\n    def __init__(\n        self,\n        user: Union[discord.User, discord.Member],\n        pages: List[discord.Embed],\n        *,\n        attachments: List[discord.File] = None,\n    ) -&gt; None:\n        super().__init__(user, pages, attachments=attachments)\n\n# Assuming a bot command\n@bot.tree.command()\nasync def paginate(inter: discord.Interaction):\n    pages = [discord.Embed(title=f\"Page {i}\", description=f\"This is page {i}\") for i in range(1, 4)]\n    paginator = EmbedButtonPaginator(inter.user, pages=pages)\n    await paginator.start_paginator(inter)\n\n@bot.tree.command()\nasync def paginate_with_attachments(inter: discord.Interaction):\n    pages = [discord.Embed(title=f\"Page {i}\", description=f\"This is page {i}\") for i in range(1, 4)]\n    attachments = [discord.File(f\"assets/{i}.png\") for i in range(1, 4)]\n    paginator = EmbedButtonPaginator(inter.user, pages=pages, attachments=attachments)\n    await paginator.start_paginator(inter)\n</code></pre> <pre><code>import discord\nfrom discord.ext import commands\nfrom paginators.button_paginator import ButtonBasedPaginator\n\nclass FileButtonPaginator(ButtonBasedPaginator[FileLike]):\n    def __init__(self, user: Union[discord.User, discord.Member], pages: List[FileLike]) -&gt; None:\n        super().__init__(user, pages)\n\n# Assuming a bot command\n@bot.tree.command()\nasync def paginate(inter: discord.Interaction):\n    pages = [discord.File(f\"assets/{i}.png\") for i in range(1, 4)]\n    paginator = FileButtonPaginator(inter.user, pages=pages)\n    await paginator.start_paginator(inter)\n</code></pre> <p>Note</p> <p>Notice that the <code>ButtonBasedPaginator</code> class is generic and can handle different types of pages, such as strings, embeds, or files. This allows you to reuse the same pagination logic for different types of data.</p>"},{"location":"pagination/#select-based-pagination","title":"Select Based Pagination","text":"<p>A more complex form of data could be a dictionary or a mapping of keys to values. This can be useful when you want to display more structured or categorized data.</p> <pre><code>data = {\n    \"Name\": \"John Doe\",\n    \"Age\": 30,\n    \"Location\": \"New York\"\n}\n</code></pre> StringsEmbedsFilesEmbeds with Attachments <p></p> <p></p> <p></p> <p></p> paginators/select_paginator.py<pre><code>from __future__ import annotations\n\nfrom typing import Generic, List, Optional, TypeVar, Union\n\nimport discord\nfrom paginators import BasePaginator, FileLike, PageLike\n\nT = TypeVar(\"T\", bound=PageLike)\n\n\nclass PageEntry(Generic[T]):\n    def __init__(\n        self,\n        value: T,\n        *,\n        page_title: str,\n        page_description: Optional[str] = None,\n        attachment: discord.File = None,\n    ) -&gt; None:\n        self.page_title = page_title\n        self.page_description = page_description\n        self.value = value\n        self.attachment = attachment\n\n\nclass SelectMenuBasedPaginator(Generic[T], BasePaginator[T]):\n    def __init__(\n        self,\n        user: Union[discord.User, discord.Member],\n        *,\n        pages: List[PageEntry[T]],\n    ) -&gt; None:\n        self.select = PaginatorSelect(view=self)\n        pages_: List[T] = []\n        attachments_: List[discord.File] = []\n        for i, page in enumerate(pages):\n            pages_.append(page.value)\n            if page.attachment:\n                attachments_.append(page.attachment)\n            self.select.add_option(\n                label=page.page_title,\n                value=str(i),\n                description=page.page_description,\n            )\n        super().__init__(user, pages=pages_, attachments=attachments_)\n        self.add_item(self.select)\n\n\nclass PaginatorSelect(discord.ui.Select[SelectMenuBasedPaginator[PageLike]]):\n    def __init__(self, view: SelectMenuBasedPaginator[PageLike]) -&gt; None:\n        super().__init__(min_values=1, max_values=1)\n        self.base_view = view\n\n    async def callback(self, interaction: discord.Interaction) -&gt; None:\n        # the user can only select one value and shoud at least select it\n        # so this is always fine\n        await interaction.response.defer()\n        self.base_view.current_page = int(self.values[0])\n        page = self.base_view.pages[self.base_view.current_page]\n        await self.base_view.send_page(interaction, page)\n\n    async def interaction_check(self, interaction: discord.Interaction) -&gt; bool:\n        return await self.base_view.interaction_check(interaction)\n</code></pre> <ul> <li>We define a <code>PageEntry</code> class that represents an entry in the select menu. It contains the value to be displayed: the title, the description of the page added to the select menu and an optional attachment.</li> <li>We define a <code>SelectMenuBasedPaginator</code> class that extends <code>BasePaginator</code> and adds a select menu for navigating between pages.</li> <li>The <code>SelectMenuBasedPaginator</code> class takes a list of <code>PageEntry</code> objects as input and creates a select menu with options for each entry.</li> <li>The <code>PaginatorSelect</code> class is a custom select menu that handles user interactions and updates the current page based on the selected option and sends the new page to the user.</li> </ul> <p>Here is how you can use the <code>SelectMenuBasedPaginator</code> class:</p> StringsEmbedsFiles <pre><code>import discord\nfrom discord.ext import commands\nfrom paginators.select_paginator import SelectMenuBasedPaginator, PageEntry\n\nclass StringSelectPaginator(SelectMenuBasedPaginator[str]):\n    def __init__(self, user: Union[discord.User, discord.Member], *, pages: List[PageEntry[str]]) -&gt; None:\n        super().__init__(user, pages=pages)\n\n# Assuming a bot command\n@bot.tree.command()\nasync def paginate(inter: discord.Interaction):\n    pages = [\n        PageEntry(\"Page 1\", page_title=\"Page 1\", page_description=\"This is page 1\"),\n        PageEntry(\"Page 2\", page_title=\"Page 2\", page_description=\"This is page 2\"),\n        PageEntry(\"Page 3\", page_title=\"Page 3\", page_description=\"This is page 3\"),\n    ]\n    paginator = StringSelectPaginator(inter.user, pages=pages)\n    await paginator.start_paginator(inter)\n\n@bot.tree.command()\nasync def paginate_with_attachments(inter: discord.Interaction):\n    pages = [\n        PageEntry(\"Page 1\", page_title=\"Page 1\", page_description=\"This is page 1\", attachment=discord.File(\"assets/1.png\")),\n        PageEntry(\"Page 2\", page_title=\"Page 2\", page_description=\"This is page 2\", attachment=discord.File(\"assets/2.png\")),\n        PageEntry(\"Page 3\", page_title=\"Page 3\", page_description=\"This is page 3\", attachment=discord.File(\"assets/3.png\")),\n    ]\n    paginator = StringSelectPaginator(inter.user, pages=pages)\n    await paginator.start_paginator(inter)\n</code></pre> <pre><code>import discord\nfrom discord.ext import commands\nfrom paginators.select_paginator import SelectMenuBasedPaginator, PageEntry\n\nclass EmbedSelectPaginator(SelectMenuBasedPaginator[discord.Embed]):\n    def __init__(self, user: Union[discord.User, discord.Member], *, pages: List[PageEntry[discord.Embed]]) -&gt; None:\n        super().__init__(user, pages=pages)\n\n# Assuming a bot command\n@bot.tree.command()\nasync def paginate(inter: discord.Interaction):\n    pages = [\n        PageEntry(\n            discord.Embed(title=\"Page 1\", description=\"This is page 1\"),\n            page_title=\"Page 1\",\n            page_description=\"This is page 1\",\n        ),\n        PageEntry(\n            discord.Embed(title=\"Page 2\", description=\"This is page 2\"),\n            page_title=\"Page 2\",\n            page_description=\"This is page 2\",\n        ),\n        PageEntry(\n            discord.Embed(title=\"Page 3\", description=\"This is page 3\"),\n            page_title=\"Page 3\",\n            page_description=\"This is page 3\",\n        ),\n    ]\n    paginator = EmbedSelectPaginator(inter.user, pages=pages)\n    await paginator.start_paginator(inter)\n\n@bot.tree.command()\nasync def paginate_with_attachments(inter: discord.Interaction):\n    pages = [\n        PageEntry(\n            discord.Embed(title=\"Page 1\", description=\"This is page 1\"),\n            page_title=\"Page 1\",\n            page_description=\"This is page 1\",\n            attachment=discord.File(\"assets/1.png\"),\n        ),\n        PageEntry(\n            discord.Embed(title=\"Page 2\", description=\"This is page 2\"),\n            page_title=\"Page 2\",\n            page_description=\"This is page 2\",\n            attachment=discord.File(\"assets/2.png\"),\n        ),\n        PageEntry(\n            discord.Embed(title=\"Page 3\", description=\"This is page 3\"),\n            page_title=\"Page 3\",\n            page_description=\"This is page 3\",\n            attachment=discord.File(\"assets/3.png\"),\n        ),\n    ]\n    paginator = EmbedSelectPaginator(inter.user, pages=pages)\n    await paginator.start_paginator(inter)\n</code></pre> <pre><code>import discord\nfrom discord.ext import commands\nfrom paginators.select_paginator import SelectMenuBasedPaginator, PageEntry\n\nclass FileSelectPaginator(SelectMenuBasedPaginator[FileLike]):\n    def __init__(self, user: Union[discord.User, discord.Member], *, pages: List[PageEntry[FileLike]]) -&gt; None:\n        super().__init__(user, pages=pages)\n\n# Assuming a bot command\n@bot.tree.command()\nasync def paginate(inter: discord.Interaction):\n    pages = [\n        PageEntry(discord.File(\"assets/1.png\"), page_title=\"Page 1\", page_description=\"This is page 1\"),\n        PageEntry(discord.File(\"assets/2.png\"), page_title=\"Page 2\", page_description=\"This is page 2\"),\n        PageEntry(discord.File(\"assets/3.png\"), page_title=\"Page 3\", page_description=\"This is page 3\"),\n    ]\n    paginator = FileSelectPaginator(inter.user, pages=pages)\n    await paginator.start_paginator(inter)\n</code></pre>"},{"location":"pagination/#hybrid-pagination","title":"Hybrid Pagination","text":"<p>Finally you could have a combination or hybrid of both lists and dictionaries nested within each other.</p> <pre><code>data = {\n    \"Fruits\": [\"Apple\", \"Banana\", \"Cherry\"],\n    \"Vegetables\": [\"Carrot\", \"Broccoli\", \"Spinach\"],\n    \"Grains\": [\"Rice\", \"Wheat\", \"Barley\"]\n}\n</code></pre> StringsEmbedsFilesEmbeds with Attachments <p></p> <p></p> <p></p> <p></p> paginators/advanced_paginator.py<pre><code>from __future__ import annotations\n\nfrom typing import Generic, List, Optional, TypeVar, Union\n\nimport discord\nfrom discord import File, Member, User\nfrom paginators import PageLike\nfrom paginators.button_paginator import ButtonBasedPaginator\n\nT = TypeVar(\"T\", bound=PageLike)\n\n\nclass CategoryEntry(Generic[T]):\n    def __init__(\n        self,\n        *,\n        category_title: str,\n        category_description: Optional[str] = None,\n        pages: Optional[List[T]] = None,\n        attachments: Optional[List[File]] = None,\n    ) -&gt; None:\n        self.category_title = category_title\n        self.category_description = category_description\n        self.pages = pages or []\n        self.attachments = attachments or []\n\n    def add_page(self, page: T) -&gt; None:\n        self.pages.append(page)\n\n\nclass CategoryBasedPaginator(Generic[T], ButtonBasedPaginator[T]):\n    def __init__(\n        self,\n        user: Union[User, Member],\n        *,\n        pages: List[CategoryEntry[T]],\n    ) -&gt; None:\n        self.categories = pages\n        self.current_category: int = 0\n\n        super().__init__(user, pages[self.current_category].pages, attachments=pages[self.current_category].attachments)\n\n        self.select = CategoryPaginatorSelect()\n        for i, page in enumerate(pages):\n            self.select.add_option(\n                label=page.category_title,\n                value=str(i),\n                description=page.category_description,\n            )\n        self.add_item(self.select)\n\n\nclass CategoryPaginatorSelect(discord.ui.Select[CategoryBasedPaginator[PageLike]]):\n    def __init__(self) -&gt; None:\n        super().__init__(min_values=1, max_values=1)\n\n    async def callback(self, interaction: discord.Interaction) -&gt; None:\n        # the user can only select one value and shoud at least select it\n        # so this is always fine\n        await interaction.response.defer()\n        self.view.current_category = int(self.values[0])\n        view: CategoryBasedPaginator[PageLike] = self.view\n        view.pages = view.categories[self.view.current_category].pages\n        view.attachments = view.categories[self.view.current_category].attachments\n        view.current_page = 0\n        page = view.pages[view.current_page]\n        await view.send_page(interaction, page)\n\n    async def interaction_check(self, interaction: discord.Interaction) -&gt; bool:\n        return await self.view.interaction_check(interaction)\n</code></pre> <ul> <li>We define a <code>CategoryEntry</code> class that represents a category in the paginator. It contains the value to be displayed: the title, the description of the category, a list of pages and an optional list of attachments.</li> <li>We define a <code>CategoryBasedPaginator</code> class that extends <code>ButtonBasedPaginator</code> and adds a select menu for navigating between categories.</li> <li>The <code>CategoryBasedPaginator</code> class takes a list of <code>CategoryEntry</code> objects as input and creates a select menu with options for each category.</li> <li>The <code>CategoryPaginatorSelect</code> class is a custom select menu that handles user interactions and updates the current category based on the selected option and sends the first page of the new category to the user.</li> </ul> <p>Here is how you can use the <code>CategoryBasedPaginator</code> class:</p> StringsEmbedsFiles <pre><code>import discord\nfrom discord.ext import commands\nfrom paginators.advanced_paginator import CategoryBasedPaginator, CategoryEntry\n\nclass StringCategoryPaginator(CategoryBasedPaginator[str]):\n    def __init__(self, user: Union[discord.User, discord.Member], *, pages: List[CategoryEntry[str]]) -&gt; None:\n        super().__init__(user, pages=pages)\n\n# Assuming a bot command\n@bot.tree.command()\nasync def paginate(inter: discord.Interaction):\n    pages = [\n        CategoryEntry(\n            category_title=\"Fruits\",\n            category_description=\"A list of fruits\",\n            pages=[\"Apple\", \"Banana\", \"Cherry\"],\n        ),\n        CategoryEntry(\n            category_title=\"Vegetables\",\n            category_description=\"A list of vegetables\",\n            pages=[\"Carrot\", \"Broccoli\", \"Spinach\"],\n        ),\n        CategoryEntry(\n            category_title=\"Grains\",\n            category_description=\"A list of grains\",\n            pages=[\"Rice\", \"Wheat\", \"Barley\"],\n        ),\n    ]\n    paginator = StringCategoryPaginator(inter.user, pages=pages)\n    await paginator.start_paginator(inter)\n\n@bot.tree.command()\nasync def paginate_with_attachments(inter: discord.Interaction):\n    pages = [\n        CategoryEntry(\n            category_title=\"Fruits\",\n            category_description=\"A list of fruits\",\n            pages=[\"Apple\", \"Banana\", \"Cherry\"],\n            attachments=[discord.File(\"assets/1.png\"), discord.File(\"assets/2.png\"), discord.File(\"assets/3.png\")],\n        ),\n        CategoryEntry(\n            category_title=\"Vegetables\",\n            category_description=\"A list of vegetables\",\n            pages=[\"Carrot\", \"Broccoli\", \"Spinach\"],\n            attachments=[discord.File(\"assets/4.png\"), discord.File(\"assets/5.png\"), discord.File(\"assets/6.png\")],\n        ),\n        CategoryEntry(\n            category_title=\"Grains\",\n            category_description=\"A list of grains\",\n            pages=[\"Rice\", \"Wheat\", \"Barley\"],\n            attachments=[discord.File(\"assets/7.png\"), discord.File(\"assets/8.png\"), discord.File(\"assets/9.png\")],\n        ),\n    ]\n    paginator = StringCategoryPaginator(inter, pages=pages)\n    await paginator.start_paginator(inter)\n</code></pre> <pre><code>import discord\nfrom discord.ext import commands\nfrom paginators.advanced_paginator import CategoryBasedPaginator, CategoryEntry\n\nclass EmbedCategoryPaginator(CategoryBasedPaginator[discord.Embed]):\n    def __init__(self, user: Union[discord.User, discord.Member], *, pages: List[CategoryEntry[discord.Embed]]) -&gt; None:\n        super().__init__(user, pages=pages)\n\n# Assuming a bot command\n@bot.tree.command()\nasync def paginate(inter: discord.Interaction):\n    pages = [\n        CategoryEntry(\n            category_title=\"Fruits\",\n            category_description=\"A list of fruits\",\n            pages=[\n                discord.Embed(title=\"Apple\", description=\"A red fruit\"),\n                discord.Embed(title=\"Banana\", description=\"A yellow fruit\"),\n                discord.Embed(title=\"Cherry\", description=\"A red fruit\"),\n            ],\n        ),\n        CategoryEntry(\n            category_title=\"Vegetables\",\n            category_description=\"A list of vegetables\",\n            pages=[\n                discord.Embed(title=\"Carrot\", description=\"An orange vegetable\"),\n                discord.Embed(title=\"Broccoli\", description=\"A green vegetable\"),\n                discord.Embed(title=\"Spinach\", description=\"A green vegetable\"),\n            ],\n        ),\n        CategoryEntry(\n            category_title=\"Grains\",\n            category_description=\"A list of grains\",\n            pages=[\n                discord.Embed(title=\"Rice\", description=\"A white grain\"),\n                discord.Embed(title=\"Wheat\", description=\"A brown grain\"),\n                discord.Embed(title=\"Barley\", description=\"A yellow grain\"),\n            ],\n        ),\n    ]\n    paginator = EmbedCategoryPaginator(inter.user, pages=pages)\n    await paginator.start_paginator(inter)\n\n@bot.tree.command()\nasync def paginate_with_attachments(inter: discord.Interaction):\n    pages = [\n        CategoryEntry(\n            category_title=\"Fruits\",\n            category_description=\"A list of fruits\",\n            pages=[\n                discord.Embed(title=\"Apple\", description=\"A red fruit\"),\n                discord.Embed(title=\"Banana\", description=\"A yellow fruit\"),\n                discord.Embed(title=\"Cherry\", description=\"A red fruit\"),\n            ],\n            attachments=[discord.File(\"assets/1.png\"), discord.File(\"assets/2.png\"), discord.File(\"assets/3.png\")],\n        ),\n        CategoryEntry(\n            category_title=\"Vegetables\",\n            category_description=\"A list of vegetables\",\n            pages=[\n                discord.Embed(title=\"Carrot\", description=\"An orange vegetable\"),\n                discord.Embed(title=\"Broccoli\", description=\"A green vegetable\"),\n                discord.Embed(title=\"Spinach\", description=\"A green vegetable\"),\n            ],\n            attachments=[discord.File(\"assets/4.png\"), discord.File(\"assets/5.png\"), discord.File(\"assets/6.png\")],\n        ),\n        CategoryEntry(\n            category_title=\"Grains\",\n            category_description=\"A list of grains\",\n            pages=[\n                discord.Embed(title=\"Rice\", description=\"A white grain\"),\n                discord.Embed(title=\"Wheat\", description=\"A brown grain\"),\n                discord.Embed(title=\"Barley\", description=\"A yellow grain\"),\n            ],\n            attachments=[discord.File(\"assets/7.png\"), discord.File(\"assets/8.png\"), discord.File(\"assets/9.png\")],\n        ),\n    ]\n    paginator = EmbedCategoryPaginator(inter.user, pages=pages)\n    await paginator.start_paginator(inter)\n</code></pre> <pre><code>import discord\nfrom discord.ext import commands\nfrom paginators.advanced_paginator import CategoryBasedPaginator, CategoryEntry\n\nclass FileCategoryPaginator(CategoryBasedPaginator[FileLike]):\n    def __init__(self, user: Union[discord.User, discord.Member], *, pages: List[CategoryEntry[FileLike]]) -&gt; None:\n        super().__init__(user, pages=pages)\n\n# Assuming a bot command\n@bot.tree.command()\nasync def paginate(inter: discord.Interaction):\n    pages = [\n        CategoryEntry(\n            category_title=\"Fruits\",\n            category_description=\"A list of fruits\",\n            pages=[discord.File(\"assets/1.png\"), discord.File(\"assets/2.png\"), discord.File(\"assets/3.png\")],\n        ),\n        CategoryEntry(\n            category_title=\"Vegetables\",\n            category_description=\"A list of vegetables\",\n            pages=[discord.File(\"assets/4.png\"), discord.File(\"assets/5.png\"), discord.File(\"assets/6.png\")],\n        ),\n        CategoryEntry(\n            category_title=\"Grains\",\n            category_description=\"A list of grains\",\n            pages=[discord.File(\"assets/7.png\"), discord.File(\"assets/8.png\"), discord.File(\"assets/9.png\")],\n        ),\n    ]\n    paginator = FileCategoryPaginator(inter.user, pages=pages)\n    await paginator.start_paginator(inter)\n</code></pre> <p>And that's it! You've now implemented a pagination system for your discord bot using views and interactions. You can customize the pagination logic, user interface, and interaction handling to suit your specific use case and provide a better user experience.</p> <p>You can copy and paste the code snippets above into your project and modify them as needed to fit your requirements. Here is the directory structure for the files we created:</p> <pre><code>.\n\u251c\u2500\u2500 assets\n\u2502   \u251c\u2500\u2500 1.png\n\u2502   \u251c\u2500\u2500 2.png\n\u2502   \u251c\u2500\u2500 3.png\n\u2502   \u251c\u2500\u2500 4.png\n\u2502   \u251c\u2500\u2500 5.png\n\u2502   \u251c\u2500\u2500 6.png\n\u2502   \u251c\u2500\u2500 7.png\n\u2502   \u251c\u2500\u2500 8.png\n\u2502   \u2514\u2500\u2500 9.png\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 paginators\n\u2502   \u251c\u2500\u2500 __init__.py  # Contains the BasePaginator class\n\u2502   \u251c\u2500\u2500 advanced_paginator.py\n\u2502   \u251c\u2500\u2500 button_paginator.py\n\u2502   \u2514\u2500\u2500 select_paginator.py\n\u2514\u2500\u2500 views\n    \u2514\u2500\u2500 __init__.py  # Contains the BaseView class\n</code></pre>"},{"location":"pagination/#conclusion","title":"Conclusion","text":"<p>In this guide, we've covered the basics of pagination in discord bots and how to implement it using views and interactions. We've also explored different types of pagination interfaces, such as button-based and select-based pagination, and how to use them with different types of data.</p> <p>By understanding the key components of pagination and how they interact with each other, you can create a smooth and intuitive pagination system for your discord bot.</p>"},{"location":"slash-commands/","title":"Slash Commands","text":"<p>A slash command is one of the types of application commands a bot can create. Unlike prefix and hybrid commands, these do not require the message content intent.</p> <p>Application commands are native ways to interact with apps in the Discord client. There are 3 types of commands accessible in different interfaces: the chat input, a message's context menu (top-right menu or right-clicking in a message), and a user's context menu (right-clicking on a user).</p> <p></p> <p>Note</p> <p>By default, slash commands are available globally. This means that they can be used in anywhere from servers to DMs. However, you can also limit them to specific guilds and set permissions for them.</p>"},{"location":"slash-commands/#the-commandtree","title":"The CommandTree","text":"<p>The <code>CommandTree</code> is the main container class defined by <code>discord.py</code> for slash commands. It is used to register and manage all slash commands and provides an interface for interacting with them.</p> <p>To use the slash commands registered in the <code>CommandTree</code>, you also need to sync them with Discord. This is done by calling <code>CommandTree.sync()</code>. When you sync your commands, the metadata for the commands is sent to Discord and Discord will create the commands for you which you can access from the Discord client.</p> <p>When invoking a slash command, Discord will send an interaction to your bot and the callback you defined for the command will be called.</p> <p>When you call <code>CommandTree.sync</code>, you sync one scope of the CommandTree, either the list of global commands <code>(sync())</code> or the list for one guild <code>(sync(guild=discord.Object(...)))</code>.</p> <p>You can read more about how to sync commands in the Syncing Commands section.</p> Using commands.BotUsing discord.Client <p>If you are using <code>commands.Bot</code>, you can directly access the <code>CommandTree</code> through the <code>commands.Bot.tree</code> attribute as the tree is already instantiated for you when you create the bot.</p> <pre><code>from discord.ext import commands\n\nbot = commands.Bot(...)\ntree = bot.tree\n</code></pre> <p>If you are using <code>discord.Client</code>, you need to instantiate the <code>CommandTree</code> yourself.</p> <pre><code>import discord\nfrom discord import app_commands\n\nclient = discord.Client(...)\ntree = app_commands.CommandTree(client)\n# protip: you set the tree as an attribute of the client for easy access\nclient.tree = tree\n</code></pre>"},{"location":"slash-commands/#creating-a-slash-command","title":"Creating a Slash Command","text":"<p>To create a slash command, you can use the <code>CommandTree.command</code> decorator. Unlike prefix and hybrid commands, here instead of a <code>commands.Context</code> object, you get a <code>discord.Interaction</code> object. This object contains all the information about the interaction, including the command name, the guild it was used in, the user who used it, etc.</p> <p>The <code>discord.Interaction</code> object also has a <code>response</code> attribute which is a <code>discord.InteractionResponse</code> object. This object is used to send responses to the interaction. Unlike the <code>commands.Context</code> object, you can only send one response per interaction and any further responses need to be sent as followups.</p> <p>Similarly to regular and hybrid commands, you can pass in a <code>name</code> argument to the decorator to set the name of the command. If you do not pass in a name, the name of the function will be used as the name of the command.</p> <p>There are two ways to document slash commands. You can either use the <code>app_commands.describe</code> decorator or docstrings. <code>discord.py</code> accepts multiple docstring formats, including Google-style, NumPy-style, and Sphinx-style.</p> Using ParametersUsing Docstrings <pre><code>import discord\nfrom discord import app_commands\nfrom discord.ext import commands\n\n@bot.tree.command(name=\"echo\", description=\"Echoes a message.\")\n@app_commands.describe(message=\"The message to echo.\")\nasync def echo(interaction: discord.Interaction, message: str) -&gt; None:\n    await interaction.response.send_message(message)\n</code></pre> <pre><code>import discord\nfrom discord.ext import commands\n\n@bot.tree.command()\nasync def echo(interaction: discord.Interaction, message: str) -&gt; None:\n    \"\"\"\n    Echoes a message.\n\n    Parameters\n    ----------\n    interaction : discord.Interaction\n        The interaction object.\n    message : str\n        The message to echo.\n    \"\"\"\n    await interaction.response.send_message(message)\n</code></pre> <p> </p>"},{"location":"slash-commands/#sending-responses","title":"Sending Responses","text":"<p>To send a response to an interaction, you can use the <code>discord.InteractionResponse.send_message</code> method. This method is same as your usual <code>commands.Context.send</code> method and takes in the same arguments.</p> <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, message: str) -&gt; None:\n    await interaction.response.send_message(message)\n</code></pre> <p>You can only send one response per interaction. Any further responses will lead to <code>InteractionResponded</code> error.</p> <pre><code>@bot.tree.command()\nasync def ping(inter: discord.Interaction) -&gt; None:\n    \"\"\"Get the bot's latency\"\"\"\n    await inter.response.send_message(f\"Pong! ({round(bot.latency * 1000)}ms)\")\n    try:\n        await inter.response.send_message(f\"Trying to send a second message...\")\n    except discord.InteractionResponded:\n        await inter.followup.send(f\"Responding again failed, as expected.\")\n</code></pre> <p></p> <p>If you do not send a response, the interaction will be marked as failed and the user will be notified that the interaction failed.</p> <p></p>"},{"location":"slash-commands/#sending-followups","title":"Sending Followups","text":"<p>To send followups, you can use the <code>discord.Interaction.followup.send</code> method. This method is same as your usual <code>commands.Context.reply</code> method and basically replies to your original response. A followup message can be sent only after you have sent a response.</p> <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, message: str) -&gt; None:\n    await interaction.response.send_message(message)\n    await interaction.followup.send(\"This is a followup message.\")\n</code></pre> <p>Warning</p> <p>You can send as many followups as you want, but you can only have one response per interaction.</p> <pre><code>@bot.tree.command()\nasync def ping(inter: discord.Interaction) -&gt; None:\n    \"\"\"Get the bot's latency\"\"\"\n    await inter.response.send_message(f\"Pong! ({round(bot.latency * 1000)}ms)\")\n    try:\n        await inter.response.send_message(f\"Trying to send a second message...\")\n    except discord.InteractionResponded:\n        await inter.followup.send(f\"Responding again failed, as expected.\")\n    await inter.followup.send(\"Trying to send a second message...\")\n</code></pre> <p></p> <p>You can send followups only for <code>15 minutes</code> after the interaction was created. To check if you can send followups, you can use the <code>discord.Interaction.is_expired()</code> method.`</p>"},{"location":"slash-commands/#editing-responses","title":"Editing Responses","text":"<p>To edit a response, you can use the <code>discord.Interaction.edit_original_response</code> method.</p> <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, message: str) -&gt; None:\n    await interaction.response.send_message(message)\n    await interaction.edit_original_response(\"This is an edited message.\")\n</code></pre> <p></p>"},{"location":"slash-commands/#deleting-responses","title":"Deleting Responses","text":"<p>To delete a response, you can use the <code>discord.Interaction.delete_original_response</code> method.</p> <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, message: str) -&gt; None:\n    await interaction.response.send_message(message)\n    await interaction.delete_original_response()\n</code></pre>"},{"location":"slash-commands/#deferring-responses","title":"Deferring Responses","text":"<p>You have <code>3 seconds</code> to respond to an interaction if you delay the response, otherwise the interaction will be marked as failed and the user will be notified that the interaction failed. To make sure that you can respond to the interaction, you can defer the response. This will make the user see a loading state until you send a response and will give you <code>15 minutes</code> to respond to the interaction.</p> <p>To defer a response, you can use the <code>discord.InteractionResponse.defer</code> method. After deferring the response, you can no longer use the <code>send_message</code> method to send a response. Instead, you need to use the <code>edit_original_response</code> method to edit the deferred response.</p> <pre><code>import asyncio\n\n@bot.tree.command()\nasync def echo(interaction: discord.Interaction, message: str) -&gt; None:\n    await interaction.response.defer()\n    await asyncio.sleep(5)\n    await interaction.edit_original_response(content=message)\n</code></pre> <p></p>"},{"location":"slash-commands/#ephemeral-responses","title":"Ephemeral Responses","text":"<p>You can send ephemeral responses to an interaction. These responses are only visible to the user who used the command and are not visible to other users. To send an ephemeral response, you can use the <code>discord.InteractionResponse.send_message</code> method and pass in <code>ephemeral=True</code>, or if you are using the <code>discord.InteractionResponse.defer</code> method, you can pass in <code>ephemeral=True</code> to <code>defer</code> method.</p> Using <code>send_message</code>Using <code>defer</code> <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, message: str) -&gt; None:\n    await interaction.response.send_message(message, ephemeral=True)\n</code></pre> <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, message: str) -&gt; None:\n    await interaction.response.defer(ephemeral=True)\n    await asyncio.sleep(5)\n    await interaction.edit_original_response(content=message)\n</code></pre> <p></p>"},{"location":"slash-commands/#slash-command-parameters","title":"Slash Command Parameters","text":"<p>Slash commands, have a few parameters that are supported by discord when registering the command.</p> <ul> <li><code>str [AppCommandOptionType.string]</code> - A string parameter</li> <li><code>int [AppCommandOptionType.integer]</code> - An integer parameter</li> <li><code>float [AppCommandOptionType.number]</code> - A float parameter</li> <li><code>bool [AppCommandOptionType.boolean]</code> - A boolean parameter</li> <li><code>discord.User [AppCommandOptionType.user]</code> or <code>discord.Member</code> - A user or member parameter. A user annotation can also result in a member parameter.</li> <li>* <code>discord.abc.GuildChannel</code> - A channel parameter</li> <li><code>discord.Role [AppCommandOptionType.role]</code> - A role parameter</li> <li><code>discord.Attachment [AppCommandOptionType.attachment]</code> - An attachment parameter</li> </ul> <p>All other parameters will be treated as a string parameter and can be converted implicitly using transformers.</p> <p>Info</p> <ul> <li> <p>* All channel subclasses and unions (e.g. Union[TextChannel, StageChannel]) are also supported.</p> </li> <li> <p>Some combinations of types are also allowed, including:</p> <ul> <li>Union[User, Member] (results in AppCommandOptionType.user)</li> <li>Union[Member, Role] (results in AppCommandOptionType.mentionable)</li> <li>Union[User, Role] (results in AppCommandOptionType.mentionable)</li> <li>Union[User, Member, Role] (results in AppCommandOptionType.mentionable)</li> </ul> </li> </ul> StringIntegerFloatBooleanUserChannelRoleAttachment <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, message: str) -&gt; None:\n    \"\"\"\n    Echoes a message\n\n    Parameters\n    ----------\n    interaction : discord.Interaction\n        The interaction object.\n    message : str\n        The message to echo.\n    \"\"\"\n    await interaction.response.send_message(message)\n</code></pre> <p></p> <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, number: int) -&gt; None:\n    \"\"\"\n    Echoes a number\n\n    Parameters\n    ----------\n    interaction : discord.Interaction\n        The interaction object.\n    number : int\n        The number to echo.\n    \"\"\"\n    await interaction.response.send_message(number)\n</code></pre> <p></p> <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, number: float) -&gt; None:\n    \"\"\"\n    Echoes a number\n\n    Parameters\n    ----------\n    interaction : discord.Interaction\n        The interaction object.\n    number : float\n        The number to echo.\n    \"\"\"\n    await interaction.response.send_message(number)\n</code></pre> <p></p> <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, boolean: bool) -&gt; None:\n    \"\"\"\n    Echoes a boolean\n\n    Parameters\n    ----------\n    interaction : discord.Interaction\n        The interaction object.\n    boolean : bool\n        The boolean to echo.\n    \"\"\"\n    await interaction.response.send_message(boolean)\n</code></pre> <p></p> <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, user: discord.User) -&gt; None:\n    \"\"\"\n    Echoes a user\n\n    Parameters\n    ----------\n    interaction : discord.Interaction\n        The interaction object.\n    user : discord.User\n        The user to echo.\n    \"\"\"\n    embed = discord.Embed(title=user.name, description=f\"{user.mention} is cool\", color=discord.Color.random())\n    embed.set_thumbnail(url=user.display_avatar)\n    await interaction.response.send_message(embed=embed)\n</code></pre> <p></p> <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, channel: discord.abc.GuildChannel) -&gt; None:\n    \"\"\"\n    Echoes a channel\n\n    Parameters\n    ----------\n    interaction : discord.Interaction\n        The interaction object.\n    channel : discord.abc.GuildChannel\n        The channel to echo.\n    \"\"\"\n    # channel types include StageChannel, TextChannel, VoiceChannel, CategoryChannel, ForumChannel\n    await interaction.response.send_message(channel.mention)\n</code></pre> <p></p> <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, role: discord.Role) -&gt; None:\n    \"\"\"\n    Echoes a role\n\n    Parameters\n    ----------\n    interaction : discord.Interaction\n        The interaction object.\n    role : discord.Role\n        The role to echo.\n    \"\"\"\n    embed = discord.Embed(title=role.name, description=f\"{role.mention} is cool\", color=role.color)\n    await interaction.response.send_message(embed=embed)\n</code></pre> <p></p> <pre><code>@bot.tree.command()\nasync def echo(interaction: discord.Interaction, attachment: discord.Attachment):\n    \"\"\"\n    Echoes an attachment\n\n    Parameters\n    ----------\n    interaction : discord.Interaction\n        The interaction object.\n    attachment: discord.Attachment\n        The attachment to echo\n    \"\"\"\n    embed = discord.Embed(title=attachment.filename, description=f\"Attachment from {attachment.url}\\nSize: {attachment.size / 1024} KB\", color=discord.Color.random())\n    embed.set_image(url=attachment.url)\n    await interaction.response.send_message(embed=embed)\n</code></pre> <p></p>"},{"location":"slash-commands/#parameter-ranges","title":"Parameter Ranges","text":"<p>You can also specify a range for integer and float parameters. This can be done by annotating using <code>app_commands.Range</code>, and for string you can specify the minimum and maximum length.</p> IntegerFloatString <pre><code>@bot.tree.command()\nasync def echo(inter: discord.Interaction, number: app_commands.Range[int, 0, 10]):\n    \"\"\"\n    Echoes a number\n\n    Parameters\n    ----------\n    inter: discord.Interaction\n        The interaction object\n    number: app_commands.Range[int, 0, 10]\n        The number to echo\n    \"\"\"\n    await inter.response.send_message(number)\n</code></pre> <p></p> <pre><code>@bot.tree.command()\nasync def echo(inter: discord.Interaction, number: app_commands.Range[float, 0.0, 10.0]):\n    \"\"\"\n    Echoes a number\n\n    Parameters\n    ----------\n    inter: discord.Interaction\n        The interaction object\n    number: app_commands.Range[float, 0.0, 10.0]\n        The number to echo\n    \"\"\"\n    await inter.response.send_message(number)\n</code></pre> <p></p> <pre><code>@bot.tree.command()\nasync def echo(inter: discord.Interaction, message: app_commands.Range[str, 1, 10]):\n    \"\"\"\n    Echoes a message\n\n    Parameters\n    ----------\n    inter: discord.Interaction\n        The interaction object\n    message: app_commands.Range[str, 1, 10]\n        The message to echo\n    \"\"\"\n    await inter.response.send_message(message)\n</code></pre> <p></p>"},{"location":"slash-commands/#choices","title":"Choices","text":"<p>You can also specify choices for parameters. This gives a dropdown menu with the specified choices for the parameter in discord.</p> Using EnumsUsing LiteralUsing Decorator <pre><code>import enum\n\nclass Color(str, enum.Enum):\n    Red = \"red\"\n    Green = \"green\"\n    Blue = \"blue\"\n\n@bot.tree.command()\nasync def echo(inter: discord.Interaction, color: Color):\n    \"\"\"\n    Echoes a color\n\n    Parameters\n    ----------\n    inter: discord.Interaction\n        The interaction object\n    color: Color\n        The color to echo\n    \"\"\"\n    await inter.response.send_message(color)\n</code></pre> <pre><code>from typing import Literal\n\n@bot.tree.command()\nasync def echo(inter: discord.Interaction, color: Literal[\"red\", \"green\", \"blue\"]):\n    \"\"\"\n    Echoes a color\n\n    Parameters\n    ----------\n    inter: discord.Interaction\n        The interaction object\n    color: Literal[\"red\", \"green\", \"blue\"]\n        The color to echo\n    \"\"\"\n    await inter.response.send_message(color)\n</code></pre> <pre><code>@bot.tree.command()\n@app_commands.choices(color=[\n    app_commands.Choice(name=\"Red\", value=\"red\"),\n    app_commands.Choice(name=\"Green\", value=\"green\"),\n    app_commands.Choice(name=\"Blue\", value=\"blue\")\n])\nasync def echo(inter: discord.Interaction, color: str):\n    \"\"\"\n    Echoes a color\n\n    Parameters\n    ----------\n    inter: discord.Interaction\n        The interaction object\n    color: str\n        The color to echo\n    \"\"\"\n    await inter.response.send_message(color)\n</code></pre> <p></p> <p>Warning</p> <p>You can have a maximum of 25 choices.</p>"},{"location":"slash-commands/#autocomplete","title":"Autocomplete","text":"<p>You can also specify autocomplete options for parameters. This gives a dropdown menu with the specified autocomplete options for the parameter in discord based on the user's input.</p> <p>Currently, autocomplete is only supported for string, integer and float parameters.</p> Using CallbackUsing Decorator <pre><code>async def color_autocomplete(interaction: discord.Interaction, current: str) -&gt; list[app_commands.Choice[str]]:\n    options = [\"Red\", \"Green\", \"Blue\"]\n    return [app_commands.Choice(name=option, value=option) for option in options if option.lower().startswith(current.lower())][:25]\n\n@bot.tree.command()\n@app_commands.autocomplete(color=color_autocomplete)\nasync def echo(inter: discord.Interaction, color: str):\n    \"\"\"\n    Echoes a color\n\n    Parameters\n    ----------\n    inter: discord.Interaction\n        The interaction object\n    color: str\n        The color to echo\n    \"\"\"\n    await inter.response.send_message(color)\n</code></pre> <pre><code>@bot.tree.command()\nasync def echo(inter: discord.Interaction, color: str):\n    \"\"\"\n    Echoes a color\n\n    Parameters\n    ----------\n    inter: discord.Interaction\n        The interaction object\n    color: str\n        The color to echo\n    \"\"\"\n    await inter.response.send_message(color)\n\n@echo.autocomplete(\"color\")\nasync def color_autocomplete(interaction: discord.Interaction, current: str) -&gt; list[app_commands.Choice[str]]:\n    options = [\"Red\", \"Green\", \"Blue\"]\n    return [app_commands.Choice(name=option, value=option) for option in options if option.lower().startswith(current.lower())][:25]\n</code></pre> <p></p> <p>Warning</p> <p>You can have a maximum of 25 autocomplete options.</p>"},{"location":"slash-commands/#transformers","title":"Transformers","text":"<p>Transformers are equivalent to converters in regular and hybrid commands. They are used to convert the parameter to the desired type. You can use the <code>app_commands.Transformer</code> decorator to register a transformer.</p> <p>The difference between transformers and converters are the following:</p> <ul> <li>Transformers inherit from <code>app_commands.Transformer</code> instead of <code>commands.Converter</code>.</li> <li>It requires you to implement the <code>transform</code> method instead of the <code>convert</code> method.</li> <li>Passed parameters are <code>discord.Interaction</code> instead of <code>commands.Context</code>.</li> </ul> <pre><code>class DurationConverter(app_commands.Transformer):\n    async def transform(self, inter: discord.Interaction, argument: str) -&gt; datetime.timedelta:\n        multipliers = {\n            's': 1,  # seconds\n            'm': 60,  # minutes\n            'h': 3600,  # hours\n            'd': 86400,  # days\n            'w': 604800  # weeks\n        }\n\n        try:\n            amount = int(argument[:-1])\n            unit = argument[-1]\n            seconds = amount * multipliers[unit]\n            delta = datetime.timedelta(seconds=seconds)\n            return delta\n        except (ValueError, KeyError):\n            raise commands.BadArgument(\"Invalid duration provided.\")\n\n@bot.tree.command()\nasync def echo(inter: discord.Interaction, duration: app_commands.Transform[datetime.timedelta, DurationConverter]) -&gt; None:\n    \"\"\"\n    Echoes a duration\n\n    Parameters\n    ----------\n    inter: discord.Interaction\n        The interaction object\n    duration: app_commands.Transform[datetime.timedelta, DurationConverter]\n        The duration to echo\n    \"\"\"\n    # it will work with app_commands.Transform[datetime.timedelta, DurationConverter] as well but with it duration is typed as datetime.timedelta instead of DurationConverter\n    await inter.response.send_message(duration)\n</code></pre> <p></p> <p>The core principles of transformers are the same as converters. You can read more about them in the Converters section.</p>"},{"location":"slash-commands/#slash-command-groups","title":"Slash Command Groups","text":"<p>You can also create slash command groups. These are similar to regular command groups and can be used to group slash commands together. You can create a slash command group using the <code>app_commands.Group</code> class.</p> Individual GroupSubclass GroupUsing GroupCog <pre><code>group = app_commands.Group(name=\"math\", description=\"Math commands\")\nchild = app_commands.Group(name=\"functions\", description=\"Math functions\")\n\n@child.command(name=\"pow\", description=\"Raise a number to a power\")\nasync def pow(inter: discord.Interaction, a: int, b: int) -&gt; None:\n    await inter.response.send_message(f\"{a} ^ {b} = {a ** b}\")\n\n@group.command(name=\"add\", description=\"Add two numbers\")\nasync def add(inter: discord.Interaction, a: int, b: int) -&gt; None:\n    await inter.response.send_message(f\"{a} + {b} = {a + b}\")\n\n@group.command(name=\"subtract\", description=\"Subtract two numbers\")\nasync def subtract(inter: discord.Interaction, a: int, b: int) -&gt; None:\n    await inter.response.send_message(f\"{a} - {b} = {a - b}\")\n\ngroup.add_command(child)\nbot.tree.add_command(group)\n</code></pre> <pre><code>class MathGroup(app_commands.Group):\n    def __init__(self):\n        super().__init__(name=\"math\", description=\"Math commands\")\n\n    @app_commands.command(name=\"add\", description=\"Add two numbers\")\n    async def add(self, inter: discord.Interaction, a: int, b: int) -&gt; None:\n        await inter.response.send_message(f\"{a} + {b} = {a + b}\")\n\n    @app_commands.command(name=\"subtract\", description=\"Subtract two numbers\")\n    async def subtract(self, inter: discord.Interaction, a: int, b: int) -&gt; None:\n        await inter.response.send_message(f\"{a} - {b} = {a - b}\")\n\nclass FunctionsGroup(app_commands.Group):\n    def __init__(self):\n        super().__init__(name=\"functions\", description=\"Math functions\")\n\n    @app_commands.command(name=\"pow\", description=\"Raise a number to a power\")\n    async def pow(self, inter: discord.Interaction, a: int, b: int) -&gt; None:\n        await inter.response.send_message(f\"{a} ^ {b} = {a ** b}\")\n\nparent = MathGroup()\nparent.add_command(FunctionsGroup())\nbot.tree.add_command(parent)\n</code></pre> <pre><code>import discord\nfrom discord import app_commands\nfrom discord.ext import commands\n\nclass MathGroup(commands.GroupCog, name=\"math\", description=\"Math commands\"):\n    group = app_commands.Group(name=\"functions\", description=\"Math functions\")\n\n    def __init__(self, bot: commands.Bot) -&gt; None:\n        self.bot = bot\n        super().__init__()\n\n    # available as /math functions pow &lt;a&gt; &lt;b&gt;\n    @group.command(name=\"pow\", description=\"Raise a number to a power\")\n    async def pow(self, inter: discord.Interaction, a: int, b: int) -&gt; None:\n        await inter.response.send_message(f\"{a} ^ {b} = {a ** b}\")\n\n    # available as /math add &lt;a&gt; &lt;b&gt;\n    @app_commands.command(name=\"add\", description=\"Add two numbers\")\n    async def add(self, inter: discord.Interaction, a: int, b: int) -&gt; None:\n        await inter.response.send_message(f\"{a} + {b} = {a + b}\")\n\n    # available as /math subtract &lt;a&gt; &lt;b&gt;\n    @app_commands.command(name=\"subtract\", description=\"Subtract two numbers\")\n    async def subtract(self, inter: discord.Interaction, a: int, b: int) -&gt; None:\n        await inter.response.send_message(f\"{a} - {b} = {a - b}\")\n\n    # available as /math multiply &lt;a&gt; &lt;b&gt;\n    @commands.hybrid_command(name=\"multiply\", description=\"Multiply two numbers\")\n    async def multiply(self, ctx: commands.Context[commands.Bot], a: int, b: int) -&gt; None:\n        await ctx.send(f\"{a} * {b} = {a * b}\")\n\n    # available as &lt;prefix&gt;divide &lt;a&gt; &lt;b&gt;\n    @commands.command(name=\"divide\", description=\"Divide two numbers\")\n    async def divide(self, ctx: commands.Context[commands.Bot], a: int, b: int) -&gt; None:\n        await ctx.send(f\"{a} / {b} = {a / b}\")\n\nasync def setup(bot: commands.Bot) -&gt; None:\n    await bot.add_cog(MathGroup(bot))\n</code></pre> <p>Info</p> <p>Group cogs are special cogs that are used to create slash command groups.</p> <ul> <li>They group all slash commands defined in the cog under a single slash command group.</li> <li>They group all hybrid commands defined in the cog are also grouped but they are only available as slash commands and not as regular commands.</li> <li>Regular commands are not grouped and are left as is.</li> </ul> <p></p> <p>Warning</p> <p>You can have only maximum of 1 level of nesting for slash command groups.</p>"},{"location":"slash-commands/#slash-commands-in-cogs","title":"Slash Commands in Cogs","text":"<p>Here is an example of how you can use slash commands in cogs.</p> <pre><code>import discord\nfrom discord import app_commands\nfrom discord.ext import commands\n\n\nclass General(commands.Cog):\n    group = app_commands.Group(name=\"utility\", description=\"Utility commands\")\n\n    def __init__(self, bot: commands.Bot) -&gt; None:\n        self.bot = bot\n\n    @group.command(name=\"ping\", description=\"Get the bot's latency\")\n    async def ping(self, inter: discord.Interaction) -&gt; None:\n        await inter.response.send_message(f\"Pong! {round(self.bot.latency * 1000)}ms\")\n\n    @app_commands.command(name=\"echo\", description=\"Echo a message\")\n    async def echo(self, inter: discord.Interaction, message: str) -&gt; None:\n        await inter.response.send_message(message)\n\n\nasync def setup(bot: commands.Bot) -&gt; None:\n    await bot.add_cog(General(bot))\n</code></pre> <p></p>"},{"location":"slash-commands/#error-handling-and-checks","title":"Error Handling and Checks","text":""},{"location":"slash-commands/#error-handling","title":"Error Handling","text":"<p>To handle errors in slash commands globally, you need to override the <code>CommandTree.on_error</code> method. This method is called whenever an error occurs in a slash command.</p> Using <code>on_error</code>Subclassing <code>CommandTree</code> <pre><code>from __future__ import annotations\n\nimport discord\nfrom discord import app_commands\nfrom discord.ext import commands\n\nbot = commands.Bot(...)\n\n@bot.tree.command()\nasync def test(inter: discord.Interaction) -&gt; None:\n    await inter.response.send_message(f\"{1 / 0}\")\n\n@bot.tree.error\nasync def on_error(interaction: discord.Interaction[discord.Client], error: app_commands.AppCommandError | Exception) -&gt; None:\n    if isinstance(error, app_commands.errors.CommandInvokeError):\n        error = error.original\n    message = f\"\\nException: {error.__class__.__name__}, Command: {interaction.command.qualified_name if interaction.command else None}, User: {interaction.user}, Time: {discord.utils.format_dt(interaction.created_at, style='F')}\\n\"\n    try:\n        await interaction.response.send_message(f\"An error occurred: {message}\")\n    except discord.InteractionResponded:\n        await interaction.followup.send(f\"An error occurred: {message}\")\n</code></pre> <pre><code>from __future__ import annotations\n\nimport discord\nfrom discord import app_commands\nfrom discord.ext import commands\n\nclass CustomTree(app_commands.CommandTree):\n    async def on_error(self, interaction: discord.Interaction[discord.Client], error: app_commands.AppCommandError | Exception) -&gt; None:\n        if isinstance(error, app_commands.errors.CommandInvokeError):\n            error = error.original\n        message = f\"\\nException: {error.__class__.__name__}, Command: {interaction.command.qualified_name if interaction.command else None}, User: {interaction.user}, Time: {discord.utils.format_dt(interaction.created_at, style='F')}\\n\"\n        try:\n            await interaction.response.send_message(f\"An error occurred: {message}\")\n        except discord.InteractionResponded:\n            await interaction.followup.send(f\"An error occurred: {message}\")\n\nbot = commands.Bot(..., tree_cls=CustomTree) # don't instantiate the tree yourself\n</code></pre> <p>Note</p> <p>A benefit of subclassing <code>CommandTree</code> is that you can also override other methods such as <code>interaction_check</code> to perform custom checks before invoking the command.</p>"},{"location":"slash-commands/#error-handling-in-cogs","title":"Error Handling in Cogs","text":"<p>To handle errors in slash commands in cogs, you need to override the <code>commands.Cog.cog_app_command_error</code> method. This method is called whenever an error occurs in a slash command in a cog.</p> <pre><code>from __future__ import annotations\n\nimport discord\n\nfrom discord import app_commands\nfrom discord.ext import commands\n\n\nclass General(commands.Cog):\n    def __init__(self, bot: commands.Bot) -&gt; None:\n        self.bot = bot\n\n    @bot.tree.command()\n    async def test(inter: discord.Interaction) -&gt; None:\n        await inter.response.send_message(f\"{1 / 0}\")\n\n    async def cog_app_command_error(self, inter: discord.Interaction, error: app_commands.AppCommandError | Exception) -&gt; None:\n        if isinstance(error, app_commands.errors.CommandInvokeError):\n            error = error.original\n        message = f\"\\nException: {error.__class__.__name__}, Command: {inter.command.qualified_name if inter.command else None}, User: {inter.user}, Time: {discord.utils.format_dt(inter.created_at, style='F')}\\n\"\n        try:\n            await inter.response.send_message(f\"An error occurred: {message}\")\n        except discord.InteractionResponded:\n            await inter.followup.send(f\"An error occurred: {message}\")\n\n\nasync def setup(bot: commands.Bot) -&gt; None:\n    await bot.add_cog(General(bot))\n</code></pre>"},{"location":"slash-commands/#per-command-error-handling","title":"Per-Command Error Handling","text":"<p>You can also handle errors for a specific slash commands similar to regular and hybrid commands. To do this, you need to use the <code>app_commands.error</code> decorator.</p> <pre><code>@bot.tree.command()\nasync def test(inter: discord.Interaction) -&gt; None:\n    await inter.response.send_message(f\"{1 / 0}\")\n\n@test.error\nasync def test_error(inter: discord.Interaction, error: app_commands.AppCommandError | Exception) -&gt; None:\n    if isinstance(error, app_commands.errors.CommandInvokeError):\n        error = error.original\n    message = f\"\\nException: {error.__class__.__name__}, Command: {inter.command.qualified_name if inter.command else None}, User: {inter.user}, Time: {discord.utils.format_dt(inter.created_at, style='F')}\\n\"\n    try:\n        await inter.response.send_message(f\"An error occurred: {message}\")\n    except discord.InteractionResponded:\n        await inter.followup.send(f\"An error occurred: {message}\")\n</code></pre>"},{"location":"slash-commands/#checks","title":"Checks","text":"<p>You can also use checks to check if a user is allowed to use a slash command. These checks are same as regular and hybrid commands and can be used to check if a user is allowed to use a slash command.</p> <p>Here is how to make a custom check for slash commands.</p> Using In-built DecoratorUsing Decorator <pre><code>from __future__ import annotations\n\nimport discord\nfrom discord import app_commands\nfrom discord.ext import commands\n\nbot = commands.Bot(...)\n\nasync def is_owner(inter: discord.Interaction) -&gt; bool:\n    return inter.user.id == 1234567890\n\n@bot.tree.command()\n@app_commands.check(is_owner)\nasync def test(inter: discord.Interaction) -&gt; None:\n    await inter.response.send_message(\"You are the owner!\")\n</code></pre> <pre><code>from __future__ import annotations\n\nimport discord\nfrom discord import app_commands\nfrom discord.ext import commands\n\nbot = commands.Bot(...)\n\ndef is_owner():\n    async def predicate(inter: discord.Interaction) -&gt; bool:\n        return inter.user.id == 1234567890\n    return app_commands.check(predicate)\n\n@bot.tree.command()\n@is_owner()\nasync def test(inter: discord.Interaction) -&gt; None:\n    await inter.response.send_message(\"You are the owner!\")\n</code></pre> <p>Further documentation on checks can be found in the Checks section.</p>"},{"location":"slash-commands/#permissions","title":"Permissions","text":""},{"location":"slash-commands/#app_commandsdefault_permissions","title":"<code>app_commands.default_permissions</code>","text":"<p>You can set the default permissions for a hybrid command using the <code>app_commands.default_permissions</code> decorator. This will set the default permissions for the slash command.</p> <p>Leaving the <code>permissions</code> parameter empty will disable the command for everyone except server administrators.</p> <pre><code>@bot.tree.command()\n@app_commands.default_permissions(permissions=discord.Permissions(manage_messages=True))\nasync def echo(inter: discord.Interaction, message: str):\n    \"\"\"\n    Echoes a message\n\n    Parameters\n    ----------\n    inter: discord.Interaction\n        The interaction object\n    message: str\n        The message to echo\n    \"\"\"\n    await interaction.response.send_message(message)\n</code></pre> <p>Can be used as a <code>kwarg</code> for <code>Group</code> as well.</p> <pre><code>group = app_commands.Group(name=\"utility\", description=\"Utility commands\", default_permissions=discord.Permissions(manage_messages=True))\n</code></pre>"},{"location":"slash-commands/#app_commandsguilds","title":"<code>app_commands.guilds</code>","text":"<p>You can also specify the guilds where the command should be enabled using the <code>app_commands.guilds</code> decorator. This will set the guilds where the slash command should be enabled.</p> <pre><code>@bot.tree.command()\n@app_commands.guilds(discord.Object(id=1234567890), ...)\nasync def echo(inter: discord.Interaction, message: str):\n    \"\"\"\n    Echoes a message\n\n    Parameters\n    ----------\n    inter: discord.Interaction\n        The interaction object\n    message: str\n        The message to echo\n    \"\"\"\n    await interaction.response.send_message(message)\n</code></pre> <p>Can be used as a <code>kwarg</code> for <code>Group</code> as well.</p> <pre><code>group = app_commands.Group(name=\"utility\", description=\"Utility commands\", guild_ids=[discord.Object(id=1234567890), ...])\n</code></pre>"},{"location":"slash-commands/#app_commandsguild_only","title":"<code>app_commands.guild_only</code>","text":"<p>You can also specify that the command should only be enabled in guilds using the <code>app_commands.guild_only</code> decorator. This will set the command to only be enabled in guilds and will not be available in DMs.</p> <pre><code>@bot.tree.command()\n@app_commands.guild_only()\nasync def echo(inter: discord.Interaction, message: str):\n    \"\"\"\n    Echoes a message\n\n    Parameters\n    ----------\n    inter: discord.Interaction\n        The interaction object\n    message: str\n        The message to echo\n    \"\"\"\n    await interaction.response.send_message(message)\n</code></pre> <p>Can be used as a <code>kwarg</code> for <code>Group</code> as well and as a decorator for <code>GroupCog</code>.</p> <pre><code>@app_commands.guild_only()\nclass UtilityGroup(commands.GroupCog, name=\"utility\", description=\"Utility commands\"):\n    ...\n</code></pre> <pre><code>group = app_commands.Group(name=\"utility\", description=\"Utility commands\", guild_only=True)\n</code></pre>"},{"location":"slash-commands/#user-commands","title":"User Commands","text":"<p>You can access these commands by right clicking on a user profile &gt; <code>Apps</code> &gt; <code>Commands</code>. These allow a command to be invoked on a user, without any arguments or text input.</p> Using DecoratorIn Cogs <pre><code>@bot.tree.context_menu(name=\"info\")\nasync def info(inter: discord.Interaction, member: discord.Member) -&gt; None:\n    embed = discord.Embed(title=member.name, description=f\"{member.mention} is cool\", color=member.color)\n    embed.set_thumbnail(url=member.display_avatar)\n    await inter.response.send_message(embed=embed)\n</code></pre> <pre><code>from __future__ import annotations\n\nimport discord\nfrom discord import app_commands\nfrom discord.ext import commands\n\n\nclass Cog(commands.Cog):\n    def __init__(self, bot: commands.Bot) -&gt; None:\n        self.bot = bot\n        self.user_menu = app_commands.ContextMenu(callback=self.info, name=\"info\")\n        self.user_menu.error(self.info_error)\n        self.bot.tree.add_command(self.user_menu)\n\n    async def info(self, inter: discord.Interaction, member: discord.Member) -&gt; None:\n        embed = discord.Embed(title=member.name, description=f\"{member.mention} is cool\", color=member.color)\n        embed.set_thumbnail(url=member.display_avatar)\n        await inter.response.send_message(embed=embed)\n\n    async def info_error(self, inter: discord.Interaction, error: app_commands.AppCommandError | Exception) -&gt; None:\n        if isinstance(error, app_commands.errors.CommandInvokeError):\n            error = error.original\n        message = f\"\\nException: {error.__class__.__name__}, Command: {inter.command.qualified_name if inter.command else None}, User: {inter.user}, Time: {discord.utils.format_dt(inter.created_at, style='F')}\\n\"\n        try:\n            await inter.response.send_message(f\"An error occurred: {message}\")\n        except discord.InteractionResponded:\n            await inter.followup.send(f\"An error occurred: {message}\")\n\n\nasync def setup(bot: commands.Bot) -&gt; None:\n    await bot.add_cog(Cog(bot))\n</code></pre> <p> </p>"},{"location":"slash-commands/#message-commands","title":"Message Commands","text":"<p>You can access these commands by right clicking on a message &gt; <code>Apps</code> &gt; <code>Commands</code>. These allow a command to be invoked on a message, without any arguments or text input.</p> Using DecoratorIn Cogs <pre><code>@bot.tree.context_menu(name=\"info\")\nasync def count(inter: discord.Interaction, message: discord.Message) -&gt; None:\n    await inter.response.send_message(f\"Message count: {len(message.content)} - Word count: {len(message.content.split())}\")\n</code></pre> <pre><code>from __future__ import annotations\n\nimport discord\nfrom discord import app_commands\nfrom discord.ext import commands\n\n\nclass Cog(commands.Cog):\n    def __init__(self, bot: commands.Bot) -&gt; None:\n        self.bot = bot\n        self.message_menu = app_commands.ContextMenu(callback=self.count, name=\"count\")\n        self.message_menu.error(self.count_error)\n        self.bot.tree.add_command(self.message_menu)\n\n    async def count(self, inter: discord.Interaction, message: discord.Message) -&gt; None:\n        await inter.response.send_message(f\"Message count: {len(message.content)} - Word count: {len(message.content.split())}\")\n\n    async def count_error(self, inter: discord.Interaction, error: app_commands.AppCommandError | Exception) -&gt; None:\n        if isinstance(error, app_commands.errors.CommandInvokeError):\n            error = error.original\n        message = f\"\\nException: {error.__class__.__name__}, Command: {inter.command.qualified_name if inter.command else None}, User: {inter.user}, Time: {discord.utils.format_dt(inter.created_at, style='F')}\\n\"\n        try:\n            await inter.response.send_message(f\"An error occurred: {message}\")\n        except discord.InteractionResponded:\n            await inter.followup.send(f\"An error occurred: {message}\")\n\n\nasync def setup(bot: commands.Bot) -&gt; None:\n    await bot.add_cog(Cog(bot))\n</code></pre> <p> </p>"},{"location":"slash-commands/#localization","title":"Localization","text":"<p>Localization is supported for slash commands. It allows you to translate all slash command details such as name, description, choices, autocomplete options, etc to different languages for your bot.</p> <pre><code>from __future__ import annotations\n\nfrom discord import app_commands\nfrom discord.app_commands.translator import TranslationContextTypes, locale_str\nfrom discord.enums import Locale\n\nfrom gpytranslate import Translator as GoogleTranslator\n\n\nclass Translator(app_commands.Translator):\n\n    async def translate(self, string: locale_str, locale: Locale, context: TranslationContextTypes) -&gt; str | None:\n        t = GoogleTranslator()\n        try:\n            translation = await t.translate(string.message, sourcelang=\"en\", targetlang=locale.value)\n            return translation.text  # type: ignore\n        except Exception:\n            return None\n\n\nbot = commands.Bot(...)\n\nasync def setup_hook() -&gt; None:\n    await bot.tree.set_translator(Translator())\n    await bot.tree.sync()\n\nbot.setup_hook = setup_hook\n\n@bot.tree.command(name=locale_str(\"test\"), description=locale_str(\"A test command\"))\n@app_commands.choices(test=[\n    app_commands.Choice(name=locale_str('One'), value=1),\n    app_commands.Choice(name=locale_str('Two'), value=2),\n    app_commands.Choice(name=locale_str('Three'), value=3),\n])\n@app_commands.describe(test=locale_str(\"A test choice\"))\nasync def translations(interaction: discord.Interaction, test: app_commands.Choice[int]) -&gt; None:\n    await interaction.response.send_message(repr(test))\n\nbot.run(...)\n</code></pre> <p> </p> <p>Tip</p> <p>Here I am using gpytranslate to translate the strings. You can use any translation library you want. Just make sure that your translation happens asynchronously. In case you are utilizing a synchronous translation library, you can use the following code.</p> <p>It's recommended to translate them one time separately and store them in a dictionary and then use that dictionary to translate the strings so as to prevent getting rate limited by the translation API.</p> <pre><code># loop is the bot's event loop i.e asyncio.get_event_loop()\ntranslation = await self.bot.loop.run_in_executor(None, functools.partial(&lt;function&gt;, &lt;arg1&gt;, &lt;arg2&gt;, ...))\n</code></pre> <p>Failure</p> <p>While translating with the <code>gpytranslate</code> library, I ran into invalid characters in the translated string in languages <code>romanian</code>, <code>vietnamese</code> and <code>turkish</code>. I am not sure if this is a problem with the library or <code>Google Translate API</code> itself. If you run into the same error feel free to either open an issue on the library's repository or use a different translation library.</p>"},{"location":"slash-commands/#syncing","title":"Syncing","text":"<p>You can sync your slash commands with discord using the <code>CommandTree.sync</code> method. This will sync all the slash commands in your tree with discord.</p> <p>For information on how to sync your slash commands, refer to the Syncing section in the hybrid commands documentation.</p>"},{"location":"slash-commands/#conclusion","title":"Conclusion","text":"<p>Slash commands are a great way to interact with your bot. They are easy to use and can be used to create a wide variety of commands with amazing interactivity thanks to interface with discord's user interface.</p>"},{"location":"tasks/","title":"Tasks","text":"<p>One of the most common things you will often find yourself needing is some sort of background task. This could be anything from updating a counter every minute to updating some leaderboard every hour or posting daily reminders. To handle these tasks, discord.py provides a <code>tasks</code> extension that makes it easy to create and manage background tasks.</p> <p>The <code>tasks</code> extension is a wrapper around the <code>asyncio.Task</code> class that allows you to run a coroutine in the background at a specified interval, with a lot of additional features like error handling, reconnect logic, exponential backoff, and more.</p>"},{"location":"tasks/#creating-a-task","title":"Creating a task","text":"<p>To create a task you need to make an <code>async</code> function that you want to run in the task and apply <code>tasks.loop</code> decorator on it.</p> <p>It takes the following arguments:</p> <ul> <li><code>seconds</code>: The number of seconds between each iteration.</li> <li><code>minutes</code>: The number of minutes between each iteration.</li> <li><code>hours</code>: The number of hours between each iteration.</li> <li><code>time</code>: A <code>datetime.time</code> or a list of <code>datetime.time</code> objects representing the time(s) of day to run the task.</li> <li><code>count</code>: The number of times to run the task. If <code>None</code>, the task will run indefinitely.</li> <li><code>reconnect</code>: Whether to handle errors and restart the task using an exponential backoff strategy. Defaults to <code>True</code>. For more information see here.</li> <li><code>name</code>: The name of the task. If <code>None</code>, the function name will be used.</li> </ul> <p>Then you can start it by using it's <code>start</code> method. This will schedule the task to run in the background.</p> Using a CogStandalone <pre><code>from discord.ext import commands, tasks\n\nclass MyCog(commands.Cog):\n    def __init__(self, bot):\n        self.bot = bot\n\n    # you can start the task when the cog is loaded\n    async def cog_load(self):\n        self.my_task.start()\n\n    # you can stop the task when the cog is unloaded\n    async def cog_unload(self):\n        self.my_task.stop()\n\n    @tasks.loop(seconds=10)\n    async def my_task(self):\n        print(\"Hello!\")\n\nasync def setup(bot):\n    bot.add_cog(MyCog(bot))\n</code></pre> <pre><code>from discord.ext import tasks\n\n@tasks.loop(seconds=10)\nasync def my_task():\n    print(\"Hello!\")\n\nclass MyBot(commands.Bot):\n    async def setup_hook(self):  # setup_hook is called before the bot starts\n        my_task.start()\n\nbot = MyBot(command_prefix=\"!\", intents=intents)\n\n@my_task.before_loop\nasync def before_my_task():\n    await bot.wait_until_ready()  # wait until the bot is ready\n</code></pre> <p>Note</p> <p>The only requirement to schedule a task is to call the <code>start</code> method which you can call at an appropriate place in your code. A thing to note is that the task may start running before the bot is ready, so you may want to use <code>before_loop</code> to wait until the bot is ready if you are fetching any data from the discord API.</p>"},{"location":"tasks/#utility-decorators","title":"Utility Decorators","text":""},{"location":"tasks/#before_loop","title":"@before_loop","text":"<p>A decorator that registers a coroutine to be called before the loop starts running.</p> <pre><code>from discord.ext import tasks\n\n\n@tasks.loop(seconds=10)\nasync def my_task():\n    print(\"Hello!\")\n\n\n@my_task.before_loop\nasync def before_my_task():\n    print(\"preparing!\")\n</code></pre>"},{"location":"tasks/#after_loop","title":"@after_loop","text":"<p>A decorator that registers a coroutine to be called after the loop finishes running. You can use this to perform cleanup tasks.</p> <pre><code>from discord.ext import tasks\n\n\n@tasks.loop(seconds=10)\nasync def my_task():\n    print(\"Hello!\")\n\n\n@my_task.after_loop\nasync def after_my_task():\n    print(\"finished!\")\n</code></pre>"},{"location":"tasks/#error","title":"@error","text":"<p>A decorator that registers a coroutine to be called if the task encounters an unhandled exception.</p> <p>The coroutine must take only one argument the exception raised</p> <pre><code>from discord.ext import tasks\n\n\n@tasks.loop(seconds=10)\nasync def my_task():\n    print(1 / 0)\n\n\n@my_task.error\nasync def error_handler(error: Exception):\n    print(error)\n</code></pre>"},{"location":"tasks/#cancelling-and-restarting","title":"Cancelling and Restarting","text":""},{"location":"tasks/#cancel","title":"cancel","text":"<p>Cancels the internal task, if it is running.</p> <pre><code>my_task.cancel()\n</code></pre>"},{"location":"tasks/#stop","title":"stop","text":"<p>Gracefully stops the task from running.</p> <p>Unlike cancel, this allows the task to finish its current iteration before gracefully exiting.</p> <pre><code>my_task.stop()\n</code></pre>"},{"location":"tasks/#restart","title":"restart","text":"<p>A convenience method to restart the internal task.</p> <pre><code>my_task.restart()\n</code></pre>"},{"location":"tasks/#reconnect-exceptions-handling","title":"Reconnect Exceptions Handling","text":""},{"location":"tasks/#add_exception_type","title":"add_exception_type","text":"<p>Adds exception types to be handled during the reconnect logic.</p> <p>By default the exception types handled are those handled by <code>Client.connect()</code>, which includes a lot of internet disconnection errors. This method is useful if you want to handle custom exceptions that are either raise by you or some third-party libraries.</p> <pre><code>class SomeCustomError(Exception):\n    pass\n\n@tasks.loop(seconds=10)\nasync def my_task():\n    connection = await some_third_party_library.connect()\n    print(connection)\n    if not connection:\n        raise SomeCustomError(\"Connection failed!\")\n    # do something with connection\n    connection.close()\n\nmy_task.add_exception_type(SomeCustomError) # now SomeCustomError will be handled during the reconnect logic\n</code></pre>"},{"location":"tasks/#clear_exception_types","title":"clear_exception_types","text":"<p>Removes all exception types that are handled.</p> <pre><code>my_task.clear_exception_types()\n</code></pre>"},{"location":"tasks/#remove_exception_type","title":"remove_exception_type","text":"<p>Removes exception types from being handled during the reconnect logic.</p> <pre><code>my_task.remove_exception_type(SomeCustomError, AnotherCustomError)\n</code></pre>"},{"location":"tasks/#changing-interval","title":"Changing Interval","text":""},{"location":"tasks/#change_interval","title":"change_interval","text":"<p>Changes the interval for the sleep time.</p> <pre><code>from discord.ext import tasks\n\n\n@tasks.loop(seconds=10)\nasync def my_task():\n    print(1 / 0)\n\n\nmy_task.change_interval(seconds=15)\n</code></pre>"},{"location":"tasks/#examples","title":"Examples","text":"<p>Check out discord.py tasks recipes for some examples on how to use tasks in your bot.</p>"},{"location":"views/","title":"Views and Components","text":"<p>Components are interactive elements that can be added to messages your bot or app sends to users. Components allow you to leverage discord's built-in UI elements to create interactive messages that users can interact with.</p> <p>View is a interface defined by discord.py that allows you to manage components and their interactions/callbacks. They are a necessary tool to create interactive messages.</p> <p>All tools for creating components are located in the <code>discord.ui</code> module.</p> <p>Here are all the components you can create:</p> <ul> <li>Button</li> <li>Select Menu<ul> <li>Select Menu</li> <li>Channel Select Menu</li> <li>Role Select Menu</li> <li>User Select Menu</li> <li>Mentionable Select Menu</li> </ul> </li> <li>Modal <ul> <li>Text Input</li> </ul> </li> </ul>"},{"location":"views/#creating-a-view","title":"Creating a View","text":"<p>To create a view, you must instantiate a subclass of <code>discord.ui.View</code> or <code>discord.ui.View</code> itself.</p> <p>Before creating a View it's necessary to take a look at few of its methods:</p> <ul> <li><code>discord.ui.View.add_item(item)</code> - Adds a component to the view.</li> <li><code>discord.ui.View.interaction_check(interaction)</code> - A check that is called when an interaction is received. If the check returns <code>True</code>, the interaction is processed. If the check returns <code>False</code>, the interaction is ignored.</li> <li><code>discord.ui.View.on_error(interaction, error, item)</code> - A method that is called when an error occurs while processing an interaction, discord.py doesn't handle errors that occur in views, so you must handle them yourself.</li> <li><code>discord.ui.View.on_timeout()</code> - A method that is called when the view times out.</li> <li><code>discord.ui.View.stop()</code> - Stops the view.</li> <li><code>discord.ui.View.wait()</code> - Waits for the view to stop. A view is stopped when <code>discord.ui.View.stop()</code> is called or when the view times out.</li> </ul>"},{"location":"views/#basic-view","title":"Basic View","text":"<p>So keeping these methods in mind, let's create a view:</p> <pre><code>from __future__ import annotations\n\nimport typing\n\nimport discord\n\n\nclass MyView(discord.ui.View):\n    message: discord.Message | None = None\n    count = 0\n\n    def __init__(self, user: discord.User | discord.Member, timeout: float = 60.0) -&gt; None:\n        super().__init__(timeout=timeout)\n        self.user = user\n\n    # checks for the view's interactions\n    async def interaction_check(self, interaction: discord.Interaction[discord.Client]) -&gt; bool:\n        # this method should return True if all checks pass, else False is returned\n        # for example, you can check if the interaction was created by the user who\n        # ran the command:\n        if interaction.user == self.user:\n            return True\n        # else send a message and return False\n        await interaction.response.send_message(f\"The command was initiated by {self.user.mention}\", ephemeral=True)\n        return False\n\n    # do stuff on timeout\n    async def on_timeout(self) -&gt; None:\n        # this method is called when the period mentioned in timeout kwarg passes.\n        # we can do tasks like disabling buttons here.\n        for button in self.children:\n            button.disabled = True  # type: ignore\n        # and update the message with the update View.\n        if self.message:\n            await self.message.edit(view=self)\n\n    # adding a component using it's decorator\n    @discord.ui.button(label=\"0\", style=discord.ButtonStyle.green, )\n    async def counter(self, inter: discord.Interaction, button: discord.ui.Button[MyView]) -&gt; None:\n        self.count+=1\n        button.label = str(self.count)\n        await inter.response.edit_message(view=self)\n\n    # error handler for the view\n    async def on_error(\n        self, interaction: discord.Interaction[discord.Client], error: Exception, item: discord.ui.Item[typing.Any]\n    ) -&gt; None:\n        tb = \"\".join(traceback.format_exception(type(error), error, error.__traceback__))\n        message = f\"An error occurred while processing the interaction for {str(item)}:\\n```py\\n{tb}\\n```\"\n        await interaction.response.send_message(message)\n\n@bot.command()\nasync def test(ctx: commands.Context[commands.Bot]) -&gt; None:\n    view = MyView(ctx.author)\n    view.message = await ctx.send(\n        embed=discord.Embed(\n            title=\"Button Counter\", description=\"Click on the button to count\", color=discord.Color.blurple()\n        ),\n        view=view,\n    )\n</code></pre> <p></p>"},{"location":"views/#working-with-views","title":"Working with Views","text":"<p>This is an advance version of the same view system with better content and error handling.</p> <pre><code># Our objectives:\n# - Create a view that handles errors\n# - Create a view that disables all components after timeout\n# - Make sure that the view only processes interactions from the user who invoked the command\n\nfrom __future__ import annotations\n\nimport typing\nimport traceback\n\nimport discord\nfrom discord.ui.select import BaseSelect\n\n\nclass BaseView(discord.ui.View):\n    interaction: discord.Interaction | None = None\n    message: discord.Message | None = None\n\n    def __init__(self, user: discord.User | discord.Member, timeout: float = 60.0):\n        super().__init__(timeout=timeout)\n        # We set the user who invoked the command as the user who can interact with the view\n        self.user = user\n\n    # make sure that the view only processes interactions from the user who invoked the command\n    async def interaction_check(self, interaction: discord.Interaction) -&gt; bool:\n        if interaction.user.id != self.user.id:\n            await interaction.response.send_message(\n                \"You cannot interact with this view.\", ephemeral=True\n            )\n            return False\n        # update the interaction attribute when a valid interaction is received\n        self.interaction = interaction\n        return True\n\n    # to handle errors we first notify the user that an error has occurred and then disable all components\n\n    def _disable_all(self) -&gt; None:\n        # disable all components\n        # so components that can be disabled are buttons and select menus\n        for item in self.children:\n            if isinstance(item, discord.ui.Button) or isinstance(item, BaseSelect):\n                item.disabled = True\n\n    # after disabling all components we need to edit the message with the new view\n    # now when editing the message there are two scenarios:\n    # 1. the view was never interacted with i.e in case of plain timeout here message attribute will come in handy\n    # 2. the view was interacted with and the interaction was processed and we have the latest interaction stored in the interaction attribute\n    async def _edit(self, **kwargs: typing.Any) -&gt; None:\n        if self.interaction is None and self.message is not None:\n            # if the view was never interacted with and the message attribute is not None, edit the message\n            await self.message.edit(**kwargs)\n        elif self.interaction is not None:\n            try:\n                # if not already responded to, respond to the interaction\n                await self.interaction.response.edit_message(**kwargs)\n            except discord.InteractionResponded:\n                # if already responded to, edit the response\n                await self.interaction.edit_original_response(**kwargs)\n\n    async def on_error(self, interaction: discord.Interaction, error: Exception, item: discord.ui.Item[BaseView]) -&gt; None:\n        tb = \"\".join(traceback.format_exception(type(error), error, error.__traceback__))\n        message = f\"An error occurred while processing the interaction for {str(item)}:\\n```py\\n{tb}\\n```\"\n        # disable all components\n        self._disable_all()\n        # edit the message with the error message\n        await self._edit(content=message, view=self)\n        # stop the view\n        self.stop()\n\n    async def on_timeout(self) -&gt; None:\n        # disable all components\n        self._disable_all()\n        # edit the message with the new view\n        await self._edit(view=self)\n</code></pre> <p>Note</p> <p>While all of this seems pretty laborious, it's pretty much just a lot of boilerplate code that you would be having to write over and over again. It's recommended to create a base view class that you can inherit from and then create your own views.</p>"},{"location":"views/#testing-our-view","title":"Testing our view","text":"<p>Now that we have created our view, let's test out wether it works as intended or not:</p> <ul> <li> <p>Lets start by testing out the <code>interaction_check</code> method:</p> <pre><code>@bot.command()\nasync def test(ctx: commands.Context):\n    \"\"\"A command to test our view\"\"\"\n    # we will set it to the bot user so that the interaction check fails\n    view = BaseView(bot.user)\n    view.add_item(discord.ui.Button(label=\"Test\", style=discord.ButtonStyle.blurple))\n    view.message = await ctx.send(\"Testing\", view=view)\n</code></pre> <p></p> </li> <li> <p>Now let's test out the <code>on_error</code> method by raising an error in the callback:</p> <pre><code>@bot.command()\nasync def test(ctx: commands.Context):\n    \"\"\"A command to test our view\"\"\"\n    view = BaseView(ctx.author)\n    view.add_item(discord.ui.Button(label=\"Test\", style=discord.ButtonStyle.blurple))\n\n    async def callback(interaction: discord.Interaction):\n        raise Exception(\"Test\")\n\n    # children is a list of all components in the view\n    view.children[0].callback = callback\n    view.message = await ctx.send(\"Testing\", view=view)\n</code></pre> <p></p> </li> <li> <p>Now let's test out the <code>on_timeout</code> method by setting the timeout to 5 seconds:</p> <pre><code>@bot.command()\nasync def test(ctx: commands.Context):\n    \"\"\"A command to test our view\"\"\"\n    view = BaseView(ctx.author, timeout=5.0)\n    view.add_item(discord.ui.Button(label=\"Test\", style=discord.ButtonStyle.blurple))\n    view.message = await ctx.send(\"Testing\", view=view)\n</code></pre> <p></p> </li> </ul>"},{"location":"views/#using-our-view","title":"Using our view","text":"<p>Now that we have created our view, let's use it to make a few simple commands:</p> A CounterA Confirmation View <pre><code>@bot.command()\nasync def counter(ctx: commands.Context):\n    \"\"\"A counter that counts from 0 to 10\"\"\"\n    # create a view\n    view = BaseView(ctx.author)\n    # create a button\n    button = discord.ui.Button(label=\"0\", style=discord.ButtonStyle.blurple)\n    # create a callback for the button\n    async def callback(interaction: discord.Interaction):\n        # update the button label\n        button.label = str(int(button.label) + 1)\n        # edit the message with the new view\n        if button.label == \"10\":\n            self._disable_all()\n            await self._edit(view=self)\n            self.stop()\n        else:\n            await self._edit(view=self)\n    # add the callback to the button\n    button.callback = callback\n    view.add_item(button)\n    # send the message with the view\n    view.message = await ctx.send(\"0-10 Counter\", view=view)\n</code></pre> <p>Now here's the same example but slightly modified to subclass our <code>BaseView</code> class:</p> <pre><code>class CounterView(BaseView):\n    @discord.ui.button(label=\"0\", style=discord.ButtonStyle.blurple)\n    async def count(self, interaction: discord.Interaction, button: discord.ui.Button[BaseView]):\n        button.label = str(int(str(button.label)) + 1)\n        if button.label == \"10\":\n            self._disable_all()\n            await self._edit(view=self)\n            self.stop()\n        else:\n            await self._edit(view=self)\n\n@bot.command()\nasync def counter(ctx: commands.Context):\n    \"\"\"A counter that counts from 0 to 10\"\"\"\n    view = CounterView(ctx.author)\n    view.message = await ctx.send(\"0-10 Counter\", view=view)\n</code></pre> <p>Would you look at that, it's so much cleaner and easier to read.</p> <p></p> <pre><code>@bot.command()\nasync def confirm(ctx: commands.Context[CustomBot], user: discord.User | discord.Member):\n    \"\"\"A confirmation view\"\"\"\n    view = BaseView(ctx.author)\n    confirm = discord.ui.Button[BaseView](label=\"Confirm\", style=discord.ButtonStyle.gray, emoji=\"\u2705\", custom_id=\"yes\")\n    cancel = discord.ui.Button[BaseView](label=\"Cancel\", style=discord.ButtonStyle.gray, emoji=\"\u274c\", custom_id=\"no\")\n\n    async def callback(interaction: discord.Interaction):\n        view.confirmed = interaction.data[\"custom_id\"] == \"yes\"\n        view._disable_all()\n        await view._edit(view=view)\n        view.stop()\n\n    confirm.callback = cancel.callback = callback\n    view.add_item(confirm)\n    view.add_item(cancel)\n    view.message = await ctx.send(\"Are you sure you want to confirm?\", view=view)\n    # wait for the view to stop\n    await view.wait()\n    await ctx.send(\"Confirmed\" if view.confirmed else \"Cancelled\")\n</code></pre> <p>And here's the same example but slightly modified to subclass our <code>BaseView</code> class:</p> <pre><code>class ConfirmationView(BaseView):\n    confirmed: bool | None = None\n\n    @discord.ui.button(label=\"Confirm\", style=discord.ButtonStyle.gray, emoji=\"\u2705\", custom_id=\"yes\")\n    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button[BaseView]):\n        self.confirmed = True\n        self._disable_all()\n        await self._edit(view=self)\n        self.stop()\n\n    @discord.ui.button(label=\"Cancel\", style=discord.ButtonStyle.gray, emoji=\"\u274c\", custom_id=\"no\")\n    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button[BaseView]):\n        self.confirmed = False\n        self._disable_all()\n        await self._edit(view=self)\n        self.stop()\n\n@bot.command()\nasync def confirm(ctx: commands.Context[CustomBot], user: discord.User | discord.Member):\n    \"\"\"A confirmation view\"\"\"\n    view = ConfirmationView(ctx.author)\n    view.message = await ctx.send(\"Are you sure you want to confirm?\", view=view)\n    # wait for the view to stop\n    await view.wait()\n    await ctx.send(\"Confirmed\" if view.confirmed else \"Cancelled\")\n</code></pre> <p></p>"},{"location":"views/#buttons","title":"Buttons","text":"<p>Buttons are interactive components that render in messages. They can be clicked by users, and send an interaction to your app when clicked. A single message can have up to <code>25</code> buttons, 5 in each row.</p> <p>Buttons have the following attributes:</p> <ul> <li><code>label</code> - The text that appears on the button.</li> <li><code>style</code> - The style of the button. Can be one of <code>discord.ButtonStyle.primary</code>, <code>discord.ButtonStyle.secondary</code>, <code>discord.ButtonStyle.success</code>, <code>discord.ButtonStyle.danger</code> or <code>discord.ButtonStyle.link</code>.</li> <li><code>emoji</code> - The emoji that appears on the button.</li> <li><code>url</code> - The url that the button links to if the style is <code>discord.ButtonStyle.link</code>.</li> <li><code>disabled</code> - Whether the button is disabled or not.</li> <li><code>custom_id</code> - The unique identifier for the button. This is used to identify the button when an interaction is received.</li> </ul> <p></p>"},{"location":"views/#creating-a-button","title":"Creating a Button","text":"<p>Buttons can be created either of two ways:  </p> <ul> <li>By instantiating a <code>discord.ui.Button</code> object and adding it to a view.</li> <li>By using the <code>discord.ui.button</code> decorator to decorate a qualified callback in a subclass of <code>discord.ui.View</code>.</li> </ul> Normal ButtonsLink ButtonsEmoji Buttons <pre><code>@bot.command()\nasync def all_buttons(ctx: commands.Context):\n    \"\"\"A command to test all button styles\"\"\"\n    view = BaseView(ctx.author)\n    styles = [\n        discord.ButtonStyle.primary,\n        discord.ButtonStyle.secondary,\n        discord.ButtonStyle.success,\n        discord.ButtonStyle.danger,\n    ]\n    for style in styles:\n        view.add_item(discord.ui.Button(label=style.name.title(), style=style))\n    view.message = await ctx.send(\"All Buttons\", view=view)\n</code></pre> <p></p> <pre><code>@bot.command()\nasync def link_button(ctx: commands.Context):\n    \"\"\"A command to test link buttons\"\"\"\n    view = BaseView(ctx.author)\n    view.add_item(discord.ui.Button(label=\"Link\", style=discord.ButtonStyle.link, url=\"https://google.com\"))\n    view.message = await ctx.send(\"Link Button\", view=view)\n</code></pre> <p></p> <p><pre><code>@bot.command()\nasync def emoji_button(ctx: commands.Context):\n    \"\"\"A command to test emoji buttons\"\"\"\n    view = BaseView(ctx.author)\n    emojis = ['\u23ee\ufe0f', '\u25c0\ufe0f', '\u23f9\ufe0f', '\u25b6\ufe0f', '\u23ed\ufe0f']\n    for emoji in emojis:\n        view.add_item(discord.ui.Button(label=emoji, style=discord.ButtonStyle.gray, emoji=emoji))\n    view.message = await ctx.send(\"Emoji Buttons\", view=view)\n</code></pre> </p> <p>Note</p> <p>You can use any emoji as a button emoji, even custom emojis. To get the emoji code for a custom emoji, type <code>\\:emoji:</code> in discord and send the message. Then copy the emoji code and paste it in the <code>emoji</code> parameter of the <code>discord.ui.Button</code> constructor.</p> <pre><code>@bot.command()\nasync def custom_emoji_button(ctx: commands.Context):\n    \"\"\"A command to test custom emoji buttons\"\"\"\n    view = BaseView(ctx.author)\n    view.add_item(discord.ui.Button(style=discord.ButtonStyle.gray, emoji=\"&lt;a:loveroll:632598533316542465&gt;\"))\n    view.message = await ctx.send(\"Custom Emoji Button\", view=view)\n</code></pre> <p></p> <p>Buttons can have <code>custom_id</code>s, which are unique identifiers that can be used to identify a button. In a given message, all buttons must have unique <code>custom_id</code>s. If two buttons have the same <code>custom_id</code>, an error will be raised.</p> <pre><code>@bot.command()\nasync def custom_id_button(ctx: commands.Context):\n    \"\"\"A command to test custom id buttons\"\"\"\n    view = BaseView(ctx.author)\n    view.add_item(discord.ui.Button(label=\"Custom ID\", style=discord.ButtonStyle.gray, custom_id=\"custom_id\"))\n\n    async def callback(interaction: discord.Interaction):\n        await view._edit(content=str(interaction.data))\n\n    view.children[0].callback = callback\n    view.message = await ctx.send(\"Custom ID Button\", view=view)\n</code></pre> <p></p> <p>One major use of custom ids is to create create persistent views. Persistent views are views that work even after the bot restarts and has no time limit.</p>"},{"location":"views/#persistent-buttons","title":"Persistent Buttons","text":"<p>In order for a view to be persistent, it must meet the following criteria:</p> <ul> <li>The timeout must be set to <code>None</code>.</li> <li>Every component in the view must have a unique <code>custom_id</code>.</li> <li>The view must be added to the bot's persistent views.</li> </ul> <pre><code>class PersistentView(discord.ui.View):\n    def __init__(self):\n        super().__init__(timeout=None)  \n        colors = [\n            discord.ButtonStyle.red,\n            discord.ButtonStyle.blurple,\n            discord.ButtonStyle.green,\n            discord.ButtonStyle.grey,\n        ]\n        for color in colors:\n            self.add_item(discord.ui.Button(label=color.name.title(), style=color, custom_id=color.name))\n            self.children[-1].callback = self.callback\n\n    async def callback(self, interaction: discord.Interaction) -&gt; None:\n        await interaction.response.send_message(f\"You clicked {interaction.data['custom_id']}\", ephemeral=True)\n\n\n@bot.command()\nasync def persistent(ctx: commands.Context):\n    \"\"\"A command to test persistent views\"\"\"\n    await ctx.send(\"Persistent View\", view=PersistentView())\n</code></pre> <p>Warning</p> <p>The persistent view needs to be added to the bot's persistent views, otherwise it will not work.</p> <p><pre><code>async def setup_hook():\n    bot.add_view(PersistentView())\n\nbot.setup_hook = setup_hook\n</code></pre> There are multiple places to add the persistent view, you can add it in the <code>setup_hook</code> or in one of the cog's <code>cog_load</code> methods. Just make sure that the view is added before the bot starts.</p> <p></p> <p>Warning</p> <p>At the time of writing this guide, the following part of persistent buttons tutorial requires the development version of discord.py. So you will have to install the development version of discord.py to <code>DynamicItem</code>s.</p> <pre><code>pip install -U git+https://github.com/Rapptz/discord.py\n</code></pre> <p>Why did we not use our <code>BaseView</code> class? Well, the <code>BaseView</code> class has attributes such as <code>message</code>, <code>interaction</code> and <code>user</code> these don't persist after the bot restarts. So to say persistent views don't have any memory of the previous state of the view. Also a large part of our base view class is dedicated to handling timeouts and disabling components after timeout, which is not necessary for persistent views.</p> <p>Ok so now that we know that memory is not persistent, how do we make it persistent? Well, one way to do it is to use a database to store the state of the view and it's related attributes such as <code>guild_id</code>, <code>channel_id</code>, <code>message_id</code> and <code>view_state</code>. Then when the bot restarts, we can fetch the view state from the database and recreate the view in the <code>interaction_check</code> method. But this is a lot of work and requires a database.</p> <p>So is there a simpler way to do this? Well, yes there is. Is it recommended? Well, depends the amount of data you want to store. So in order to deal with such cases <code>discord.py</code> provides a <code>discord.ui.DynamicItem</code> class which uses the <code>custom_id</code> of the component to store data. It takes a parameter <code>template</code> which receives a regex pattern and uses it to extract data from the <code>custom_id</code> of the component.</p> <p>Here's an example:</p> <pre><code>data = \"counter:0:user:1234567890\" # this is the data in the custom_id counter:&lt;count&gt;:user:&lt;user_id&gt;\ntemplate = re.compile(r\"counter:(?P&lt;count&gt;\\d+):user:(?P&lt;user_id&gt;\\d+)\") # this is the regex pattern\nmatch = template.match(data) # match the data with the pattern\nprint(match.groupdict()) # print the matched data\n</code></pre> <p>Important</p> <p>You can have a maximum of <code>100</code> characters in the <code>custom_id</code> of a component.</p> <p></p> <p>Now that we know how to extract data from the <code>custom_id</code> of a component, let's create a persistent counter:</p> <pre><code>from __future__ import annotations\n\nimport re\nimport typing\n\n\n# DynamicItem is used to work with custom ids of components that store the required data\nclass DynamicCounter(discord.ui.DynamicItem[discord.ui.Button[discord.ui.View]], template=r\"counter:(?P&lt;count&gt;\\d+):user:(?P&lt;user_id&gt;\\d+)\"):\n    def __init__(self, count: int, user_id: int):\n        self.count = count\n        self.user_id = user_id\n        super().__init__(\n            discord.ui.Button(\n                style=discord.ButtonStyle.blurple, label=str(count), custom_id=f\"counter:{count}:user:{user_id}\"\n            )\n        )\n\n    # This method needs to be implemented when subclassing DynamicItem\n    @classmethod\n    async def from_custom_id(cls, interaction: discord.Interaction, item: Item[typing.Any], match: re.Match[str]) -&gt; discord.ui.DynamicItem[typing.Any]:\n        return cls(int(match.group(\"count\")), int(match.group(\"user_id\")))\n\n    async def interaction_check(self, interaction: discord.Interaction) -&gt; bool:\n        return interaction.user.id == self.user_id\n\n    async def callback(self, interaction: discord.Interaction) -&gt; None:\n        self.count += 1\n        self.item.label = str(self.count)\n        self.item.custom_id = f\"counter:{self.count}:user:{self.user_id}\"\n        await interaction.response.edit_message(view=self.view)\n\n\n@bot.command()\nasync def persistent_counter(ctx: commands.Context):\n    \"\"\"A command to test persistent counters\"\"\"\n    view = discord.ui.View(timeout=None)\n    view.add_item(DynamicCounter(0, ctx.author.id))\n    await ctx.send(\"Persistent Counter\", view=view)\n</code></pre> <p></p> <p>Warning</p> <p>Similar to persistent views, dynamic items also need to be added to the bot's dynamic items.</p> <pre><code>async def setup_hook():\n    bot.add_dynamic_items(DynamicCounter)\n\nbot.setup_hook = setup_hook\n</code></pre> <p>There are multiple places to add the dynamic item, you can add it in the <code>setup_hook</code> or in one of the cog's <code>cog_load</code> methods. Just make sure that the dynamic item is added before the bot starts.</p>"},{"location":"views/#select-menus","title":"Select Menus","text":"<p>Select menus are interactive components that allow users to select one or more options from a dropdown list in messages. A single message can have up to <code>5</code> select menus and each select menu can have up to <code>25</code> options.</p> <p>Select menus have the following attributes:</p> <ul> <li><code>placeholder</code> - The text that appears on the select menu when no option is selected.</li> <li><code>min_values</code> - The minimum number of options that can be selected.</li> <li><code>max_values</code> - The maximum number of options that can be selected.</li> <li><code>options</code> - The options that appear in the select menu.</li> <li><code>disabled</code> - Whether the select menu is disabled or not.</li> <li><code>custom_id</code> - The unique identifier for the select menu. This is used to identify the select menu when an interaction is received.</li> <li><code>values</code> - The values of the selected options it's a list of strings.</li> </ul> <p></p>"},{"location":"views/#creating-a-select-menu","title":"Creating a Select Menu","text":"<p>Select menus can be created either of two ways:</p> <ul> <li>By instantiating a <code>discord.ui.Select</code> object and adding it to a view.</li> <li>By using the <code>discord.ui.select</code> decorator to decorate a qualified callback in a subclass of <code>discord.ui.View</code>.</li> </ul> Normal Select MenusChannel Select MenuRole Select MenuUser Select MenuMentionable Select Menu <pre><code>class Menu(BaseView):\n    @discord.ui.select(\n        cls=discord.ui.Select,\n        options=[discord.SelectOption(emoji=f\"{chr(127462 + i)}\", label=f\"{chr(65 + i)}\") for i in range(26)][:25],\n        placeholder=\"Select a letter\",\n        min_values=1,\n        max_values=1,\n    )\n    async def select(self, interaction: discord.Interaction, select: discord.ui.Select[Menus]) -&gt; None:\n        await interaction.response.defer()\n        await interaction.followup.send(f\"You selected {select.values[0]}\", ephemeral=True)\n\n\n@bot.command()\nasync def select_menu(ctx: commands.Context):\n    \"\"\"A command to test select menus\"\"\"\n    view = Menu(ctx.author)\n    view.message = await ctx.send(\"Select Menu\", view=view)\n</code></pre> <p></p> <pre><code>class ChannelMenu(BaseView):\n    @discord.ui.select(\n        cls=discord.ui.ChannelSelect,\n        placeholder=\"Select a channel\",\n        min_values=1,\n        max_values=1,\n    )\n    async def channel_select(self, interaction: discord.Interaction, select: discord.ui.ChannelSelect[Menus]) -&gt; None:\n        await interaction.response.defer()\n        await interaction.followup.send(f\"You selected {select.values[0]}\", ephemeral=True)\n\n\n@bot.command()\nasync def channel_select_menu(ctx: commands.Context):\n    \"\"\"A command to test channel select menus\"\"\"\n    view = ChannelMenu(ctx.author)\n    view.message = await ctx.send(\"Channel Select Menu\", view=view)\n</code></pre> <p></p> <pre><code>class RoleMenu(BaseView):\n    @discord.ui.select(\n        cls=discord.ui.RoleSelect,\n        placeholder=\"Select a role\",\n        min_values=1,\n        max_values=1,\n    )\n    async def role_select(self, interaction: discord.Interaction, select: discord.ui.RoleSelect[Menus]) -&gt; None:\n        await interaction.response.defer()\n        await interaction.followup.send(f\"You selected {select.values[0]}\", ephemeral=True)\n\n\n@bot.command()\nasync def role_select_menu(ctx: commands.Context):\n    \"\"\"A command to test role select menus\"\"\"\n    view = RoleMenu(ctx.author)\n    view.message = await ctx.send(\"Role Select Menu\", view=view)\n</code></pre> <p></p> <pre><code>class UserMenu(BaseView):\n    @discord.ui.select(\n        cls=discord.ui.UserSelect,\n        placeholder=\"Select a user\",\n        min_values=1,\n        max_values=1,\n    )\n    async def user_select(self, interaction: discord.Interaction, select: discord.ui.UserSelect[Menus]) -&gt; None:\n        await interaction.response.defer()\n        await interaction.followup.send(f\"You selected {select.values[0]}\", ephemeral=True)\n\n\n@bot.command()\nasync def user_select_menu(ctx: commands.Context):\n    \"\"\"A command to test user select menus\"\"\"\n    view = UserMenu(ctx.author)\n    view.message = await ctx.send(\"User Select Menu\", view=view)\n</code></pre> <p></p> <pre><code>class MentionableMenu(BaseView):\n    @discord.ui.select(\n        cls=discord.ui.MentionableSelect,\n        placeholder=\"Select a mentionable\",\n        min_values=1,\n        max_values=1,\n    )\n    async def mentionable_select(self, interaction: discord.Interaction, select: discord.ui.MentionableSelect[Menus]) -&gt; None:\n        await interaction.response.defer()\n        await interaction.followup.send(f\"You selected {select.values[0]}\", ephemeral=True)\n\n\n@bot.command()\nasync def mentionable_select_menu(ctx: commands.Context):\n    \"\"\"A command to test mentionable select menus\"\"\"\n    view = MentionableMenu(ctx.author)\n    view.message = await ctx.send(\"Mentionable Select Menu\", view=view)\n</code></pre> <p></p>"},{"location":"views/#persistent-select-menus","title":"Persistent Select Menus","text":"<p>In order for a view to be persistent, it must meet the following criteria:</p> <ul> <li>The timeout must be set to <code>None</code>.</li> <li>Every component in the view must have a unique <code>custom_id</code>.</li> <li>The view must be added to the bot's persistent views.</li> </ul> <pre><code>class PersistentMenu(discord.ui.View):\n    def __init__(self):\n        super().__init__(timeout=None)\n        self.menu = discord.ui.Select[PersistentMenu](\n            custom_id=\"persistent_menu\",\n            placeholder=\"Select a letter\",\n            min_values=1,\n            max_values=1,\n            options=[discord.SelectOption(emoji=f\"{chr(127462 + i)}\", label=f\"{chr(65 + i)}\") for i in range(26)][:25],\n        )\n        self.menu.callback = self.callback\n        self.add_item(self.menu)\n\n    async def callback(self, interaction: discord.Interaction) -&gt; None:\n        await interaction.response.defer()\n        assert interaction.data is not None and \"custom_id\" in interaction.data, \"Invalid interaction data\"\n        await interaction.followup.send(f\"You clicked {self.menu.values[0]}\", ephemeral=True)\n\n\n@bot.command()\nasync def persistent_select_menu(ctx: commands.Context):\n    \"\"\"A command to test persistent select menus\"\"\"\n    await ctx.send(\"Persistent Select Menu\", view=PersistentMenu())\n</code></pre> <p></p> <p>Warning</p> <p>Similar to persistent views, persistent select menus also need to be added to the bot's persistent views.</p> <pre><code>async def setup_hook():\n    bot.add_view(PersistentMenu())\n\nbot.setup_hook = setup_hook\n</code></pre> <p>There are multiple places to add the persistent select menu, you can add it in the <code>setup_hook</code> or in one of the cog's <code>cog_load</code> methods. Just make sure that the view is added before the bot starts.</p> <p>Warning</p> <p>At the time of writing this guide, the following part of persistent menus tutorial requires the development version of discord.py. So you will have to install the development version of discord.py to <code>DynamicItem</code>s.</p> <pre><code>pip install -U git+https://github.com/Rapptz/discord.py\n</code></pre> <p>Similar to how we used <code>discord.ui.DynamicItem</code> to create persistent counters with buttons, we can use <code>discord.ui.DynamicItem</code> to work with menus as well.</p> <pre><code>from __future__ import annotations\n\nimport re\nimport typing\n\nclass DynamicSelect(discord.ui.DynamicItem[discord.ui.Select[discord.ui.View]], template=r\"select-user:(?P&lt;user_id&gt;\\d+)\"):\n    def __init__(self, user_id: int):\n        self.user_id = user_id\n        super().__init__(\n            discord.ui.Select(\n                custom_id=f\"select-user:{user_id}\",\n                placeholder=\"Select a letter\",\n                min_values=1,\n                max_values=1,\n                options=[discord.SelectOption(emoji=f\"{chr(127462 + i)}\", label=f\"{chr(65 + i)}\") for i in range(26)][:25],\n            )\n        )\n\n    # This method needs to be implemented when subclassing DynamicItem\n    @classmethod\n    async def from_custom_id(cls, interaction: discord.Interaction, item: Item[typing.Any], match: re.Match[str]) -&gt; discord.ui.DynamicItem[typing.Any]:\n        return cls(int(match.group(\"user_id\")))\n\n    async def interaction_check(self, interaction: discord.Interaction) -&gt; bool:\n        return interaction.user.id == self.user_id\n\n    async def callback(self, interaction: discord.Interaction) -&gt; None:\n        await interaction.response.defer()\n        assert interaction.data is not None and \"custom_id\" in interaction.data, \"Invalid interaction data\"\n        await interaction.followup.send(f\"You clicked {self.item.values[0]}\", ephemeral=True)\n\n\n@bot.command()\nasync def persistent_dynamic_select_menu(ctx: commands.Context):\n    \"\"\"A command to test persistent dynamic select menus\"\"\"\n    view = discord.ui.View(timeout=None)\n    view.add_item(DynamicSelect(ctx.author.id))\n    await ctx.send(\"Persistent Dynamic Select Menu\", view=view)\n</code></pre> <p></p> <p>Warning</p> <p>Similar to persistent views, dynamic items also need to be added to the bot's dynamic items.</p> <pre><code>async def setup_hook():\n    bot.add_dynamic_items(DynamicSelect)\n\nbot.setup_hook = setup_hook\n</code></pre> <p>There are multiple places to add the dynamic item, you can add it in the <code>setup_hook</code> or in one of the cog's <code>cog_load</code> methods. Just make sure that the dynamic item is added before the bot starts.</p>"},{"location":"views/#modals","title":"Modals","text":"<p>Modals are how you can prompt users for further detailed input. They act as form popups, and work in tandem with interactive components called Text Inputs. These inputs can have various formats to accept information from the user on prompt, and use the callback to process that information. A modal can only have <code>Text Input</code> components.</p> <p>Like views, we need to take a look at a few of the methods of the <code>discord.ui.Modal</code> class to understand how to create a modal:</p> <ul> <li><code>on_error(interaction, error, item)</code> - A method that is called when an error occurs while processing an interaction, discord.py doesn't handle errors that occur in modals, so you must handle them yourself.</li> <li><code>on_submit(interaction)</code> - A method that is called when the modal is submitted.</li> <li><code>interaction_check(interaction)</code> - A check that is called when an interaction is received. If the check returns <code>True</code>, the interaction is processed. If the check returns <code>False</code>, the interaction is ignored.</li> <li><code>stop()</code> - Stops the modal.</li> <li><code>wait()</code> - Waits for the modal to stop. A modal is stopped when <code>discord.ui.Modal.stop()</code> is called or when the modal times out.</li> </ul> <p>So now just like how we created a base view class, let's create a base modal class:</p> <pre><code>from __future__ import annotations\n\nimport traceback\n\nimport discord\n\nclass BaseModal(discord.ui.Modal):\n    _interaction: discord.Interaction | None = None\n\n    # sets the interaction attribute when a valid interaction is received i.e modal is submitted\n    # via this we can know if the modal was submitted or it timed out\n    async def on_submit(self, interaction: discord.Interaction) -&gt; None:\n        # if not responded to, defer the interaction\n        if not interaction.response.is_done():\n            await interaction.response.defer()\n        self._interaction = interaction\n        self.stop()\n\n    # make sure any errors don't get ignored\n    async def on_error(self, interaction: discord.Interaction, error: Exception) -&gt; None:\n        tb = \"\".join(traceback.format_exception(type(error), error, error.__traceback__))\n        message = f\"An error occurred while processing the interaction:\\n```py\\n{tb}\\n```\"\n        try:\n            await interaction.response.send_message(message, ephemeral=True)\n        except discord.InteractionResponded:\n            await interaction.edit_original_response(content=message, view=None)\n        self.stop()\n\n    @property\n    def interaction(self) -&gt; discord.Interaction | None:\n        return self._interaction\n</code></pre> <p>Modals can only have text inputs, so let's take a look at the <code>discord.ui.TextInput</code> class:</p> <ul> <li><code>label</code> - The text that appears above the text input.</li> <li><code>placeholder</code> - The text that appears in the text input when no text is entered.</li> <li><code>min_length</code> - The minimum length of the text that can be entered.</li> <li><code>max_length</code> - The maximum length of the text that can be entered.</li> <li><code>style</code> - The style of the text input. Can be one of <code>discord.TextStyle.short</code>, <code>discord.TextStyle.long</code> or <code>discord.TextStyle.paragraph</code> which is just an alias for <code>discord.TextStyle.long</code>.</li> <li><code>value</code> - The value of the text input.</li> </ul> <p>With that out of the way, let's delve into testing and working with modals.</p>"},{"location":"views/#testing-our-modal","title":"Testing our modal","text":"<p>Now that we have created our modal, let's test out whether it works as intended or not:</p> <ul> <li> <p>Lets start by testing out the <code>on_error</code> method by raising an error in the callback:</p> <pre><code>import typing\n\n@bot.tree.command()\nasync def modal(inter: discord.Interaction):\n    \"\"\"A command to test modals\"\"\"\n    mymodal = BaseModal(title=\"Error Modal\")\n\n    async def callback(interaction: discord.Interaction) -&gt; None:\n        raise RuntimeError(typing.cast(discord.ui.TextInput[BaseModal], mymodal.children[0]).value)\n\n    mymodal.add_item(discord.ui.TextInput(label=\"Error\", placeholder=\"Enter an error message\", min_length=1, max_length=100))\n    mymodal.on_submit = callback\n    await inter.response.send_modal(mymodal)\n</code></pre> <p> </p> </li> <li> <p>Now let's test out the <code>on_timeout</code> method by setting the timeout to 5 seconds:</p> <pre><code>import typing\n\n@bot.tree.command()\nasync def modal(inter: discord.Interaction):\n    \"\"\"A command to test modals\"\"\"\n    mymodal = BaseModal(title=\"Timeout Modal\", timeout=5.0)\n    mymodal.add_item(discord.ui.TextInput(label=\"Timeout\", placeholder=\"Enter a timeout message\", min_length=1, max_length=100))\n    await inter.response.send_modal(mymodal)\n    await mymodal.wait()\n    await inter.followup.send(\"Modal Timed Out\" if mymodal.interaction is None else \"Modal Submitted\")\n</code></pre> <p> </p> </li> </ul>"},{"location":"views/#using-our-modal","title":"Using our modal","text":"<p>Now that we have created our modal, let's use it to make a simple <code>Tag Creation</code> system:</p> <pre><code>class TagModal(BaseModal, title=\"Tag Creation\"):\n    tag_title = discord.ui.TextInput(label=\"Tag Title\", placeholder=\"Enter a tag title\", min_length=1, max_length=100, style=discord.TextStyle.short)\n    tag_content = discord.ui.TextInput(label=\"Tag Content\", placeholder=\"Enter a tag content\", min_length=1, max_length=300, style=discord.TextStyle.long)\n\n    async def on_submit(self, interaction: discord.Interaction) -&gt; None:\n        embed = discord.Embed(title=self.tag_title.value, description=self.tag_content.value, color=discord.Color.blurple())\n        embed.set_thumbnail(url=interaction.user.display_avatar)\n        embed.timestamp = discord.utils.utcnow()\n        await interaction.response.send_message(embed=embed, ephemeral=True)\n        await super().on_submit(interaction)\n\n\n@bot.tree.command()\nasync def tag(inter: discord.Interaction):\n    \"\"\"A command to test modals\"\"\"\n    await inter.response.send_modal(TagModal())\n</code></pre> <p> </p> <p>Note</p> <p>A modal can have a total of 5 text inputs. Text inputs can have a maximum of 4000 characters.</p>"},{"location":"views/#conclusion","title":"Conclusion","text":"<p>This concludes the basics of utilizing discord components in your bot. You can use these components to create interactive commands and menus, pagination system, games, etc. The possibilities are endless.</p>"}]}